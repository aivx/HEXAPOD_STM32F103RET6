
HEXAPOD_STM32F103RET6.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001e4  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00005abc  080001f0  080001f0  000101f0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000027c  08005cac  08005cac  00015cac  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  08005f28  08005f28  00015f28  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  08005f2c  08005f2c  00015f2c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         00000010  20000000  08005f30  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          000012c4  20000010  08005f40  00020010  2**2
                  ALLOC
  7 ._user_heap_stack 00000604  200012d4  08005f40  000212d4  2**0
                  ALLOC
  8 .ARM.attributes 00000029  00000000  00000000  00020010  2**0
                  CONTENTS, READONLY
  9 .debug_info   0001aa8a  00000000  00000000  00020039  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00002c4c  00000000  00000000  0003aac3  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000c449  00000000  00000000  0003d70f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_aranges 00001300  00000000  00000000  00049b58  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00001308  00000000  00000000  0004ae58  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_macro  0001b13c  00000000  00000000  0004c160  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   00010b48  00000000  00000000  0006729c  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    000a1e97  00000000  00000000  00077de4  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      0000007b  00000000  00000000  00119c7b  2**0
                  CONTENTS, READONLY
 18 .debug_frame  000038f8  00000000  00000000  00119cf8  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080001f0 <__do_global_dtors_aux>:
 80001f0:	b510      	push	{r4, lr}
 80001f2:	4c05      	ldr	r4, [pc, #20]	; (8000208 <__do_global_dtors_aux+0x18>)
 80001f4:	7823      	ldrb	r3, [r4, #0]
 80001f6:	b933      	cbnz	r3, 8000206 <__do_global_dtors_aux+0x16>
 80001f8:	4b04      	ldr	r3, [pc, #16]	; (800020c <__do_global_dtors_aux+0x1c>)
 80001fa:	b113      	cbz	r3, 8000202 <__do_global_dtors_aux+0x12>
 80001fc:	4804      	ldr	r0, [pc, #16]	; (8000210 <__do_global_dtors_aux+0x20>)
 80001fe:	f3af 8000 	nop.w
 8000202:	2301      	movs	r3, #1
 8000204:	7023      	strb	r3, [r4, #0]
 8000206:	bd10      	pop	{r4, pc}
 8000208:	20000010 	.word	0x20000010
 800020c:	00000000 	.word	0x00000000
 8000210:	08005c94 	.word	0x08005c94

08000214 <frame_dummy>:
 8000214:	b508      	push	{r3, lr}
 8000216:	4b03      	ldr	r3, [pc, #12]	; (8000224 <frame_dummy+0x10>)
 8000218:	b11b      	cbz	r3, 8000222 <frame_dummy+0xe>
 800021a:	4903      	ldr	r1, [pc, #12]	; (8000228 <frame_dummy+0x14>)
 800021c:	4803      	ldr	r0, [pc, #12]	; (800022c <frame_dummy+0x18>)
 800021e:	f3af 8000 	nop.w
 8000222:	bd08      	pop	{r3, pc}
 8000224:	00000000 	.word	0x00000000
 8000228:	20000014 	.word	0x20000014
 800022c:	08005c94 	.word	0x08005c94

08000230 <__aeabi_frsub>:
 8000230:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
 8000234:	e002      	b.n	800023c <__addsf3>
 8000236:	bf00      	nop

08000238 <__aeabi_fsub>:
 8000238:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

0800023c <__addsf3>:
 800023c:	0042      	lsls	r2, r0, #1
 800023e:	bf1f      	itttt	ne
 8000240:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 8000244:	ea92 0f03 	teqne	r2, r3
 8000248:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 800024c:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000250:	d06a      	beq.n	8000328 <__addsf3+0xec>
 8000252:	ea4f 6212 	mov.w	r2, r2, lsr #24
 8000256:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 800025a:	bfc1      	itttt	gt
 800025c:	18d2      	addgt	r2, r2, r3
 800025e:	4041      	eorgt	r1, r0
 8000260:	4048      	eorgt	r0, r1
 8000262:	4041      	eorgt	r1, r0
 8000264:	bfb8      	it	lt
 8000266:	425b      	neglt	r3, r3
 8000268:	2b19      	cmp	r3, #25
 800026a:	bf88      	it	hi
 800026c:	4770      	bxhi	lr
 800026e:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 8000272:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000276:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 800027a:	bf18      	it	ne
 800027c:	4240      	negne	r0, r0
 800027e:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000282:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 8000286:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 800028a:	bf18      	it	ne
 800028c:	4249      	negne	r1, r1
 800028e:	ea92 0f03 	teq	r2, r3
 8000292:	d03f      	beq.n	8000314 <__addsf3+0xd8>
 8000294:	f1a2 0201 	sub.w	r2, r2, #1
 8000298:	fa41 fc03 	asr.w	ip, r1, r3
 800029c:	eb10 000c 	adds.w	r0, r0, ip
 80002a0:	f1c3 0320 	rsb	r3, r3, #32
 80002a4:	fa01 f103 	lsl.w	r1, r1, r3
 80002a8:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 80002ac:	d502      	bpl.n	80002b4 <__addsf3+0x78>
 80002ae:	4249      	negs	r1, r1
 80002b0:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 80002b4:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 80002b8:	d313      	bcc.n	80002e2 <__addsf3+0xa6>
 80002ba:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 80002be:	d306      	bcc.n	80002ce <__addsf3+0x92>
 80002c0:	0840      	lsrs	r0, r0, #1
 80002c2:	ea4f 0131 	mov.w	r1, r1, rrx
 80002c6:	f102 0201 	add.w	r2, r2, #1
 80002ca:	2afe      	cmp	r2, #254	; 0xfe
 80002cc:	d251      	bcs.n	8000372 <__addsf3+0x136>
 80002ce:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 80002d2:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80002d6:	bf08      	it	eq
 80002d8:	f020 0001 	biceq.w	r0, r0, #1
 80002dc:	ea40 0003 	orr.w	r0, r0, r3
 80002e0:	4770      	bx	lr
 80002e2:	0049      	lsls	r1, r1, #1
 80002e4:	eb40 0000 	adc.w	r0, r0, r0
 80002e8:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
 80002ec:	f1a2 0201 	sub.w	r2, r2, #1
 80002f0:	d1ed      	bne.n	80002ce <__addsf3+0x92>
 80002f2:	fab0 fc80 	clz	ip, r0
 80002f6:	f1ac 0c08 	sub.w	ip, ip, #8
 80002fa:	ebb2 020c 	subs.w	r2, r2, ip
 80002fe:	fa00 f00c 	lsl.w	r0, r0, ip
 8000302:	bfaa      	itet	ge
 8000304:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 8000308:	4252      	neglt	r2, r2
 800030a:	4318      	orrge	r0, r3
 800030c:	bfbc      	itt	lt
 800030e:	40d0      	lsrlt	r0, r2
 8000310:	4318      	orrlt	r0, r3
 8000312:	4770      	bx	lr
 8000314:	f092 0f00 	teq	r2, #0
 8000318:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
 800031c:	bf06      	itte	eq
 800031e:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
 8000322:	3201      	addeq	r2, #1
 8000324:	3b01      	subne	r3, #1
 8000326:	e7b5      	b.n	8000294 <__addsf3+0x58>
 8000328:	ea4f 0341 	mov.w	r3, r1, lsl #1
 800032c:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8000330:	bf18      	it	ne
 8000332:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000336:	d021      	beq.n	800037c <__addsf3+0x140>
 8000338:	ea92 0f03 	teq	r2, r3
 800033c:	d004      	beq.n	8000348 <__addsf3+0x10c>
 800033e:	f092 0f00 	teq	r2, #0
 8000342:	bf08      	it	eq
 8000344:	4608      	moveq	r0, r1
 8000346:	4770      	bx	lr
 8000348:	ea90 0f01 	teq	r0, r1
 800034c:	bf1c      	itt	ne
 800034e:	2000      	movne	r0, #0
 8000350:	4770      	bxne	lr
 8000352:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
 8000356:	d104      	bne.n	8000362 <__addsf3+0x126>
 8000358:	0040      	lsls	r0, r0, #1
 800035a:	bf28      	it	cs
 800035c:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
 8000360:	4770      	bx	lr
 8000362:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 8000366:	bf3c      	itt	cc
 8000368:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
 800036c:	4770      	bxcc	lr
 800036e:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 8000372:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
 8000376:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 800037a:	4770      	bx	lr
 800037c:	ea7f 6222 	mvns.w	r2, r2, asr #24
 8000380:	bf16      	itet	ne
 8000382:	4608      	movne	r0, r1
 8000384:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 8000388:	4601      	movne	r1, r0
 800038a:	0242      	lsls	r2, r0, #9
 800038c:	bf06      	itte	eq
 800038e:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 8000392:	ea90 0f01 	teqeq	r0, r1
 8000396:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
 800039a:	4770      	bx	lr

0800039c <__aeabi_ui2f>:
 800039c:	f04f 0300 	mov.w	r3, #0
 80003a0:	e004      	b.n	80003ac <__aeabi_i2f+0x8>
 80003a2:	bf00      	nop

080003a4 <__aeabi_i2f>:
 80003a4:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
 80003a8:	bf48      	it	mi
 80003aa:	4240      	negmi	r0, r0
 80003ac:	ea5f 0c00 	movs.w	ip, r0
 80003b0:	bf08      	it	eq
 80003b2:	4770      	bxeq	lr
 80003b4:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
 80003b8:	4601      	mov	r1, r0
 80003ba:	f04f 0000 	mov.w	r0, #0
 80003be:	e01c      	b.n	80003fa <__aeabi_l2f+0x2a>

080003c0 <__aeabi_ul2f>:
 80003c0:	ea50 0201 	orrs.w	r2, r0, r1
 80003c4:	bf08      	it	eq
 80003c6:	4770      	bxeq	lr
 80003c8:	f04f 0300 	mov.w	r3, #0
 80003cc:	e00a      	b.n	80003e4 <__aeabi_l2f+0x14>
 80003ce:	bf00      	nop

080003d0 <__aeabi_l2f>:
 80003d0:	ea50 0201 	orrs.w	r2, r0, r1
 80003d4:	bf08      	it	eq
 80003d6:	4770      	bxeq	lr
 80003d8:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
 80003dc:	d502      	bpl.n	80003e4 <__aeabi_l2f+0x14>
 80003de:	4240      	negs	r0, r0
 80003e0:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80003e4:	ea5f 0c01 	movs.w	ip, r1
 80003e8:	bf02      	ittt	eq
 80003ea:	4684      	moveq	ip, r0
 80003ec:	4601      	moveq	r1, r0
 80003ee:	2000      	moveq	r0, #0
 80003f0:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
 80003f4:	bf08      	it	eq
 80003f6:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
 80003fa:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 80003fe:	fabc f28c 	clz	r2, ip
 8000402:	3a08      	subs	r2, #8
 8000404:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 8000408:	db10      	blt.n	800042c <__aeabi_l2f+0x5c>
 800040a:	fa01 fc02 	lsl.w	ip, r1, r2
 800040e:	4463      	add	r3, ip
 8000410:	fa00 fc02 	lsl.w	ip, r0, r2
 8000414:	f1c2 0220 	rsb	r2, r2, #32
 8000418:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 800041c:	fa20 f202 	lsr.w	r2, r0, r2
 8000420:	eb43 0002 	adc.w	r0, r3, r2
 8000424:	bf08      	it	eq
 8000426:	f020 0001 	biceq.w	r0, r0, #1
 800042a:	4770      	bx	lr
 800042c:	f102 0220 	add.w	r2, r2, #32
 8000430:	fa01 fc02 	lsl.w	ip, r1, r2
 8000434:	f1c2 0220 	rsb	r2, r2, #32
 8000438:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 800043c:	fa21 f202 	lsr.w	r2, r1, r2
 8000440:	eb43 0002 	adc.w	r0, r3, r2
 8000444:	bf08      	it	eq
 8000446:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 800044a:	4770      	bx	lr

0800044c <__aeabi_fmul>:
 800044c:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000450:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 8000454:	bf1e      	ittt	ne
 8000456:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 800045a:	ea92 0f0c 	teqne	r2, ip
 800045e:	ea93 0f0c 	teqne	r3, ip
 8000462:	d06f      	beq.n	8000544 <__aeabi_fmul+0xf8>
 8000464:	441a      	add	r2, r3
 8000466:	ea80 0c01 	eor.w	ip, r0, r1
 800046a:	0240      	lsls	r0, r0, #9
 800046c:	bf18      	it	ne
 800046e:	ea5f 2141 	movsne.w	r1, r1, lsl #9
 8000472:	d01e      	beq.n	80004b2 <__aeabi_fmul+0x66>
 8000474:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8000478:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
 800047c:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
 8000480:	fba0 3101 	umull	r3, r1, r0, r1
 8000484:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 8000488:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 800048c:	bf3e      	ittt	cc
 800048e:	0049      	lslcc	r1, r1, #1
 8000490:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
 8000494:	005b      	lslcc	r3, r3, #1
 8000496:	ea40 0001 	orr.w	r0, r0, r1
 800049a:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
 800049e:	2afd      	cmp	r2, #253	; 0xfd
 80004a0:	d81d      	bhi.n	80004de <__aeabi_fmul+0x92>
 80004a2:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 80004a6:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80004aa:	bf08      	it	eq
 80004ac:	f020 0001 	biceq.w	r0, r0, #1
 80004b0:	4770      	bx	lr
 80004b2:	f090 0f00 	teq	r0, #0
 80004b6:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 80004ba:	bf08      	it	eq
 80004bc:	0249      	lsleq	r1, r1, #9
 80004be:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 80004c2:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
 80004c6:	3a7f      	subs	r2, #127	; 0x7f
 80004c8:	bfc2      	ittt	gt
 80004ca:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 80004ce:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 80004d2:	4770      	bxgt	lr
 80004d4:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80004d8:	f04f 0300 	mov.w	r3, #0
 80004dc:	3a01      	subs	r2, #1
 80004de:	dc5d      	bgt.n	800059c <__aeabi_fmul+0x150>
 80004e0:	f112 0f19 	cmn.w	r2, #25
 80004e4:	bfdc      	itt	le
 80004e6:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
 80004ea:	4770      	bxle	lr
 80004ec:	f1c2 0200 	rsb	r2, r2, #0
 80004f0:	0041      	lsls	r1, r0, #1
 80004f2:	fa21 f102 	lsr.w	r1, r1, r2
 80004f6:	f1c2 0220 	rsb	r2, r2, #32
 80004fa:	fa00 fc02 	lsl.w	ip, r0, r2
 80004fe:	ea5f 0031 	movs.w	r0, r1, rrx
 8000502:	f140 0000 	adc.w	r0, r0, #0
 8000506:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
 800050a:	bf08      	it	eq
 800050c:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8000510:	4770      	bx	lr
 8000512:	f092 0f00 	teq	r2, #0
 8000516:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 800051a:	bf02      	ittt	eq
 800051c:	0040      	lsleq	r0, r0, #1
 800051e:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 8000522:	3a01      	subeq	r2, #1
 8000524:	d0f9      	beq.n	800051a <__aeabi_fmul+0xce>
 8000526:	ea40 000c 	orr.w	r0, r0, ip
 800052a:	f093 0f00 	teq	r3, #0
 800052e:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000532:	bf02      	ittt	eq
 8000534:	0049      	lsleq	r1, r1, #1
 8000536:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 800053a:	3b01      	subeq	r3, #1
 800053c:	d0f9      	beq.n	8000532 <__aeabi_fmul+0xe6>
 800053e:	ea41 010c 	orr.w	r1, r1, ip
 8000542:	e78f      	b.n	8000464 <__aeabi_fmul+0x18>
 8000544:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 8000548:	ea92 0f0c 	teq	r2, ip
 800054c:	bf18      	it	ne
 800054e:	ea93 0f0c 	teqne	r3, ip
 8000552:	d00a      	beq.n	800056a <__aeabi_fmul+0x11e>
 8000554:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 8000558:	bf18      	it	ne
 800055a:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 800055e:	d1d8      	bne.n	8000512 <__aeabi_fmul+0xc6>
 8000560:	ea80 0001 	eor.w	r0, r0, r1
 8000564:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 8000568:	4770      	bx	lr
 800056a:	f090 0f00 	teq	r0, #0
 800056e:	bf17      	itett	ne
 8000570:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
 8000574:	4608      	moveq	r0, r1
 8000576:	f091 0f00 	teqne	r1, #0
 800057a:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
 800057e:	d014      	beq.n	80005aa <__aeabi_fmul+0x15e>
 8000580:	ea92 0f0c 	teq	r2, ip
 8000584:	d101      	bne.n	800058a <__aeabi_fmul+0x13e>
 8000586:	0242      	lsls	r2, r0, #9
 8000588:	d10f      	bne.n	80005aa <__aeabi_fmul+0x15e>
 800058a:	ea93 0f0c 	teq	r3, ip
 800058e:	d103      	bne.n	8000598 <__aeabi_fmul+0x14c>
 8000590:	024b      	lsls	r3, r1, #9
 8000592:	bf18      	it	ne
 8000594:	4608      	movne	r0, r1
 8000596:	d108      	bne.n	80005aa <__aeabi_fmul+0x15e>
 8000598:	ea80 0001 	eor.w	r0, r0, r1
 800059c:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 80005a0:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 80005a4:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80005a8:	4770      	bx	lr
 80005aa:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 80005ae:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
 80005b2:	4770      	bx	lr

080005b4 <__aeabi_fdiv>:
 80005b4:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80005b8:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 80005bc:	bf1e      	ittt	ne
 80005be:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 80005c2:	ea92 0f0c 	teqne	r2, ip
 80005c6:	ea93 0f0c 	teqne	r3, ip
 80005ca:	d069      	beq.n	80006a0 <__aeabi_fdiv+0xec>
 80005cc:	eba2 0203 	sub.w	r2, r2, r3
 80005d0:	ea80 0c01 	eor.w	ip, r0, r1
 80005d4:	0249      	lsls	r1, r1, #9
 80005d6:	ea4f 2040 	mov.w	r0, r0, lsl #9
 80005da:	d037      	beq.n	800064c <__aeabi_fdiv+0x98>
 80005dc:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 80005e0:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
 80005e4:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
 80005e8:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 80005ec:	428b      	cmp	r3, r1
 80005ee:	bf38      	it	cc
 80005f0:	005b      	lslcc	r3, r3, #1
 80005f2:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
 80005f6:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
 80005fa:	428b      	cmp	r3, r1
 80005fc:	bf24      	itt	cs
 80005fe:	1a5b      	subcs	r3, r3, r1
 8000600:	ea40 000c 	orrcs.w	r0, r0, ip
 8000604:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
 8000608:	bf24      	itt	cs
 800060a:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
 800060e:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000612:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
 8000616:	bf24      	itt	cs
 8000618:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
 800061c:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000620:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
 8000624:	bf24      	itt	cs
 8000626:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
 800062a:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 800062e:	011b      	lsls	r3, r3, #4
 8000630:	bf18      	it	ne
 8000632:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
 8000636:	d1e0      	bne.n	80005fa <__aeabi_fdiv+0x46>
 8000638:	2afd      	cmp	r2, #253	; 0xfd
 800063a:	f63f af50 	bhi.w	80004de <__aeabi_fmul+0x92>
 800063e:	428b      	cmp	r3, r1
 8000640:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8000644:	bf08      	it	eq
 8000646:	f020 0001 	biceq.w	r0, r0, #1
 800064a:	4770      	bx	lr
 800064c:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 8000650:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 8000654:	327f      	adds	r2, #127	; 0x7f
 8000656:	bfc2      	ittt	gt
 8000658:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 800065c:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 8000660:	4770      	bxgt	lr
 8000662:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000666:	f04f 0300 	mov.w	r3, #0
 800066a:	3a01      	subs	r2, #1
 800066c:	e737      	b.n	80004de <__aeabi_fmul+0x92>
 800066e:	f092 0f00 	teq	r2, #0
 8000672:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 8000676:	bf02      	ittt	eq
 8000678:	0040      	lsleq	r0, r0, #1
 800067a:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 800067e:	3a01      	subeq	r2, #1
 8000680:	d0f9      	beq.n	8000676 <__aeabi_fdiv+0xc2>
 8000682:	ea40 000c 	orr.w	r0, r0, ip
 8000686:	f093 0f00 	teq	r3, #0
 800068a:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 800068e:	bf02      	ittt	eq
 8000690:	0049      	lsleq	r1, r1, #1
 8000692:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 8000696:	3b01      	subeq	r3, #1
 8000698:	d0f9      	beq.n	800068e <__aeabi_fdiv+0xda>
 800069a:	ea41 010c 	orr.w	r1, r1, ip
 800069e:	e795      	b.n	80005cc <__aeabi_fdiv+0x18>
 80006a0:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 80006a4:	ea92 0f0c 	teq	r2, ip
 80006a8:	d108      	bne.n	80006bc <__aeabi_fdiv+0x108>
 80006aa:	0242      	lsls	r2, r0, #9
 80006ac:	f47f af7d 	bne.w	80005aa <__aeabi_fmul+0x15e>
 80006b0:	ea93 0f0c 	teq	r3, ip
 80006b4:	f47f af70 	bne.w	8000598 <__aeabi_fmul+0x14c>
 80006b8:	4608      	mov	r0, r1
 80006ba:	e776      	b.n	80005aa <__aeabi_fmul+0x15e>
 80006bc:	ea93 0f0c 	teq	r3, ip
 80006c0:	d104      	bne.n	80006cc <__aeabi_fdiv+0x118>
 80006c2:	024b      	lsls	r3, r1, #9
 80006c4:	f43f af4c 	beq.w	8000560 <__aeabi_fmul+0x114>
 80006c8:	4608      	mov	r0, r1
 80006ca:	e76e      	b.n	80005aa <__aeabi_fmul+0x15e>
 80006cc:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 80006d0:	bf18      	it	ne
 80006d2:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 80006d6:	d1ca      	bne.n	800066e <__aeabi_fdiv+0xba>
 80006d8:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
 80006dc:	f47f af5c 	bne.w	8000598 <__aeabi_fmul+0x14c>
 80006e0:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
 80006e4:	f47f af3c 	bne.w	8000560 <__aeabi_fmul+0x114>
 80006e8:	e75f      	b.n	80005aa <__aeabi_fmul+0x15e>
 80006ea:	bf00      	nop

080006ec <__gesf2>:
 80006ec:	f04f 3cff 	mov.w	ip, #4294967295
 80006f0:	e006      	b.n	8000700 <__cmpsf2+0x4>
 80006f2:	bf00      	nop

080006f4 <__lesf2>:
 80006f4:	f04f 0c01 	mov.w	ip, #1
 80006f8:	e002      	b.n	8000700 <__cmpsf2+0x4>
 80006fa:	bf00      	nop

080006fc <__cmpsf2>:
 80006fc:	f04f 0c01 	mov.w	ip, #1
 8000700:	f84d cd04 	str.w	ip, [sp, #-4]!
 8000704:	ea4f 0240 	mov.w	r2, r0, lsl #1
 8000708:	ea4f 0341 	mov.w	r3, r1, lsl #1
 800070c:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8000710:	bf18      	it	ne
 8000712:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000716:	d011      	beq.n	800073c <__cmpsf2+0x40>
 8000718:	b001      	add	sp, #4
 800071a:	ea52 0c53 	orrs.w	ip, r2, r3, lsr #1
 800071e:	bf18      	it	ne
 8000720:	ea90 0f01 	teqne	r0, r1
 8000724:	bf58      	it	pl
 8000726:	ebb2 0003 	subspl.w	r0, r2, r3
 800072a:	bf88      	it	hi
 800072c:	17c8      	asrhi	r0, r1, #31
 800072e:	bf38      	it	cc
 8000730:	ea6f 70e1 	mvncc.w	r0, r1, asr #31
 8000734:	bf18      	it	ne
 8000736:	f040 0001 	orrne.w	r0, r0, #1
 800073a:	4770      	bx	lr
 800073c:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8000740:	d102      	bne.n	8000748 <__cmpsf2+0x4c>
 8000742:	ea5f 2c40 	movs.w	ip, r0, lsl #9
 8000746:	d105      	bne.n	8000754 <__cmpsf2+0x58>
 8000748:	ea7f 6c23 	mvns.w	ip, r3, asr #24
 800074c:	d1e4      	bne.n	8000718 <__cmpsf2+0x1c>
 800074e:	ea5f 2c41 	movs.w	ip, r1, lsl #9
 8000752:	d0e1      	beq.n	8000718 <__cmpsf2+0x1c>
 8000754:	f85d 0b04 	ldr.w	r0, [sp], #4
 8000758:	4770      	bx	lr
 800075a:	bf00      	nop

0800075c <__aeabi_cfrcmple>:
 800075c:	4684      	mov	ip, r0
 800075e:	4608      	mov	r0, r1
 8000760:	4661      	mov	r1, ip
 8000762:	e7ff      	b.n	8000764 <__aeabi_cfcmpeq>

08000764 <__aeabi_cfcmpeq>:
 8000764:	b50f      	push	{r0, r1, r2, r3, lr}
 8000766:	f7ff ffc9 	bl	80006fc <__cmpsf2>
 800076a:	2800      	cmp	r0, #0
 800076c:	bf48      	it	mi
 800076e:	f110 0f00 	cmnmi.w	r0, #0
 8000772:	bd0f      	pop	{r0, r1, r2, r3, pc}

08000774 <__aeabi_fcmpeq>:
 8000774:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000778:	f7ff fff4 	bl	8000764 <__aeabi_cfcmpeq>
 800077c:	bf0c      	ite	eq
 800077e:	2001      	moveq	r0, #1
 8000780:	2000      	movne	r0, #0
 8000782:	f85d fb08 	ldr.w	pc, [sp], #8
 8000786:	bf00      	nop

08000788 <__aeabi_fcmplt>:
 8000788:	f84d ed08 	str.w	lr, [sp, #-8]!
 800078c:	f7ff ffea 	bl	8000764 <__aeabi_cfcmpeq>
 8000790:	bf34      	ite	cc
 8000792:	2001      	movcc	r0, #1
 8000794:	2000      	movcs	r0, #0
 8000796:	f85d fb08 	ldr.w	pc, [sp], #8
 800079a:	bf00      	nop

0800079c <__aeabi_fcmple>:
 800079c:	f84d ed08 	str.w	lr, [sp, #-8]!
 80007a0:	f7ff ffe0 	bl	8000764 <__aeabi_cfcmpeq>
 80007a4:	bf94      	ite	ls
 80007a6:	2001      	movls	r0, #1
 80007a8:	2000      	movhi	r0, #0
 80007aa:	f85d fb08 	ldr.w	pc, [sp], #8
 80007ae:	bf00      	nop

080007b0 <__aeabi_fcmpge>:
 80007b0:	f84d ed08 	str.w	lr, [sp, #-8]!
 80007b4:	f7ff ffd2 	bl	800075c <__aeabi_cfrcmple>
 80007b8:	bf94      	ite	ls
 80007ba:	2001      	movls	r0, #1
 80007bc:	2000      	movhi	r0, #0
 80007be:	f85d fb08 	ldr.w	pc, [sp], #8
 80007c2:	bf00      	nop

080007c4 <__aeabi_fcmpgt>:
 80007c4:	f84d ed08 	str.w	lr, [sp, #-8]!
 80007c8:	f7ff ffc8 	bl	800075c <__aeabi_cfrcmple>
 80007cc:	bf34      	ite	cc
 80007ce:	2001      	movcc	r0, #1
 80007d0:	2000      	movcs	r0, #0
 80007d2:	f85d fb08 	ldr.w	pc, [sp], #8
 80007d6:	bf00      	nop

080007d8 <__aeabi_f2uiz>:
 80007d8:	0042      	lsls	r2, r0, #1
 80007da:	d20e      	bcs.n	80007fa <__aeabi_f2uiz+0x22>
 80007dc:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
 80007e0:	d30b      	bcc.n	80007fa <__aeabi_f2uiz+0x22>
 80007e2:	f04f 039e 	mov.w	r3, #158	; 0x9e
 80007e6:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
 80007ea:	d409      	bmi.n	8000800 <__aeabi_f2uiz+0x28>
 80007ec:	ea4f 2300 	mov.w	r3, r0, lsl #8
 80007f0:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80007f4:	fa23 f002 	lsr.w	r0, r3, r2
 80007f8:	4770      	bx	lr
 80007fa:	f04f 0000 	mov.w	r0, #0
 80007fe:	4770      	bx	lr
 8000800:	f112 0f61 	cmn.w	r2, #97	; 0x61
 8000804:	d101      	bne.n	800080a <__aeabi_f2uiz+0x32>
 8000806:	0242      	lsls	r2, r0, #9
 8000808:	d102      	bne.n	8000810 <__aeabi_f2uiz+0x38>
 800080a:	f04f 30ff 	mov.w	r0, #4294967295
 800080e:	4770      	bx	lr
 8000810:	f04f 0000 	mov.w	r0, #0
 8000814:	4770      	bx	lr
 8000816:	bf00      	nop

08000818 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000818:	b510      	push	{r4, lr}
 800081a:	4604      	mov	r4, r0
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 800081c:	4b0e      	ldr	r3, [pc, #56]	; (8000858 <HAL_InitTick+0x40>)
 800081e:	7818      	ldrb	r0, [r3, #0]
 8000820:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8000824:	fbb3 f3f0 	udiv	r3, r3, r0
 8000828:	4a0c      	ldr	r2, [pc, #48]	; (800085c <HAL_InitTick+0x44>)
 800082a:	6810      	ldr	r0, [r2, #0]
 800082c:	fbb0 f0f3 	udiv	r0, r0, r3
 8000830:	f000 f8b6 	bl	80009a0 <HAL_SYSTICK_Config>
 8000834:	b968      	cbnz	r0, 8000852 <HAL_InitTick+0x3a>
  {
    return HAL_ERROR;
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8000836:	2c0f      	cmp	r4, #15
 8000838:	d901      	bls.n	800083e <HAL_InitTick+0x26>
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
    uwTickPrio = TickPriority;
  }
  else
  {
    return HAL_ERROR;
 800083a:	2001      	movs	r0, #1
 800083c:	e00a      	b.n	8000854 <HAL_InitTick+0x3c>
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 800083e:	2200      	movs	r2, #0
 8000840:	4621      	mov	r1, r4
 8000842:	f04f 30ff 	mov.w	r0, #4294967295
 8000846:	f000 f84d 	bl	80008e4 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 800084a:	4b03      	ldr	r3, [pc, #12]	; (8000858 <HAL_InitTick+0x40>)
 800084c:	605c      	str	r4, [r3, #4]
  }

  /* Return function status */
  return HAL_OK;
 800084e:	2000      	movs	r0, #0
 8000850:	e000      	b.n	8000854 <HAL_InitTick+0x3c>
    return HAL_ERROR;
 8000852:	2001      	movs	r0, #1
}
 8000854:	bd10      	pop	{r4, pc}
 8000856:	bf00      	nop
 8000858:	20000000 	.word	0x20000000
 800085c:	2000000c 	.word	0x2000000c

08000860 <HAL_Init>:
{
 8000860:	b508      	push	{r3, lr}
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8000862:	4a07      	ldr	r2, [pc, #28]	; (8000880 <HAL_Init+0x20>)
 8000864:	6813      	ldr	r3, [r2, #0]
 8000866:	f043 0310 	orr.w	r3, r3, #16
 800086a:	6013      	str	r3, [r2, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800086c:	2003      	movs	r0, #3
 800086e:	f000 f81b 	bl	80008a8 <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
 8000872:	200f      	movs	r0, #15
 8000874:	f7ff ffd0 	bl	8000818 <HAL_InitTick>
  HAL_MspInit();
 8000878:	f004 ff30 	bl	80056dc <HAL_MspInit>
}
 800087c:	2000      	movs	r0, #0
 800087e:	bd08      	pop	{r3, pc}
 8000880:	40022000 	.word	0x40022000

08000884 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 8000884:	4a03      	ldr	r2, [pc, #12]	; (8000894 <HAL_IncTick+0x10>)
 8000886:	6811      	ldr	r1, [r2, #0]
 8000888:	4b03      	ldr	r3, [pc, #12]	; (8000898 <HAL_IncTick+0x14>)
 800088a:	781b      	ldrb	r3, [r3, #0]
 800088c:	440b      	add	r3, r1
 800088e:	6013      	str	r3, [r2, #0]
}
 8000890:	4770      	bx	lr
 8000892:	bf00      	nop
 8000894:	20000fc8 	.word	0x20000fc8
 8000898:	20000000 	.word	0x20000000

0800089c <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 800089c:	4b01      	ldr	r3, [pc, #4]	; (80008a4 <HAL_GetTick+0x8>)
 800089e:	6818      	ldr	r0, [r3, #0]
}
 80008a0:	4770      	bx	lr
 80008a2:	bf00      	nop
 80008a4:	20000fc8 	.word	0x20000fc8

080008a8 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 80008a8:	b510      	push	{r4, lr}
 80008aa:	4604      	mov	r4, r0
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
 80008ac:	1ec3      	subs	r3, r0, #3
 80008ae:	2b04      	cmp	r3, #4
 80008b0:	d80f      	bhi.n	80008d2 <HAL_NVIC_SetPriorityGrouping+0x2a>
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80008b2:	4a0a      	ldr	r2, [pc, #40]	; (80008dc <HAL_NVIC_SetPriorityGrouping+0x34>)
 80008b4:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80008b6:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 80008ba:	041b      	lsls	r3, r3, #16
 80008bc:	0c1b      	lsrs	r3, r3, #16
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos) );               /* Insert write key and priority group */
 80008be:	0224      	lsls	r4, r4, #8
 80008c0:	f404 64e0 	and.w	r4, r4, #1792	; 0x700
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 80008c4:	4323      	orrs	r3, r4
  reg_value  =  (reg_value                                   |
 80008c6:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 80008ca:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  SCB->AIRCR =  reg_value;
 80008ce:	60d3      	str	r3, [r2, #12]
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 80008d0:	bd10      	pop	{r4, pc}
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
 80008d2:	2192      	movs	r1, #146	; 0x92
 80008d4:	4802      	ldr	r0, [pc, #8]	; (80008e0 <HAL_NVIC_SetPriorityGrouping+0x38>)
 80008d6:	f004 feff 	bl	80056d8 <assert_failed>
 80008da:	e7ea      	b.n	80008b2 <HAL_NVIC_SetPriorityGrouping+0xa>
 80008dc:	e000ed00 	.word	0xe000ed00
 80008e0:	08005d2c 	.word	0x08005d2c

080008e4 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 80008e4:	b570      	push	{r4, r5, r6, lr}
 80008e6:	4605      	mov	r5, r0
 80008e8:	460c      	mov	r4, r1
 80008ea:	4616      	mov	r6, r2
  uint32_t prioritygroup = 0x00U;
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
 80008ec:	2a0f      	cmp	r2, #15
 80008ee:	d825      	bhi.n	800093c <HAL_NVIC_SetPriority+0x58>
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
 80008f0:	2c0f      	cmp	r4, #15
 80008f2:	d828      	bhi.n	8000946 <HAL_NVIC_SetPriority+0x62>
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80008f4:	4b1b      	ldr	r3, [pc, #108]	; (8000964 <HAL_NVIC_SetPriority+0x80>)
 80008f6:	68db      	ldr	r3, [r3, #12]
 80008f8:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80008fc:	f1c3 0207 	rsb	r2, r3, #7
 8000900:	2a04      	cmp	r2, #4
 8000902:	bf28      	it	cs
 8000904:	2204      	movcs	r2, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000906:	1d19      	adds	r1, r3, #4
 8000908:	2906      	cmp	r1, #6
 800090a:	d921      	bls.n	8000950 <HAL_NVIC_SetPriority+0x6c>
 800090c:	3b03      	subs	r3, #3

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800090e:	f04f 31ff 	mov.w	r1, #4294967295
 8000912:	fa01 f202 	lsl.w	r2, r1, r2
 8000916:	ea24 0402 	bic.w	r4, r4, r2
 800091a:	409c      	lsls	r4, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800091c:	fa01 f303 	lsl.w	r3, r1, r3
 8000920:	ea26 0603 	bic.w	r6, r6, r3
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000924:	4334      	orrs	r4, r6
  if ((int32_t)(IRQn) >= 0)
 8000926:	2d00      	cmp	r5, #0
 8000928:	db14      	blt.n	8000954 <HAL_NVIC_SetPriority+0x70>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800092a:	0124      	lsls	r4, r4, #4
 800092c:	b2e4      	uxtb	r4, r4
 800092e:	f105 4560 	add.w	r5, r5, #3758096384	; 0xe0000000
 8000932:	f505 4561 	add.w	r5, r5, #57600	; 0xe100
 8000936:	f885 4300 	strb.w	r4, [r5, #768]	; 0x300
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 800093a:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
 800093c:	21aa      	movs	r1, #170	; 0xaa
 800093e:	480a      	ldr	r0, [pc, #40]	; (8000968 <HAL_NVIC_SetPriority+0x84>)
 8000940:	f004 feca 	bl	80056d8 <assert_failed>
 8000944:	e7d4      	b.n	80008f0 <HAL_NVIC_SetPriority+0xc>
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
 8000946:	21ab      	movs	r1, #171	; 0xab
 8000948:	4807      	ldr	r0, [pc, #28]	; (8000968 <HAL_NVIC_SetPriority+0x84>)
 800094a:	f004 fec5 	bl	80056d8 <assert_failed>
 800094e:	e7d1      	b.n	80008f4 <HAL_NVIC_SetPriority+0x10>
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000950:	2300      	movs	r3, #0
 8000952:	e7dc      	b.n	800090e <HAL_NVIC_SetPriority+0x2a>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000954:	f005 050f 	and.w	r5, r5, #15
 8000958:	0124      	lsls	r4, r4, #4
 800095a:	b2e4      	uxtb	r4, r4
 800095c:	4b03      	ldr	r3, [pc, #12]	; (800096c <HAL_NVIC_SetPriority+0x88>)
 800095e:	555c      	strb	r4, [r3, r5]
}
 8000960:	e7eb      	b.n	800093a <HAL_NVIC_SetPriority+0x56>
 8000962:	bf00      	nop
 8000964:	e000ed00 	.word	0xe000ed00
 8000968:	08005d2c 	.word	0x08005d2c
 800096c:	e000ed14 	.word	0xe000ed14

08000970 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f10xxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8000970:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
 8000972:	1e04      	subs	r4, r0, #0
 8000974:	db0a      	blt.n	800098c <HAL_NVIC_EnableIRQ+0x1c>
  if ((int32_t)(IRQn) >= 0)
 8000976:	2c00      	cmp	r4, #0
 8000978:	db07      	blt.n	800098a <HAL_NVIC_EnableIRQ+0x1a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800097a:	f004 021f 	and.w	r2, r4, #31
 800097e:	0964      	lsrs	r4, r4, #5
 8000980:	2301      	movs	r3, #1
 8000982:	4093      	lsls	r3, r2
 8000984:	4a04      	ldr	r2, [pc, #16]	; (8000998 <HAL_NVIC_EnableIRQ+0x28>)
 8000986:	f842 3024 	str.w	r3, [r2, r4, lsl #2]

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 800098a:	bd10      	pop	{r4, pc}
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
 800098c:	21be      	movs	r1, #190	; 0xbe
 800098e:	4803      	ldr	r0, [pc, #12]	; (800099c <HAL_NVIC_EnableIRQ+0x2c>)
 8000990:	f004 fea2 	bl	80056d8 <assert_failed>
 8000994:	e7ef      	b.n	8000976 <HAL_NVIC_EnableIRQ+0x6>
 8000996:	bf00      	nop
 8000998:	e000e100 	.word	0xe000e100
 800099c:	08005d2c 	.word	0x08005d2c

080009a0 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 80009a0:	3801      	subs	r0, #1
 80009a2:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 80009a6:	d20a      	bcs.n	80009be <HAL_SYSTICK_Config+0x1e>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80009a8:	4b06      	ldr	r3, [pc, #24]	; (80009c4 <HAL_SYSTICK_Config+0x24>)
 80009aa:	6058      	str	r0, [r3, #4]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80009ac:	4a06      	ldr	r2, [pc, #24]	; (80009c8 <HAL_SYSTICK_Config+0x28>)
 80009ae:	21f0      	movs	r1, #240	; 0xf0
 80009b0:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80009b4:	2000      	movs	r0, #0
 80009b6:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80009b8:	2207      	movs	r2, #7
 80009ba:	601a      	str	r2, [r3, #0]
 80009bc:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 80009be:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 80009c0:	4770      	bx	lr
 80009c2:	bf00      	nop
 80009c4:	e000e010 	.word	0xe000e010
 80009c8:	e000ed00 	.word	0xe000ed00

080009cc <DMA_SetConfig>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 80009cc:	b470      	push	{r4, r5, r6}
  /* Clear all flags */
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << hdma->ChannelIndex);
 80009ce:	6c06      	ldr	r6, [r0, #64]	; 0x40
 80009d0:	6bc5      	ldr	r5, [r0, #60]	; 0x3c
 80009d2:	2401      	movs	r4, #1
 80009d4:	40b4      	lsls	r4, r6
 80009d6:	606c      	str	r4, [r5, #4]

  /* Configure DMA Channel data length */
  hdma->Instance->CNDTR = DataLength;
 80009d8:	6804      	ldr	r4, [r0, #0]
 80009da:	6063      	str	r3, [r4, #4]

  /* Memory to Peripheral */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 80009dc:	6843      	ldr	r3, [r0, #4]
 80009de:	2b10      	cmp	r3, #16
 80009e0:	d005      	beq.n	80009ee <DMA_SetConfig+0x22>
  }
  /* Peripheral to Memory */
  else
  {
    /* Configure DMA Channel source address */
    hdma->Instance->CPAR = SrcAddress;
 80009e2:	6803      	ldr	r3, [r0, #0]
 80009e4:	6099      	str	r1, [r3, #8]

    /* Configure DMA Channel destination address */
    hdma->Instance->CMAR = DstAddress;
 80009e6:	6803      	ldr	r3, [r0, #0]
 80009e8:	60da      	str	r2, [r3, #12]
  }
}
 80009ea:	bc70      	pop	{r4, r5, r6}
 80009ec:	4770      	bx	lr
    hdma->Instance->CPAR = DstAddress;
 80009ee:	6803      	ldr	r3, [r0, #0]
 80009f0:	609a      	str	r2, [r3, #8]
    hdma->Instance->CMAR = SrcAddress;
 80009f2:	6803      	ldr	r3, [r0, #0]
 80009f4:	60d9      	str	r1, [r3, #12]
 80009f6:	e7f8      	b.n	80009ea <DMA_SetConfig+0x1e>

080009f8 <HAL_DMA_Init>:
  if(hdma == NULL)
 80009f8:	2800      	cmp	r0, #0
 80009fa:	f000 80b8 	beq.w	8000b6e <HAL_DMA_Init+0x176>
{
 80009fe:	b510      	push	{r4, lr}
 8000a00:	4604      	mov	r4, r0
  assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));
 8000a02:	6803      	ldr	r3, [r0, #0]
 8000a04:	4a5b      	ldr	r2, [pc, #364]	; (8000b74 <HAL_DMA_Init+0x17c>)
 8000a06:	4293      	cmp	r3, r2
 8000a08:	d025      	beq.n	8000a56 <HAL_DMA_Init+0x5e>
 8000a0a:	3214      	adds	r2, #20
 8000a0c:	4293      	cmp	r3, r2
 8000a0e:	d022      	beq.n	8000a56 <HAL_DMA_Init+0x5e>
 8000a10:	3214      	adds	r2, #20
 8000a12:	4293      	cmp	r3, r2
 8000a14:	d01f      	beq.n	8000a56 <HAL_DMA_Init+0x5e>
 8000a16:	3214      	adds	r2, #20
 8000a18:	4293      	cmp	r3, r2
 8000a1a:	d01c      	beq.n	8000a56 <HAL_DMA_Init+0x5e>
 8000a1c:	3214      	adds	r2, #20
 8000a1e:	4293      	cmp	r3, r2
 8000a20:	d019      	beq.n	8000a56 <HAL_DMA_Init+0x5e>
 8000a22:	3214      	adds	r2, #20
 8000a24:	4293      	cmp	r3, r2
 8000a26:	d016      	beq.n	8000a56 <HAL_DMA_Init+0x5e>
 8000a28:	3214      	adds	r2, #20
 8000a2a:	4293      	cmp	r3, r2
 8000a2c:	d013      	beq.n	8000a56 <HAL_DMA_Init+0x5e>
 8000a2e:	f502 7262 	add.w	r2, r2, #904	; 0x388
 8000a32:	4293      	cmp	r3, r2
 8000a34:	d00f      	beq.n	8000a56 <HAL_DMA_Init+0x5e>
 8000a36:	3214      	adds	r2, #20
 8000a38:	4293      	cmp	r3, r2
 8000a3a:	d00c      	beq.n	8000a56 <HAL_DMA_Init+0x5e>
 8000a3c:	3214      	adds	r2, #20
 8000a3e:	4293      	cmp	r3, r2
 8000a40:	d009      	beq.n	8000a56 <HAL_DMA_Init+0x5e>
 8000a42:	3214      	adds	r2, #20
 8000a44:	4293      	cmp	r3, r2
 8000a46:	d006      	beq.n	8000a56 <HAL_DMA_Init+0x5e>
 8000a48:	3214      	adds	r2, #20
 8000a4a:	4293      	cmp	r3, r2
 8000a4c:	d003      	beq.n	8000a56 <HAL_DMA_Init+0x5e>
 8000a4e:	219a      	movs	r1, #154	; 0x9a
 8000a50:	4849      	ldr	r0, [pc, #292]	; (8000b78 <HAL_DMA_Init+0x180>)
 8000a52:	f004 fe41 	bl	80056d8 <assert_failed>
  assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));
 8000a56:	6863      	ldr	r3, [r4, #4]
 8000a58:	b123      	cbz	r3, 8000a64 <HAL_DMA_Init+0x6c>
 8000a5a:	2b10      	cmp	r3, #16
 8000a5c:	d002      	beq.n	8000a64 <HAL_DMA_Init+0x6c>
 8000a5e:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8000a62:	d156      	bne.n	8000b12 <HAL_DMA_Init+0x11a>
  assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
 8000a64:	68a3      	ldr	r3, [r4, #8]
 8000a66:	2b40      	cmp	r3, #64	; 0x40
 8000a68:	d001      	beq.n	8000a6e <HAL_DMA_Init+0x76>
 8000a6a:	2b00      	cmp	r3, #0
 8000a6c:	d156      	bne.n	8000b1c <HAL_DMA_Init+0x124>
  assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
 8000a6e:	68e3      	ldr	r3, [r4, #12]
 8000a70:	2b80      	cmp	r3, #128	; 0x80
 8000a72:	d001      	beq.n	8000a78 <HAL_DMA_Init+0x80>
 8000a74:	2b00      	cmp	r3, #0
 8000a76:	d156      	bne.n	8000b26 <HAL_DMA_Init+0x12e>
  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
 8000a78:	6923      	ldr	r3, [r4, #16]
 8000a7a:	b12b      	cbz	r3, 8000a88 <HAL_DMA_Init+0x90>
 8000a7c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8000a80:	d002      	beq.n	8000a88 <HAL_DMA_Init+0x90>
 8000a82:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8000a86:	d153      	bne.n	8000b30 <HAL_DMA_Init+0x138>
  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
 8000a88:	6963      	ldr	r3, [r4, #20]
 8000a8a:	b12b      	cbz	r3, 8000a98 <HAL_DMA_Init+0xa0>
 8000a8c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8000a90:	d002      	beq.n	8000a98 <HAL_DMA_Init+0xa0>
 8000a92:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8000a96:	d150      	bne.n	8000b3a <HAL_DMA_Init+0x142>
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
 8000a98:	69a3      	ldr	r3, [r4, #24]
 8000a9a:	b10b      	cbz	r3, 8000aa0 <HAL_DMA_Init+0xa8>
 8000a9c:	2b20      	cmp	r3, #32
 8000a9e:	d151      	bne.n	8000b44 <HAL_DMA_Init+0x14c>
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
 8000aa0:	69e3      	ldr	r3, [r4, #28]
 8000aa2:	b143      	cbz	r3, 8000ab6 <HAL_DMA_Init+0xbe>
 8000aa4:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8000aa8:	d005      	beq.n	8000ab6 <HAL_DMA_Init+0xbe>
 8000aaa:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8000aae:	d002      	beq.n	8000ab6 <HAL_DMA_Init+0xbe>
 8000ab0:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
 8000ab4:	d14b      	bne.n	8000b4e <HAL_DMA_Init+0x156>
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 8000ab6:	6822      	ldr	r2, [r4, #0]
 8000ab8:	4b30      	ldr	r3, [pc, #192]	; (8000b7c <HAL_DMA_Init+0x184>)
 8000aba:	429a      	cmp	r2, r3
 8000abc:	d84c      	bhi.n	8000b58 <HAL_DMA_Init+0x160>
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
 8000abe:	4b30      	ldr	r3, [pc, #192]	; (8000b80 <HAL_DMA_Init+0x188>)
 8000ac0:	4413      	add	r3, r2
 8000ac2:	4a30      	ldr	r2, [pc, #192]	; (8000b84 <HAL_DMA_Init+0x18c>)
 8000ac4:	fba2 2303 	umull	r2, r3, r2, r3
 8000ac8:	091b      	lsrs	r3, r3, #4
 8000aca:	009b      	lsls	r3, r3, #2
 8000acc:	6423      	str	r3, [r4, #64]	; 0x40
    hdma->DmaBaseAddress = DMA1;
 8000ace:	4b2e      	ldr	r3, [pc, #184]	; (8000b88 <HAL_DMA_Init+0x190>)
 8000ad0:	63e3      	str	r3, [r4, #60]	; 0x3c
  hdma->State = HAL_DMA_STATE_BUSY;
 8000ad2:	2302      	movs	r3, #2
 8000ad4:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
  tmp = hdma->Instance->CCR;
 8000ad8:	6821      	ldr	r1, [r4, #0]
 8000ada:	680a      	ldr	r2, [r1, #0]
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 8000adc:	f422 527f 	bic.w	r2, r2, #16320	; 0x3fc0
 8000ae0:	f022 0230 	bic.w	r2, r2, #48	; 0x30
  tmp |=  hdma->Init.Direction        |
 8000ae4:	6863      	ldr	r3, [r4, #4]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8000ae6:	68a0      	ldr	r0, [r4, #8]
  tmp |=  hdma->Init.Direction        |
 8000ae8:	4303      	orrs	r3, r0
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8000aea:	68e0      	ldr	r0, [r4, #12]
 8000aec:	4303      	orrs	r3, r0
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8000aee:	6920      	ldr	r0, [r4, #16]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8000af0:	4303      	orrs	r3, r0
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8000af2:	6960      	ldr	r0, [r4, #20]
 8000af4:	4303      	orrs	r3, r0
          hdma->Init.Mode                | hdma->Init.Priority;
 8000af6:	69a0      	ldr	r0, [r4, #24]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8000af8:	4303      	orrs	r3, r0
          hdma->Init.Mode                | hdma->Init.Priority;
 8000afa:	69e0      	ldr	r0, [r4, #28]
 8000afc:	4303      	orrs	r3, r0
  tmp |=  hdma->Init.Direction        |
 8000afe:	4313      	orrs	r3, r2
  hdma->Instance->CCR = tmp;
 8000b00:	600b      	str	r3, [r1, #0]
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8000b02:	2000      	movs	r0, #0
 8000b04:	63a0      	str	r0, [r4, #56]	; 0x38
  hdma->State = HAL_DMA_STATE_READY;
 8000b06:	2301      	movs	r3, #1
 8000b08:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
  hdma->Lock = HAL_UNLOCKED;
 8000b0c:	f884 0020 	strb.w	r0, [r4, #32]
}
 8000b10:	bd10      	pop	{r4, pc}
  assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));
 8000b12:	219b      	movs	r1, #155	; 0x9b
 8000b14:	4818      	ldr	r0, [pc, #96]	; (8000b78 <HAL_DMA_Init+0x180>)
 8000b16:	f004 fddf 	bl	80056d8 <assert_failed>
 8000b1a:	e7a3      	b.n	8000a64 <HAL_DMA_Init+0x6c>
  assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
 8000b1c:	219c      	movs	r1, #156	; 0x9c
 8000b1e:	4816      	ldr	r0, [pc, #88]	; (8000b78 <HAL_DMA_Init+0x180>)
 8000b20:	f004 fdda 	bl	80056d8 <assert_failed>
 8000b24:	e7a3      	b.n	8000a6e <HAL_DMA_Init+0x76>
  assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
 8000b26:	219d      	movs	r1, #157	; 0x9d
 8000b28:	4813      	ldr	r0, [pc, #76]	; (8000b78 <HAL_DMA_Init+0x180>)
 8000b2a:	f004 fdd5 	bl	80056d8 <assert_failed>
 8000b2e:	e7a3      	b.n	8000a78 <HAL_DMA_Init+0x80>
  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
 8000b30:	219e      	movs	r1, #158	; 0x9e
 8000b32:	4811      	ldr	r0, [pc, #68]	; (8000b78 <HAL_DMA_Init+0x180>)
 8000b34:	f004 fdd0 	bl	80056d8 <assert_failed>
 8000b38:	e7a6      	b.n	8000a88 <HAL_DMA_Init+0x90>
  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
 8000b3a:	219f      	movs	r1, #159	; 0x9f
 8000b3c:	480e      	ldr	r0, [pc, #56]	; (8000b78 <HAL_DMA_Init+0x180>)
 8000b3e:	f004 fdcb 	bl	80056d8 <assert_failed>
 8000b42:	e7a9      	b.n	8000a98 <HAL_DMA_Init+0xa0>
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
 8000b44:	21a0      	movs	r1, #160	; 0xa0
 8000b46:	480c      	ldr	r0, [pc, #48]	; (8000b78 <HAL_DMA_Init+0x180>)
 8000b48:	f004 fdc6 	bl	80056d8 <assert_failed>
 8000b4c:	e7a8      	b.n	8000aa0 <HAL_DMA_Init+0xa8>
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
 8000b4e:	21a1      	movs	r1, #161	; 0xa1
 8000b50:	4809      	ldr	r0, [pc, #36]	; (8000b78 <HAL_DMA_Init+0x180>)
 8000b52:	f004 fdc1 	bl	80056d8 <assert_failed>
 8000b56:	e7ae      	b.n	8000ab6 <HAL_DMA_Init+0xbe>
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2;
 8000b58:	4b0c      	ldr	r3, [pc, #48]	; (8000b8c <HAL_DMA_Init+0x194>)
 8000b5a:	4413      	add	r3, r2
 8000b5c:	4a09      	ldr	r2, [pc, #36]	; (8000b84 <HAL_DMA_Init+0x18c>)
 8000b5e:	fba2 2303 	umull	r2, r3, r2, r3
 8000b62:	091b      	lsrs	r3, r3, #4
 8000b64:	009b      	lsls	r3, r3, #2
 8000b66:	6423      	str	r3, [r4, #64]	; 0x40
    hdma->DmaBaseAddress = DMA2;
 8000b68:	4b09      	ldr	r3, [pc, #36]	; (8000b90 <HAL_DMA_Init+0x198>)
 8000b6a:	63e3      	str	r3, [r4, #60]	; 0x3c
 8000b6c:	e7b1      	b.n	8000ad2 <HAL_DMA_Init+0xda>
    return HAL_ERROR;
 8000b6e:	2001      	movs	r0, #1
}
 8000b70:	4770      	bx	lr
 8000b72:	bf00      	nop
 8000b74:	40020008 	.word	0x40020008
 8000b78:	08005d68 	.word	0x08005d68
 8000b7c:	40020407 	.word	0x40020407
 8000b80:	bffdfff8 	.word	0xbffdfff8
 8000b84:	cccccccd 	.word	0xcccccccd
 8000b88:	40020000 	.word	0x40020000
 8000b8c:	bffdfbf8 	.word	0xbffdfbf8
 8000b90:	40020400 	.word	0x40020400

08000b94 <HAL_DMA_Start_IT>:
{
 8000b94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000b96:	4604      	mov	r4, r0
 8000b98:	460e      	mov	r6, r1
 8000b9a:	4617      	mov	r7, r2
 8000b9c:	461d      	mov	r5, r3
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
 8000b9e:	1e5a      	subs	r2, r3, #1
 8000ba0:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 8000ba4:	429a      	cmp	r2, r3
 8000ba6:	d80f      	bhi.n	8000bc8 <HAL_DMA_Start_IT+0x34>
  __HAL_LOCK(hdma);
 8000ba8:	f894 3020 	ldrb.w	r3, [r4, #32]
 8000bac:	2b01      	cmp	r3, #1
 8000bae:	d03a      	beq.n	8000c26 <HAL_DMA_Start_IT+0x92>
 8000bb0:	2301      	movs	r3, #1
 8000bb2:	f884 3020 	strb.w	r3, [r4, #32]
  if(HAL_DMA_STATE_READY == hdma->State)
 8000bb6:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
 8000bba:	2b01      	cmp	r3, #1
 8000bbc:	d00a      	beq.n	8000bd4 <HAL_DMA_Start_IT+0x40>
    __HAL_UNLOCK(hdma); 
 8000bbe:	2300      	movs	r3, #0
 8000bc0:	f884 3020 	strb.w	r3, [r4, #32]
    status = HAL_BUSY;
 8000bc4:	2002      	movs	r0, #2
}
 8000bc6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
 8000bc8:	f240 116f 	movw	r1, #367	; 0x16f
 8000bcc:	4817      	ldr	r0, [pc, #92]	; (8000c2c <HAL_DMA_Start_IT+0x98>)
 8000bce:	f004 fd83 	bl	80056d8 <assert_failed>
 8000bd2:	e7e9      	b.n	8000ba8 <HAL_DMA_Start_IT+0x14>
    hdma->State = HAL_DMA_STATE_BUSY;
 8000bd4:	2302      	movs	r3, #2
 8000bd6:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8000bda:	2300      	movs	r3, #0
 8000bdc:	63a3      	str	r3, [r4, #56]	; 0x38
    __HAL_DMA_DISABLE(hdma);
 8000bde:	6822      	ldr	r2, [r4, #0]
 8000be0:	6813      	ldr	r3, [r2, #0]
 8000be2:	f023 0301 	bic.w	r3, r3, #1
 8000be6:	6013      	str	r3, [r2, #0]
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
 8000be8:	462b      	mov	r3, r5
 8000bea:	463a      	mov	r2, r7
 8000bec:	4631      	mov	r1, r6
 8000bee:	4620      	mov	r0, r4
 8000bf0:	f7ff feec 	bl	80009cc <DMA_SetConfig>
    if(NULL != hdma->XferHalfCpltCallback)
 8000bf4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8000bf6:	b15b      	cbz	r3, 8000c10 <HAL_DMA_Start_IT+0x7c>
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8000bf8:	6822      	ldr	r2, [r4, #0]
 8000bfa:	6813      	ldr	r3, [r2, #0]
 8000bfc:	f043 030e 	orr.w	r3, r3, #14
 8000c00:	6013      	str	r3, [r2, #0]
    __HAL_DMA_ENABLE(hdma);
 8000c02:	6822      	ldr	r2, [r4, #0]
 8000c04:	6813      	ldr	r3, [r2, #0]
 8000c06:	f043 0301 	orr.w	r3, r3, #1
 8000c0a:	6013      	str	r3, [r2, #0]
  HAL_StatusTypeDef status = HAL_OK;
 8000c0c:	2000      	movs	r0, #0
 8000c0e:	e7da      	b.n	8000bc6 <HAL_DMA_Start_IT+0x32>
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 8000c10:	6822      	ldr	r2, [r4, #0]
 8000c12:	6813      	ldr	r3, [r2, #0]
 8000c14:	f023 0304 	bic.w	r3, r3, #4
 8000c18:	6013      	str	r3, [r2, #0]
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_TE));
 8000c1a:	6822      	ldr	r2, [r4, #0]
 8000c1c:	6813      	ldr	r3, [r2, #0]
 8000c1e:	f043 030a 	orr.w	r3, r3, #10
 8000c22:	6013      	str	r3, [r2, #0]
 8000c24:	e7ed      	b.n	8000c02 <HAL_DMA_Start_IT+0x6e>
  __HAL_LOCK(hdma);
 8000c26:	2002      	movs	r0, #2
 8000c28:	e7cd      	b.n	8000bc6 <HAL_DMA_Start_IT+0x32>
 8000c2a:	bf00      	nop
 8000c2c:	08005d68 	.word	0x08005d68

08000c30 <HAL_DMA_Abort_IT>:
{  
 8000c30:	b508      	push	{r3, lr}
  if(HAL_DMA_STATE_BUSY != hdma->State)
 8000c32:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
 8000c36:	2b02      	cmp	r3, #2
 8000c38:	d003      	beq.n	8000c42 <HAL_DMA_Abort_IT+0x12>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8000c3a:	2304      	movs	r3, #4
 8000c3c:	6383      	str	r3, [r0, #56]	; 0x38
    status = HAL_ERROR;
 8000c3e:	2001      	movs	r0, #1
}
 8000c40:	bd08      	pop	{r3, pc}
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8000c42:	6802      	ldr	r2, [r0, #0]
 8000c44:	6813      	ldr	r3, [r2, #0]
 8000c46:	f023 030e 	bic.w	r3, r3, #14
 8000c4a:	6013      	str	r3, [r2, #0]
    __HAL_DMA_DISABLE(hdma);
 8000c4c:	6802      	ldr	r2, [r0, #0]
 8000c4e:	6813      	ldr	r3, [r2, #0]
 8000c50:	f023 0301 	bic.w	r3, r3, #1
 8000c54:	6013      	str	r3, [r2, #0]
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
 8000c56:	6803      	ldr	r3, [r0, #0]
 8000c58:	4a4b      	ldr	r2, [pc, #300]	; (8000d88 <HAL_DMA_Abort_IT+0x158>)
 8000c5a:	4293      	cmp	r3, r2
 8000c5c:	d94e      	bls.n	8000cfc <HAL_DMA_Abort_IT+0xcc>
 8000c5e:	3a78      	subs	r2, #120	; 0x78
 8000c60:	4293      	cmp	r3, r2
 8000c62:	d024      	beq.n	8000cae <HAL_DMA_Abort_IT+0x7e>
 8000c64:	3214      	adds	r2, #20
 8000c66:	4293      	cmp	r3, r2
 8000c68:	d030      	beq.n	8000ccc <HAL_DMA_Abort_IT+0x9c>
 8000c6a:	3214      	adds	r2, #20
 8000c6c:	4293      	cmp	r3, r2
 8000c6e:	d02f      	beq.n	8000cd0 <HAL_DMA_Abort_IT+0xa0>
 8000c70:	3214      	adds	r2, #20
 8000c72:	4293      	cmp	r3, r2
 8000c74:	d02f      	beq.n	8000cd6 <HAL_DMA_Abort_IT+0xa6>
 8000c76:	3214      	adds	r2, #20
 8000c78:	4293      	cmp	r3, r2
 8000c7a:	d02f      	beq.n	8000cdc <HAL_DMA_Abort_IT+0xac>
 8000c7c:	3214      	adds	r2, #20
 8000c7e:	4293      	cmp	r3, r2
 8000c80:	d02f      	beq.n	8000ce2 <HAL_DMA_Abort_IT+0xb2>
 8000c82:	3214      	adds	r2, #20
 8000c84:	4293      	cmp	r3, r2
 8000c86:	d02f      	beq.n	8000ce8 <HAL_DMA_Abort_IT+0xb8>
 8000c88:	f502 7262 	add.w	r2, r2, #904	; 0x388
 8000c8c:	4293      	cmp	r3, r2
 8000c8e:	d02e      	beq.n	8000cee <HAL_DMA_Abort_IT+0xbe>
 8000c90:	3214      	adds	r2, #20
 8000c92:	4293      	cmp	r3, r2
 8000c94:	d02d      	beq.n	8000cf2 <HAL_DMA_Abort_IT+0xc2>
 8000c96:	3214      	adds	r2, #20
 8000c98:	4293      	cmp	r3, r2
 8000c9a:	d02c      	beq.n	8000cf6 <HAL_DMA_Abort_IT+0xc6>
 8000c9c:	3214      	adds	r2, #20
 8000c9e:	4293      	cmp	r3, r2
 8000ca0:	d002      	beq.n	8000ca8 <HAL_DMA_Abort_IT+0x78>
 8000ca2:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8000ca6:	e003      	b.n	8000cb0 <HAL_DMA_Abort_IT+0x80>
 8000ca8:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8000cac:	e000      	b.n	8000cb0 <HAL_DMA_Abort_IT+0x80>
 8000cae:	2201      	movs	r2, #1
 8000cb0:	4b36      	ldr	r3, [pc, #216]	; (8000d8c <HAL_DMA_Abort_IT+0x15c>)
 8000cb2:	605a      	str	r2, [r3, #4]
    hdma->State = HAL_DMA_STATE_READY;
 8000cb4:	2301      	movs	r3, #1
 8000cb6:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
    __HAL_UNLOCK(hdma);
 8000cba:	2300      	movs	r3, #0
 8000cbc:	f880 3020 	strb.w	r3, [r0, #32]
    if(hdma->XferAbortCallback != NULL)
 8000cc0:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8000cc2:	2b00      	cmp	r3, #0
 8000cc4:	d05e      	beq.n	8000d84 <HAL_DMA_Abort_IT+0x154>
      hdma->XferAbortCallback(hdma);
 8000cc6:	4798      	blx	r3
  HAL_StatusTypeDef status = HAL_OK;
 8000cc8:	2000      	movs	r0, #0
 8000cca:	e7b9      	b.n	8000c40 <HAL_DMA_Abort_IT+0x10>
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
 8000ccc:	2210      	movs	r2, #16
 8000cce:	e7ef      	b.n	8000cb0 <HAL_DMA_Abort_IT+0x80>
 8000cd0:	f44f 7280 	mov.w	r2, #256	; 0x100
 8000cd4:	e7ec      	b.n	8000cb0 <HAL_DMA_Abort_IT+0x80>
 8000cd6:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8000cda:	e7e9      	b.n	8000cb0 <HAL_DMA_Abort_IT+0x80>
 8000cdc:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8000ce0:	e7e6      	b.n	8000cb0 <HAL_DMA_Abort_IT+0x80>
 8000ce2:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 8000ce6:	e7e3      	b.n	8000cb0 <HAL_DMA_Abort_IT+0x80>
 8000ce8:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8000cec:	e7e0      	b.n	8000cb0 <HAL_DMA_Abort_IT+0x80>
 8000cee:	2201      	movs	r2, #1
 8000cf0:	e7de      	b.n	8000cb0 <HAL_DMA_Abort_IT+0x80>
 8000cf2:	2210      	movs	r2, #16
 8000cf4:	e7dc      	b.n	8000cb0 <HAL_DMA_Abort_IT+0x80>
 8000cf6:	f44f 7280 	mov.w	r2, #256	; 0x100
 8000cfa:	e7d9      	b.n	8000cb0 <HAL_DMA_Abort_IT+0x80>
 8000cfc:	4a24      	ldr	r2, [pc, #144]	; (8000d90 <HAL_DMA_Abort_IT+0x160>)
 8000cfe:	4293      	cmp	r3, r2
 8000d00:	d024      	beq.n	8000d4c <HAL_DMA_Abort_IT+0x11c>
 8000d02:	3214      	adds	r2, #20
 8000d04:	4293      	cmp	r3, r2
 8000d06:	d025      	beq.n	8000d54 <HAL_DMA_Abort_IT+0x124>
 8000d08:	3214      	adds	r2, #20
 8000d0a:	4293      	cmp	r3, r2
 8000d0c:	d024      	beq.n	8000d58 <HAL_DMA_Abort_IT+0x128>
 8000d0e:	3214      	adds	r2, #20
 8000d10:	4293      	cmp	r3, r2
 8000d12:	d024      	beq.n	8000d5e <HAL_DMA_Abort_IT+0x12e>
 8000d14:	3214      	adds	r2, #20
 8000d16:	4293      	cmp	r3, r2
 8000d18:	d024      	beq.n	8000d64 <HAL_DMA_Abort_IT+0x134>
 8000d1a:	3214      	adds	r2, #20
 8000d1c:	4293      	cmp	r3, r2
 8000d1e:	d024      	beq.n	8000d6a <HAL_DMA_Abort_IT+0x13a>
 8000d20:	3214      	adds	r2, #20
 8000d22:	4293      	cmp	r3, r2
 8000d24:	d024      	beq.n	8000d70 <HAL_DMA_Abort_IT+0x140>
 8000d26:	f502 7262 	add.w	r2, r2, #904	; 0x388
 8000d2a:	4293      	cmp	r3, r2
 8000d2c:	d023      	beq.n	8000d76 <HAL_DMA_Abort_IT+0x146>
 8000d2e:	3214      	adds	r2, #20
 8000d30:	4293      	cmp	r3, r2
 8000d32:	d022      	beq.n	8000d7a <HAL_DMA_Abort_IT+0x14a>
 8000d34:	3214      	adds	r2, #20
 8000d36:	4293      	cmp	r3, r2
 8000d38:	d021      	beq.n	8000d7e <HAL_DMA_Abort_IT+0x14e>
 8000d3a:	3214      	adds	r2, #20
 8000d3c:	4293      	cmp	r3, r2
 8000d3e:	d002      	beq.n	8000d46 <HAL_DMA_Abort_IT+0x116>
 8000d40:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8000d44:	e003      	b.n	8000d4e <HAL_DMA_Abort_IT+0x11e>
 8000d46:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8000d4a:	e000      	b.n	8000d4e <HAL_DMA_Abort_IT+0x11e>
 8000d4c:	2201      	movs	r2, #1
 8000d4e:	4b11      	ldr	r3, [pc, #68]	; (8000d94 <HAL_DMA_Abort_IT+0x164>)
 8000d50:	605a      	str	r2, [r3, #4]
 8000d52:	e7af      	b.n	8000cb4 <HAL_DMA_Abort_IT+0x84>
 8000d54:	2210      	movs	r2, #16
 8000d56:	e7fa      	b.n	8000d4e <HAL_DMA_Abort_IT+0x11e>
 8000d58:	f44f 7280 	mov.w	r2, #256	; 0x100
 8000d5c:	e7f7      	b.n	8000d4e <HAL_DMA_Abort_IT+0x11e>
 8000d5e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8000d62:	e7f4      	b.n	8000d4e <HAL_DMA_Abort_IT+0x11e>
 8000d64:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8000d68:	e7f1      	b.n	8000d4e <HAL_DMA_Abort_IT+0x11e>
 8000d6a:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 8000d6e:	e7ee      	b.n	8000d4e <HAL_DMA_Abort_IT+0x11e>
 8000d70:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8000d74:	e7eb      	b.n	8000d4e <HAL_DMA_Abort_IT+0x11e>
 8000d76:	2201      	movs	r2, #1
 8000d78:	e7e9      	b.n	8000d4e <HAL_DMA_Abort_IT+0x11e>
 8000d7a:	2210      	movs	r2, #16
 8000d7c:	e7e7      	b.n	8000d4e <HAL_DMA_Abort_IT+0x11e>
 8000d7e:	f44f 7280 	mov.w	r2, #256	; 0x100
 8000d82:	e7e4      	b.n	8000d4e <HAL_DMA_Abort_IT+0x11e>
  HAL_StatusTypeDef status = HAL_OK;
 8000d84:	2000      	movs	r0, #0
 8000d86:	e75b      	b.n	8000c40 <HAL_DMA_Abort_IT+0x10>
 8000d88:	40020080 	.word	0x40020080
 8000d8c:	40020400 	.word	0x40020400
 8000d90:	40020008 	.word	0x40020008
 8000d94:	40020000 	.word	0x40020000

08000d98 <HAL_DMA_IRQHandler>:
{
 8000d98:	b538      	push	{r3, r4, r5, lr}
  uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 8000d9a:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 8000d9c:	681a      	ldr	r2, [r3, #0]
  uint32_t source_it = hdma->Instance->CCR;
 8000d9e:	6804      	ldr	r4, [r0, #0]
 8000da0:	6825      	ldr	r5, [r4, #0]
  if (((flag_it & (DMA_FLAG_HT1 << hdma->ChannelIndex)) != RESET) && ((source_it & DMA_IT_HT) != RESET))
 8000da2:	6c01      	ldr	r1, [r0, #64]	; 0x40
 8000da4:	2304      	movs	r3, #4
 8000da6:	408b      	lsls	r3, r1
 8000da8:	4213      	tst	r3, r2
 8000daa:	f000 809b 	beq.w	8000ee4 <HAL_DMA_IRQHandler+0x14c>
 8000dae:	f015 0f04 	tst.w	r5, #4
 8000db2:	f000 8097 	beq.w	8000ee4 <HAL_DMA_IRQHandler+0x14c>
    if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 8000db6:	6823      	ldr	r3, [r4, #0]
 8000db8:	f013 0f20 	tst.w	r3, #32
 8000dbc:	d103      	bne.n	8000dc6 <HAL_DMA_IRQHandler+0x2e>
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 8000dbe:	6823      	ldr	r3, [r4, #0]
 8000dc0:	f023 0304 	bic.w	r3, r3, #4
 8000dc4:	6023      	str	r3, [r4, #0]
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8000dc6:	6803      	ldr	r3, [r0, #0]
 8000dc8:	4aaa      	ldr	r2, [pc, #680]	; (8001074 <HAL_DMA_IRQHandler+0x2dc>)
 8000dca:	4293      	cmp	r3, r2
 8000dcc:	d946      	bls.n	8000e5c <HAL_DMA_IRQHandler+0xc4>
 8000dce:	3a78      	subs	r2, #120	; 0x78
 8000dd0:	4293      	cmp	r3, r2
 8000dd2:	d024      	beq.n	8000e1e <HAL_DMA_IRQHandler+0x86>
 8000dd4:	3214      	adds	r2, #20
 8000dd6:	4293      	cmp	r3, r2
 8000dd8:	d028      	beq.n	8000e2c <HAL_DMA_IRQHandler+0x94>
 8000dda:	3214      	adds	r2, #20
 8000ddc:	4293      	cmp	r3, r2
 8000dde:	d027      	beq.n	8000e30 <HAL_DMA_IRQHandler+0x98>
 8000de0:	3214      	adds	r2, #20
 8000de2:	4293      	cmp	r3, r2
 8000de4:	d027      	beq.n	8000e36 <HAL_DMA_IRQHandler+0x9e>
 8000de6:	3214      	adds	r2, #20
 8000de8:	4293      	cmp	r3, r2
 8000dea:	d027      	beq.n	8000e3c <HAL_DMA_IRQHandler+0xa4>
 8000dec:	3214      	adds	r2, #20
 8000dee:	4293      	cmp	r3, r2
 8000df0:	d027      	beq.n	8000e42 <HAL_DMA_IRQHandler+0xaa>
 8000df2:	3214      	adds	r2, #20
 8000df4:	4293      	cmp	r3, r2
 8000df6:	d027      	beq.n	8000e48 <HAL_DMA_IRQHandler+0xb0>
 8000df8:	f502 7262 	add.w	r2, r2, #904	; 0x388
 8000dfc:	4293      	cmp	r3, r2
 8000dfe:	d026      	beq.n	8000e4e <HAL_DMA_IRQHandler+0xb6>
 8000e00:	3214      	adds	r2, #20
 8000e02:	4293      	cmp	r3, r2
 8000e04:	d025      	beq.n	8000e52 <HAL_DMA_IRQHandler+0xba>
 8000e06:	3214      	adds	r2, #20
 8000e08:	4293      	cmp	r3, r2
 8000e0a:	d024      	beq.n	8000e56 <HAL_DMA_IRQHandler+0xbe>
 8000e0c:	3214      	adds	r2, #20
 8000e0e:	4293      	cmp	r3, r2
 8000e10:	d002      	beq.n	8000e18 <HAL_DMA_IRQHandler+0x80>
 8000e12:	f44f 2280 	mov.w	r2, #262144	; 0x40000
 8000e16:	e003      	b.n	8000e20 <HAL_DMA_IRQHandler+0x88>
 8000e18:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8000e1c:	e000      	b.n	8000e20 <HAL_DMA_IRQHandler+0x88>
 8000e1e:	2204      	movs	r2, #4
 8000e20:	4b95      	ldr	r3, [pc, #596]	; (8001078 <HAL_DMA_IRQHandler+0x2e0>)
 8000e22:	605a      	str	r2, [r3, #4]
    if(hdma->XferHalfCpltCallback != NULL)
 8000e24:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8000e26:	b103      	cbz	r3, 8000e2a <HAL_DMA_IRQHandler+0x92>
      hdma->XferHalfCpltCallback(hdma);
 8000e28:	4798      	blx	r3
}
 8000e2a:	bd38      	pop	{r3, r4, r5, pc}
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8000e2c:	2240      	movs	r2, #64	; 0x40
 8000e2e:	e7f7      	b.n	8000e20 <HAL_DMA_IRQHandler+0x88>
 8000e30:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8000e34:	e7f4      	b.n	8000e20 <HAL_DMA_IRQHandler+0x88>
 8000e36:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8000e3a:	e7f1      	b.n	8000e20 <HAL_DMA_IRQHandler+0x88>
 8000e3c:	f44f 2280 	mov.w	r2, #262144	; 0x40000
 8000e40:	e7ee      	b.n	8000e20 <HAL_DMA_IRQHandler+0x88>
 8000e42:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
 8000e46:	e7eb      	b.n	8000e20 <HAL_DMA_IRQHandler+0x88>
 8000e48:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
 8000e4c:	e7e8      	b.n	8000e20 <HAL_DMA_IRQHandler+0x88>
 8000e4e:	2204      	movs	r2, #4
 8000e50:	e7e6      	b.n	8000e20 <HAL_DMA_IRQHandler+0x88>
 8000e52:	2240      	movs	r2, #64	; 0x40
 8000e54:	e7e4      	b.n	8000e20 <HAL_DMA_IRQHandler+0x88>
 8000e56:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8000e5a:	e7e1      	b.n	8000e20 <HAL_DMA_IRQHandler+0x88>
 8000e5c:	4a87      	ldr	r2, [pc, #540]	; (800107c <HAL_DMA_IRQHandler+0x2e4>)
 8000e5e:	4293      	cmp	r3, r2
 8000e60:	d024      	beq.n	8000eac <HAL_DMA_IRQHandler+0x114>
 8000e62:	3214      	adds	r2, #20
 8000e64:	4293      	cmp	r3, r2
 8000e66:	d025      	beq.n	8000eb4 <HAL_DMA_IRQHandler+0x11c>
 8000e68:	3214      	adds	r2, #20
 8000e6a:	4293      	cmp	r3, r2
 8000e6c:	d024      	beq.n	8000eb8 <HAL_DMA_IRQHandler+0x120>
 8000e6e:	3214      	adds	r2, #20
 8000e70:	4293      	cmp	r3, r2
 8000e72:	d024      	beq.n	8000ebe <HAL_DMA_IRQHandler+0x126>
 8000e74:	3214      	adds	r2, #20
 8000e76:	4293      	cmp	r3, r2
 8000e78:	d024      	beq.n	8000ec4 <HAL_DMA_IRQHandler+0x12c>
 8000e7a:	3214      	adds	r2, #20
 8000e7c:	4293      	cmp	r3, r2
 8000e7e:	d024      	beq.n	8000eca <HAL_DMA_IRQHandler+0x132>
 8000e80:	3214      	adds	r2, #20
 8000e82:	4293      	cmp	r3, r2
 8000e84:	d024      	beq.n	8000ed0 <HAL_DMA_IRQHandler+0x138>
 8000e86:	f502 7262 	add.w	r2, r2, #904	; 0x388
 8000e8a:	4293      	cmp	r3, r2
 8000e8c:	d023      	beq.n	8000ed6 <HAL_DMA_IRQHandler+0x13e>
 8000e8e:	3214      	adds	r2, #20
 8000e90:	4293      	cmp	r3, r2
 8000e92:	d022      	beq.n	8000eda <HAL_DMA_IRQHandler+0x142>
 8000e94:	3214      	adds	r2, #20
 8000e96:	4293      	cmp	r3, r2
 8000e98:	d021      	beq.n	8000ede <HAL_DMA_IRQHandler+0x146>
 8000e9a:	3214      	adds	r2, #20
 8000e9c:	4293      	cmp	r3, r2
 8000e9e:	d002      	beq.n	8000ea6 <HAL_DMA_IRQHandler+0x10e>
 8000ea0:	f44f 2280 	mov.w	r2, #262144	; 0x40000
 8000ea4:	e003      	b.n	8000eae <HAL_DMA_IRQHandler+0x116>
 8000ea6:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8000eaa:	e000      	b.n	8000eae <HAL_DMA_IRQHandler+0x116>
 8000eac:	2204      	movs	r2, #4
 8000eae:	4b74      	ldr	r3, [pc, #464]	; (8001080 <HAL_DMA_IRQHandler+0x2e8>)
 8000eb0:	605a      	str	r2, [r3, #4]
 8000eb2:	e7b7      	b.n	8000e24 <HAL_DMA_IRQHandler+0x8c>
 8000eb4:	2240      	movs	r2, #64	; 0x40
 8000eb6:	e7fa      	b.n	8000eae <HAL_DMA_IRQHandler+0x116>
 8000eb8:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8000ebc:	e7f7      	b.n	8000eae <HAL_DMA_IRQHandler+0x116>
 8000ebe:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8000ec2:	e7f4      	b.n	8000eae <HAL_DMA_IRQHandler+0x116>
 8000ec4:	f44f 2280 	mov.w	r2, #262144	; 0x40000
 8000ec8:	e7f1      	b.n	8000eae <HAL_DMA_IRQHandler+0x116>
 8000eca:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
 8000ece:	e7ee      	b.n	8000eae <HAL_DMA_IRQHandler+0x116>
 8000ed0:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
 8000ed4:	e7eb      	b.n	8000eae <HAL_DMA_IRQHandler+0x116>
 8000ed6:	2204      	movs	r2, #4
 8000ed8:	e7e9      	b.n	8000eae <HAL_DMA_IRQHandler+0x116>
 8000eda:	2240      	movs	r2, #64	; 0x40
 8000edc:	e7e7      	b.n	8000eae <HAL_DMA_IRQHandler+0x116>
 8000ede:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8000ee2:	e7e4      	b.n	8000eae <HAL_DMA_IRQHandler+0x116>
  else if (((flag_it & (DMA_FLAG_TC1 << hdma->ChannelIndex)) != RESET) && ((source_it & DMA_IT_TC) != RESET))
 8000ee4:	2302      	movs	r3, #2
 8000ee6:	408b      	lsls	r3, r1
 8000ee8:	4213      	tst	r3, r2
 8000eea:	f000 80a3 	beq.w	8001034 <HAL_DMA_IRQHandler+0x29c>
 8000eee:	f015 0f02 	tst.w	r5, #2
 8000ef2:	f000 809f 	beq.w	8001034 <HAL_DMA_IRQHandler+0x29c>
    if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 8000ef6:	6823      	ldr	r3, [r4, #0]
 8000ef8:	f013 0f20 	tst.w	r3, #32
 8000efc:	d106      	bne.n	8000f0c <HAL_DMA_IRQHandler+0x174>
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);  
 8000efe:	6823      	ldr	r3, [r4, #0]
 8000f00:	f023 030a 	bic.w	r3, r3, #10
 8000f04:	6023      	str	r3, [r4, #0]
      hdma->State = HAL_DMA_STATE_READY;
 8000f06:	2301      	movs	r3, #1
 8000f08:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8000f0c:	6803      	ldr	r3, [r0, #0]
 8000f0e:	4a59      	ldr	r2, [pc, #356]	; (8001074 <HAL_DMA_IRQHandler+0x2dc>)
 8000f10:	4293      	cmp	r3, r2
 8000f12:	d94b      	bls.n	8000fac <HAL_DMA_IRQHandler+0x214>
 8000f14:	3a78      	subs	r2, #120	; 0x78
 8000f16:	4293      	cmp	r3, r2
 8000f18:	d024      	beq.n	8000f64 <HAL_DMA_IRQHandler+0x1cc>
 8000f1a:	3214      	adds	r2, #20
 8000f1c:	4293      	cmp	r3, r2
 8000f1e:	d02d      	beq.n	8000f7c <HAL_DMA_IRQHandler+0x1e4>
 8000f20:	3214      	adds	r2, #20
 8000f22:	4293      	cmp	r3, r2
 8000f24:	d02c      	beq.n	8000f80 <HAL_DMA_IRQHandler+0x1e8>
 8000f26:	3214      	adds	r2, #20
 8000f28:	4293      	cmp	r3, r2
 8000f2a:	d02c      	beq.n	8000f86 <HAL_DMA_IRQHandler+0x1ee>
 8000f2c:	3214      	adds	r2, #20
 8000f2e:	4293      	cmp	r3, r2
 8000f30:	d02c      	beq.n	8000f8c <HAL_DMA_IRQHandler+0x1f4>
 8000f32:	3214      	adds	r2, #20
 8000f34:	4293      	cmp	r3, r2
 8000f36:	d02c      	beq.n	8000f92 <HAL_DMA_IRQHandler+0x1fa>
 8000f38:	3214      	adds	r2, #20
 8000f3a:	4293      	cmp	r3, r2
 8000f3c:	d02c      	beq.n	8000f98 <HAL_DMA_IRQHandler+0x200>
 8000f3e:	f502 7262 	add.w	r2, r2, #904	; 0x388
 8000f42:	4293      	cmp	r3, r2
 8000f44:	d02b      	beq.n	8000f9e <HAL_DMA_IRQHandler+0x206>
 8000f46:	3214      	adds	r2, #20
 8000f48:	4293      	cmp	r3, r2
 8000f4a:	d02a      	beq.n	8000fa2 <HAL_DMA_IRQHandler+0x20a>
 8000f4c:	3214      	adds	r2, #20
 8000f4e:	4293      	cmp	r3, r2
 8000f50:	d029      	beq.n	8000fa6 <HAL_DMA_IRQHandler+0x20e>
 8000f52:	3214      	adds	r2, #20
 8000f54:	4293      	cmp	r3, r2
 8000f56:	d002      	beq.n	8000f5e <HAL_DMA_IRQHandler+0x1c6>
 8000f58:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 8000f5c:	e003      	b.n	8000f66 <HAL_DMA_IRQHandler+0x1ce>
 8000f5e:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8000f62:	e000      	b.n	8000f66 <HAL_DMA_IRQHandler+0x1ce>
 8000f64:	2202      	movs	r2, #2
 8000f66:	4b44      	ldr	r3, [pc, #272]	; (8001078 <HAL_DMA_IRQHandler+0x2e0>)
 8000f68:	605a      	str	r2, [r3, #4]
    __HAL_UNLOCK(hdma);
 8000f6a:	2300      	movs	r3, #0
 8000f6c:	f880 3020 	strb.w	r3, [r0, #32]
    if(hdma->XferCpltCallback != NULL)
 8000f70:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8000f72:	2b00      	cmp	r3, #0
 8000f74:	f43f af59 	beq.w	8000e2a <HAL_DMA_IRQHandler+0x92>
      hdma->XferCpltCallback(hdma);
 8000f78:	4798      	blx	r3
 8000f7a:	e756      	b.n	8000e2a <HAL_DMA_IRQHandler+0x92>
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8000f7c:	2220      	movs	r2, #32
 8000f7e:	e7f2      	b.n	8000f66 <HAL_DMA_IRQHandler+0x1ce>
 8000f80:	f44f 7200 	mov.w	r2, #512	; 0x200
 8000f84:	e7ef      	b.n	8000f66 <HAL_DMA_IRQHandler+0x1ce>
 8000f86:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8000f8a:	e7ec      	b.n	8000f66 <HAL_DMA_IRQHandler+0x1ce>
 8000f8c:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 8000f90:	e7e9      	b.n	8000f66 <HAL_DMA_IRQHandler+0x1ce>
 8000f92:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
 8000f96:	e7e6      	b.n	8000f66 <HAL_DMA_IRQHandler+0x1ce>
 8000f98:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
 8000f9c:	e7e3      	b.n	8000f66 <HAL_DMA_IRQHandler+0x1ce>
 8000f9e:	2202      	movs	r2, #2
 8000fa0:	e7e1      	b.n	8000f66 <HAL_DMA_IRQHandler+0x1ce>
 8000fa2:	2220      	movs	r2, #32
 8000fa4:	e7df      	b.n	8000f66 <HAL_DMA_IRQHandler+0x1ce>
 8000fa6:	f44f 7200 	mov.w	r2, #512	; 0x200
 8000faa:	e7dc      	b.n	8000f66 <HAL_DMA_IRQHandler+0x1ce>
 8000fac:	4a33      	ldr	r2, [pc, #204]	; (800107c <HAL_DMA_IRQHandler+0x2e4>)
 8000fae:	4293      	cmp	r3, r2
 8000fb0:	d024      	beq.n	8000ffc <HAL_DMA_IRQHandler+0x264>
 8000fb2:	3214      	adds	r2, #20
 8000fb4:	4293      	cmp	r3, r2
 8000fb6:	d025      	beq.n	8001004 <HAL_DMA_IRQHandler+0x26c>
 8000fb8:	3214      	adds	r2, #20
 8000fba:	4293      	cmp	r3, r2
 8000fbc:	d024      	beq.n	8001008 <HAL_DMA_IRQHandler+0x270>
 8000fbe:	3214      	adds	r2, #20
 8000fc0:	4293      	cmp	r3, r2
 8000fc2:	d024      	beq.n	800100e <HAL_DMA_IRQHandler+0x276>
 8000fc4:	3214      	adds	r2, #20
 8000fc6:	4293      	cmp	r3, r2
 8000fc8:	d024      	beq.n	8001014 <HAL_DMA_IRQHandler+0x27c>
 8000fca:	3214      	adds	r2, #20
 8000fcc:	4293      	cmp	r3, r2
 8000fce:	d024      	beq.n	800101a <HAL_DMA_IRQHandler+0x282>
 8000fd0:	3214      	adds	r2, #20
 8000fd2:	4293      	cmp	r3, r2
 8000fd4:	d024      	beq.n	8001020 <HAL_DMA_IRQHandler+0x288>
 8000fd6:	f502 7262 	add.w	r2, r2, #904	; 0x388
 8000fda:	4293      	cmp	r3, r2
 8000fdc:	d023      	beq.n	8001026 <HAL_DMA_IRQHandler+0x28e>
 8000fde:	3214      	adds	r2, #20
 8000fe0:	4293      	cmp	r3, r2
 8000fe2:	d022      	beq.n	800102a <HAL_DMA_IRQHandler+0x292>
 8000fe4:	3214      	adds	r2, #20
 8000fe6:	4293      	cmp	r3, r2
 8000fe8:	d021      	beq.n	800102e <HAL_DMA_IRQHandler+0x296>
 8000fea:	3214      	adds	r2, #20
 8000fec:	4293      	cmp	r3, r2
 8000fee:	d002      	beq.n	8000ff6 <HAL_DMA_IRQHandler+0x25e>
 8000ff0:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 8000ff4:	e003      	b.n	8000ffe <HAL_DMA_IRQHandler+0x266>
 8000ff6:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8000ffa:	e000      	b.n	8000ffe <HAL_DMA_IRQHandler+0x266>
 8000ffc:	2202      	movs	r2, #2
 8000ffe:	4b20      	ldr	r3, [pc, #128]	; (8001080 <HAL_DMA_IRQHandler+0x2e8>)
 8001000:	605a      	str	r2, [r3, #4]
 8001002:	e7b2      	b.n	8000f6a <HAL_DMA_IRQHandler+0x1d2>
 8001004:	2220      	movs	r2, #32
 8001006:	e7fa      	b.n	8000ffe <HAL_DMA_IRQHandler+0x266>
 8001008:	f44f 7200 	mov.w	r2, #512	; 0x200
 800100c:	e7f7      	b.n	8000ffe <HAL_DMA_IRQHandler+0x266>
 800100e:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8001012:	e7f4      	b.n	8000ffe <HAL_DMA_IRQHandler+0x266>
 8001014:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 8001018:	e7f1      	b.n	8000ffe <HAL_DMA_IRQHandler+0x266>
 800101a:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
 800101e:	e7ee      	b.n	8000ffe <HAL_DMA_IRQHandler+0x266>
 8001020:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
 8001024:	e7eb      	b.n	8000ffe <HAL_DMA_IRQHandler+0x266>
 8001026:	2202      	movs	r2, #2
 8001028:	e7e9      	b.n	8000ffe <HAL_DMA_IRQHandler+0x266>
 800102a:	2220      	movs	r2, #32
 800102c:	e7e7      	b.n	8000ffe <HAL_DMA_IRQHandler+0x266>
 800102e:	f44f 7200 	mov.w	r2, #512	; 0x200
 8001032:	e7e4      	b.n	8000ffe <HAL_DMA_IRQHandler+0x266>
  else if (( RESET != (flag_it & (DMA_FLAG_TE1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_TE)))
 8001034:	2308      	movs	r3, #8
 8001036:	fa03 f101 	lsl.w	r1, r3, r1
 800103a:	4211      	tst	r1, r2
 800103c:	f43f aef5 	beq.w	8000e2a <HAL_DMA_IRQHandler+0x92>
 8001040:	f015 0f08 	tst.w	r5, #8
 8001044:	f43f aef1 	beq.w	8000e2a <HAL_DMA_IRQHandler+0x92>
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8001048:	6823      	ldr	r3, [r4, #0]
 800104a:	f023 030e 	bic.w	r3, r3, #14
 800104e:	6023      	str	r3, [r4, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << hdma->ChannelIndex);
 8001050:	6c02      	ldr	r2, [r0, #64]	; 0x40
 8001052:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
 8001054:	2301      	movs	r3, #1
 8001056:	fa03 f202 	lsl.w	r2, r3, r2
 800105a:	604a      	str	r2, [r1, #4]
    hdma->ErrorCode = HAL_DMA_ERROR_TE;
 800105c:	6383      	str	r3, [r0, #56]	; 0x38
    hdma->State = HAL_DMA_STATE_READY;
 800105e:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
    __HAL_UNLOCK(hdma);
 8001062:	2300      	movs	r3, #0
 8001064:	f880 3020 	strb.w	r3, [r0, #32]
    if (hdma->XferErrorCallback != NULL)
 8001068:	6b03      	ldr	r3, [r0, #48]	; 0x30
 800106a:	2b00      	cmp	r3, #0
 800106c:	f43f aedd 	beq.w	8000e2a <HAL_DMA_IRQHandler+0x92>
      hdma->XferErrorCallback(hdma);
 8001070:	4798      	blx	r3
  return;
 8001072:	e6da      	b.n	8000e2a <HAL_DMA_IRQHandler+0x92>
 8001074:	40020080 	.word	0x40020080
 8001078:	40020400 	.word	0x40020400
 800107c:	40020008 	.word	0x40020008
 8001080:	40020000 	.word	0x40020000

08001084 <HAL_DMA_GetState>:
}
 8001084:	f890 0021 	ldrb.w	r0, [r0, #33]	; 0x21
 8001088:	4770      	bx	lr
	...

0800108c <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 800108c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8001090:	b083      	sub	sp, #12
 8001092:	4680      	mov	r8, r0
 8001094:	460f      	mov	r7, r1
  uint32_t config = 0x00u;
  __IO uint32_t *configregister; /* Store the address of CRL or CRH register based on pin number */
  uint32_t registeroffset;       /* offset used during computation of CNF and MODE bits placement inside CRL or CRH register */

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
 8001096:	4bba      	ldr	r3, [pc, #744]	; (8001380 <HAL_GPIO_Init+0x2f4>)
 8001098:	4298      	cmp	r0, r3
 800109a:	d01b      	beq.n	80010d4 <HAL_GPIO_Init+0x48>
 800109c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80010a0:	4298      	cmp	r0, r3
 80010a2:	d017      	beq.n	80010d4 <HAL_GPIO_Init+0x48>
 80010a4:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80010a8:	4298      	cmp	r0, r3
 80010aa:	d013      	beq.n	80010d4 <HAL_GPIO_Init+0x48>
 80010ac:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80010b0:	4298      	cmp	r0, r3
 80010b2:	d00f      	beq.n	80010d4 <HAL_GPIO_Init+0x48>
 80010b4:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80010b8:	4298      	cmp	r0, r3
 80010ba:	d00b      	beq.n	80010d4 <HAL_GPIO_Init+0x48>
 80010bc:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80010c0:	4298      	cmp	r0, r3
 80010c2:	d007      	beq.n	80010d4 <HAL_GPIO_Init+0x48>
 80010c4:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80010c8:	4298      	cmp	r0, r3
 80010ca:	d003      	beq.n	80010d4 <HAL_GPIO_Init+0x48>
 80010cc:	21bd      	movs	r1, #189	; 0xbd
 80010ce:	48ad      	ldr	r0, [pc, #692]	; (8001384 <HAL_GPIO_Init+0x2f8>)
 80010d0:	f004 fb02 	bl	80056d8 <assert_failed>
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
 80010d4:	683b      	ldr	r3, [r7, #0]
 80010d6:	b29a      	uxth	r2, r3
 80010d8:	b112      	cbz	r2, 80010e0 <HAL_GPIO_Init+0x54>
 80010da:	0c1b      	lsrs	r3, r3, #16
 80010dc:	041b      	lsls	r3, r3, #16
 80010de:	b11b      	cbz	r3, 80010e8 <HAL_GPIO_Init+0x5c>
 80010e0:	21be      	movs	r1, #190	; 0xbe
 80010e2:	48a8      	ldr	r0, [pc, #672]	; (8001384 <HAL_GPIO_Init+0x2f8>)
 80010e4:	f004 faf8 	bl	80056d8 <assert_failed>
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
 80010e8:	687b      	ldr	r3, [r7, #4]
 80010ea:	2b01      	cmp	r3, #1
 80010ec:	d91e      	bls.n	800112c <HAL_GPIO_Init+0xa0>
 80010ee:	2b11      	cmp	r3, #17
 80010f0:	d01c      	beq.n	800112c <HAL_GPIO_Init+0xa0>
 80010f2:	2b02      	cmp	r3, #2
 80010f4:	d01a      	beq.n	800112c <HAL_GPIO_Init+0xa0>
 80010f6:	2b12      	cmp	r3, #18
 80010f8:	d018      	beq.n	800112c <HAL_GPIO_Init+0xa0>
 80010fa:	4aa3      	ldr	r2, [pc, #652]	; (8001388 <HAL_GPIO_Init+0x2fc>)
 80010fc:	4293      	cmp	r3, r2
 80010fe:	d015      	beq.n	800112c <HAL_GPIO_Init+0xa0>
 8001100:	f502 1280 	add.w	r2, r2, #1048576	; 0x100000
 8001104:	4293      	cmp	r3, r2
 8001106:	d011      	beq.n	800112c <HAL_GPIO_Init+0xa0>
 8001108:	f502 1280 	add.w	r2, r2, #1048576	; 0x100000
 800110c:	4293      	cmp	r3, r2
 800110e:	d00d      	beq.n	800112c <HAL_GPIO_Init+0xa0>
 8001110:	f5a2 12f8 	sub.w	r2, r2, #2031616	; 0x1f0000
 8001114:	4293      	cmp	r3, r2
 8001116:	d009      	beq.n	800112c <HAL_GPIO_Init+0xa0>
 8001118:	f502 1280 	add.w	r2, r2, #1048576	; 0x100000
 800111c:	4293      	cmp	r3, r2
 800111e:	d005      	beq.n	800112c <HAL_GPIO_Init+0xa0>
 8001120:	f502 1280 	add.w	r2, r2, #1048576	; 0x100000
 8001124:	4293      	cmp	r3, r2
 8001126:	d001      	beq.n	800112c <HAL_GPIO_Init+0xa0>
 8001128:	2b03      	cmp	r3, #3
 800112a:	d103      	bne.n	8001134 <HAL_GPIO_Init+0xa8>
      {
        /* Enable AFIO Clock */
        __HAL_RCC_AFIO_CLK_ENABLE();
        temp = AFIO->EXTICR[position >> 2u];
        CLEAR_BIT(temp, (0x0Fu) << (4u * (position & 0x03u)));
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4u * (position & 0x03u)));
 800112c:	f04f 0900 	mov.w	r9, #0
 8001130:	464d      	mov	r5, r9
 8001132:	e0e1      	b.n	80012f8 <HAL_GPIO_Init+0x26c>
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
 8001134:	21bf      	movs	r1, #191	; 0xbf
 8001136:	4893      	ldr	r0, [pc, #588]	; (8001384 <HAL_GPIO_Init+0x2f8>)
 8001138:	f004 face 	bl	80056d8 <assert_failed>
 800113c:	e7f6      	b.n	800112c <HAL_GPIO_Init+0xa0>
      switch (GPIO_Init->Mode)
 800113e:	2b00      	cmp	r3, #0
 8001140:	d068      	beq.n	8001214 <HAL_GPIO_Init+0x188>
 8001142:	2b01      	cmp	r3, #1
 8001144:	d105      	bne.n	8001152 <HAL_GPIO_Init+0xc6>
          assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
 8001146:	68fb      	ldr	r3, [r7, #12]
 8001148:	3b01      	subs	r3, #1
 800114a:	2b02      	cmp	r3, #2
 800114c:	d86f      	bhi.n	800122e <HAL_GPIO_Init+0x1a2>
          config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_PP;
 800114e:	f8d7 900c 	ldr.w	r9, [r7, #12]
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 8001152:	2cff      	cmp	r4, #255	; 0xff
 8001154:	f200 809f 	bhi.w	8001296 <HAL_GPIO_Init+0x20a>
 8001158:	4640      	mov	r0, r8
      registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2u) : ((position - 8u) << 2u);
 800115a:	2cff      	cmp	r4, #255	; 0xff
 800115c:	f200 809e 	bhi.w	800129c <HAL_GPIO_Init+0x210>
 8001160:	00aa      	lsls	r2, r5, #2
      MODIFY_REG((*configregister), ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset), (config << registeroffset));
 8001162:	6803      	ldr	r3, [r0, #0]
 8001164:	210f      	movs	r1, #15
 8001166:	4091      	lsls	r1, r2
 8001168:	ea23 0301 	bic.w	r3, r3, r1
 800116c:	fa09 f202 	lsl.w	r2, r9, r2
 8001170:	4313      	orrs	r3, r2
 8001172:	6003      	str	r3, [r0, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8001174:	687b      	ldr	r3, [r7, #4]
 8001176:	f013 5f80 	tst.w	r3, #268435456	; 0x10000000
 800117a:	f000 80bc 	beq.w	80012f6 <HAL_GPIO_Init+0x26a>
        __HAL_RCC_AFIO_CLK_ENABLE();
 800117e:	4b83      	ldr	r3, [pc, #524]	; (800138c <HAL_GPIO_Init+0x300>)
 8001180:	699a      	ldr	r2, [r3, #24]
 8001182:	f042 0201 	orr.w	r2, r2, #1
 8001186:	619a      	str	r2, [r3, #24]
 8001188:	699b      	ldr	r3, [r3, #24]
 800118a:	f003 0301 	and.w	r3, r3, #1
 800118e:	9301      	str	r3, [sp, #4]
 8001190:	9b01      	ldr	r3, [sp, #4]
        temp = AFIO->EXTICR[position >> 2u];
 8001192:	08aa      	lsrs	r2, r5, #2
 8001194:	1c91      	adds	r1, r2, #2
 8001196:	4b7e      	ldr	r3, [pc, #504]	; (8001390 <HAL_GPIO_Init+0x304>)
 8001198:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]
        CLEAR_BIT(temp, (0x0Fu) << (4u * (position & 0x03u)));
 800119c:	f005 0303 	and.w	r3, r5, #3
 80011a0:	0099      	lsls	r1, r3, #2
 80011a2:	230f      	movs	r3, #15
 80011a4:	408b      	lsls	r3, r1
 80011a6:	ea20 0003 	bic.w	r0, r0, r3
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4u * (position & 0x03u)));
 80011aa:	4b75      	ldr	r3, [pc, #468]	; (8001380 <HAL_GPIO_Init+0x2f4>)
 80011ac:	4598      	cmp	r8, r3
 80011ae:	d07b      	beq.n	80012a8 <HAL_GPIO_Init+0x21c>
 80011b0:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80011b4:	4598      	cmp	r8, r3
 80011b6:	f000 80df 	beq.w	8001378 <HAL_GPIO_Init+0x2ec>
 80011ba:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80011be:	4598      	cmp	r8, r3
 80011c0:	f000 80dc 	beq.w	800137c <HAL_GPIO_Init+0x2f0>
 80011c4:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80011c8:	4598      	cmp	r8, r3
 80011ca:	f000 80e9 	beq.w	80013a0 <HAL_GPIO_Init+0x314>
 80011ce:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80011d2:	4598      	cmp	r8, r3
 80011d4:	f000 80e6 	beq.w	80013a4 <HAL_GPIO_Init+0x318>
 80011d8:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80011dc:	4598      	cmp	r8, r3
 80011de:	d061      	beq.n	80012a4 <HAL_GPIO_Init+0x218>
 80011e0:	2306      	movs	r3, #6
 80011e2:	e062      	b.n	80012aa <HAL_GPIO_Init+0x21e>
      switch (GPIO_Init->Mode)
 80011e4:	4a6b      	ldr	r2, [pc, #428]	; (8001394 <HAL_GPIO_Init+0x308>)
 80011e6:	4293      	cmp	r3, r2
 80011e8:	d014      	beq.n	8001214 <HAL_GPIO_Init+0x188>
 80011ea:	d90b      	bls.n	8001204 <HAL_GPIO_Init+0x178>
 80011ec:	4a6a      	ldr	r2, [pc, #424]	; (8001398 <HAL_GPIO_Init+0x30c>)
 80011ee:	4293      	cmp	r3, r2
 80011f0:	d010      	beq.n	8001214 <HAL_GPIO_Init+0x188>
 80011f2:	f502 3280 	add.w	r2, r2, #65536	; 0x10000
 80011f6:	4293      	cmp	r3, r2
 80011f8:	d00c      	beq.n	8001214 <HAL_GPIO_Init+0x188>
 80011fa:	f5a2 1280 	sub.w	r2, r2, #1048576	; 0x100000
 80011fe:	4293      	cmp	r3, r2
 8001200:	d1a7      	bne.n	8001152 <HAL_GPIO_Init+0xc6>
 8001202:	e007      	b.n	8001214 <HAL_GPIO_Init+0x188>
 8001204:	f5a2 1280 	sub.w	r2, r2, #1048576	; 0x100000
 8001208:	4293      	cmp	r3, r2
 800120a:	d003      	beq.n	8001214 <HAL_GPIO_Init+0x188>
 800120c:	f502 3280 	add.w	r2, r2, #65536	; 0x10000
 8001210:	4293      	cmp	r3, r2
 8001212:	d19e      	bne.n	8001152 <HAL_GPIO_Init+0xc6>
          assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
 8001214:	68bb      	ldr	r3, [r7, #8]
 8001216:	2b02      	cmp	r3, #2
 8001218:	d82d      	bhi.n	8001276 <HAL_GPIO_Init+0x1ea>
          if (GPIO_Init->Pull == GPIO_NOPULL)
 800121a:	68bb      	ldr	r3, [r7, #8]
 800121c:	2b00      	cmp	r3, #0
 800121e:	d037      	beq.n	8001290 <HAL_GPIO_Init+0x204>
          else if (GPIO_Init->Pull == GPIO_PULLUP)
 8001220:	2b01      	cmp	r3, #1
 8001222:	d02d      	beq.n	8001280 <HAL_GPIO_Init+0x1f4>
            GPIOx->BRR = ioposition;
 8001224:	f8c8 6014 	str.w	r6, [r8, #20]
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
 8001228:	f04f 0908 	mov.w	r9, #8
 800122c:	e791      	b.n	8001152 <HAL_GPIO_Init+0xc6>
          assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
 800122e:	21d5      	movs	r1, #213	; 0xd5
 8001230:	4854      	ldr	r0, [pc, #336]	; (8001384 <HAL_GPIO_Init+0x2f8>)
 8001232:	f004 fa51 	bl	80056d8 <assert_failed>
 8001236:	e78a      	b.n	800114e <HAL_GPIO_Init+0xc2>
          assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
 8001238:	21dc      	movs	r1, #220	; 0xdc
 800123a:	4852      	ldr	r0, [pc, #328]	; (8001384 <HAL_GPIO_Init+0x2f8>)
 800123c:	f004 fa4c 	bl	80056d8 <assert_failed>
 8001240:	e096      	b.n	8001370 <HAL_GPIO_Init+0x2e4>
          assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
 8001242:	68fb      	ldr	r3, [r7, #12]
 8001244:	3b01      	subs	r3, #1
 8001246:	2b02      	cmp	r3, #2
 8001248:	d803      	bhi.n	8001252 <HAL_GPIO_Init+0x1c6>
          config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_PP;
 800124a:	68fb      	ldr	r3, [r7, #12]
 800124c:	f103 0908 	add.w	r9, r3, #8
          break;
 8001250:	e77f      	b.n	8001152 <HAL_GPIO_Init+0xc6>
          assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
 8001252:	21e3      	movs	r1, #227	; 0xe3
 8001254:	484b      	ldr	r0, [pc, #300]	; (8001384 <HAL_GPIO_Init+0x2f8>)
 8001256:	f004 fa3f 	bl	80056d8 <assert_failed>
 800125a:	e7f6      	b.n	800124a <HAL_GPIO_Init+0x1be>
          assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
 800125c:	68fb      	ldr	r3, [r7, #12]
 800125e:	3b01      	subs	r3, #1
 8001260:	2b02      	cmp	r3, #2
 8001262:	d803      	bhi.n	800126c <HAL_GPIO_Init+0x1e0>
          config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_OD;
 8001264:	68fb      	ldr	r3, [r7, #12]
 8001266:	f103 090c 	add.w	r9, r3, #12
          break;
 800126a:	e772      	b.n	8001152 <HAL_GPIO_Init+0xc6>
          assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
 800126c:	21ea      	movs	r1, #234	; 0xea
 800126e:	4845      	ldr	r0, [pc, #276]	; (8001384 <HAL_GPIO_Init+0x2f8>)
 8001270:	f004 fa32 	bl	80056d8 <assert_failed>
 8001274:	e7f6      	b.n	8001264 <HAL_GPIO_Init+0x1d8>
          assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
 8001276:	21f7      	movs	r1, #247	; 0xf7
 8001278:	4842      	ldr	r0, [pc, #264]	; (8001384 <HAL_GPIO_Init+0x2f8>)
 800127a:	f004 fa2d 	bl	80056d8 <assert_failed>
 800127e:	e7cc      	b.n	800121a <HAL_GPIO_Init+0x18e>
            GPIOx->BSRR = ioposition;
 8001280:	f8c8 6010 	str.w	r6, [r8, #16]
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
 8001284:	f04f 0908 	mov.w	r9, #8
 8001288:	e763      	b.n	8001152 <HAL_GPIO_Init+0xc6>
          config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_ANALOG;
 800128a:	f04f 0900 	mov.w	r9, #0
 800128e:	e760      	b.n	8001152 <HAL_GPIO_Init+0xc6>
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_FLOATING;
 8001290:	f04f 0904 	mov.w	r9, #4
 8001294:	e75d      	b.n	8001152 <HAL_GPIO_Init+0xc6>
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 8001296:	f108 0004 	add.w	r0, r8, #4
 800129a:	e75e      	b.n	800115a <HAL_GPIO_Init+0xce>
      registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2u) : ((position - 8u) << 2u);
 800129c:	f1a5 0208 	sub.w	r2, r5, #8
 80012a0:	0092      	lsls	r2, r2, #2
 80012a2:	e75e      	b.n	8001162 <HAL_GPIO_Init+0xd6>
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4u * (position & 0x03u)));
 80012a4:	2305      	movs	r3, #5
 80012a6:	e000      	b.n	80012aa <HAL_GPIO_Init+0x21e>
 80012a8:	2300      	movs	r3, #0
 80012aa:	408b      	lsls	r3, r1
 80012ac:	4303      	orrs	r3, r0
        AFIO->EXTICR[position >> 2u] = temp;
 80012ae:	3202      	adds	r2, #2
 80012b0:	4937      	ldr	r1, [pc, #220]	; (8001390 <HAL_GPIO_Init+0x304>)
 80012b2:	f841 3022 	str.w	r3, [r1, r2, lsl #2]


        /* Configure the interrupt mask */
        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 80012b6:	687b      	ldr	r3, [r7, #4]
 80012b8:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 80012bc:	d074      	beq.n	80013a8 <HAL_GPIO_Init+0x31c>
        {
          SET_BIT(EXTI->IMR, iocurrent);
 80012be:	4a37      	ldr	r2, [pc, #220]	; (800139c <HAL_GPIO_Init+0x310>)
 80012c0:	6813      	ldr	r3, [r2, #0]
 80012c2:	4323      	orrs	r3, r4
 80012c4:	6013      	str	r3, [r2, #0]
        {
          CLEAR_BIT(EXTI->IMR, iocurrent);
        }

        /* Configure the event mask */
        if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 80012c6:	687b      	ldr	r3, [r7, #4]
 80012c8:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 80012cc:	d072      	beq.n	80013b4 <HAL_GPIO_Init+0x328>
        {
          SET_BIT(EXTI->EMR, iocurrent);
 80012ce:	4a33      	ldr	r2, [pc, #204]	; (800139c <HAL_GPIO_Init+0x310>)
 80012d0:	6853      	ldr	r3, [r2, #4]
 80012d2:	4323      	orrs	r3, r4
 80012d4:	6053      	str	r3, [r2, #4]
        {
          CLEAR_BIT(EXTI->EMR, iocurrent);
        }

        /* Enable or disable the rising trigger */
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 80012d6:	687b      	ldr	r3, [r7, #4]
 80012d8:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 80012dc:	d070      	beq.n	80013c0 <HAL_GPIO_Init+0x334>
        {
          SET_BIT(EXTI->RTSR, iocurrent);
 80012de:	4a2f      	ldr	r2, [pc, #188]	; (800139c <HAL_GPIO_Init+0x310>)
 80012e0:	6893      	ldr	r3, [r2, #8]
 80012e2:	4323      	orrs	r3, r4
 80012e4:	6093      	str	r3, [r2, #8]
        {
          CLEAR_BIT(EXTI->RTSR, iocurrent);
        }

        /* Enable or disable the falling trigger */
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 80012e6:	687b      	ldr	r3, [r7, #4]
 80012e8:	f413 1f00 	tst.w	r3, #2097152	; 0x200000
 80012ec:	d06e      	beq.n	80013cc <HAL_GPIO_Init+0x340>
        {
          SET_BIT(EXTI->FTSR, iocurrent);
 80012ee:	4a2b      	ldr	r2, [pc, #172]	; (800139c <HAL_GPIO_Init+0x310>)
 80012f0:	68d3      	ldr	r3, [r2, #12]
 80012f2:	431c      	orrs	r4, r3
 80012f4:	60d4      	str	r4, [r2, #12]
          CLEAR_BIT(EXTI->FTSR, iocurrent);
        }
      }
    }

	position++;
 80012f6:	3501      	adds	r5, #1
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 80012f8:	683c      	ldr	r4, [r7, #0]
 80012fa:	fa34 f305 	lsrs.w	r3, r4, r5
 80012fe:	d06b      	beq.n	80013d8 <HAL_GPIO_Init+0x34c>
    ioposition = (0x01uL << position);
 8001300:	2601      	movs	r6, #1
 8001302:	40ae      	lsls	r6, r5
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8001304:	4034      	ands	r4, r6
    if (iocurrent == ioposition)
 8001306:	42a6      	cmp	r6, r4
 8001308:	d1f5      	bne.n	80012f6 <HAL_GPIO_Init+0x26a>
      assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
 800130a:	4b1d      	ldr	r3, [pc, #116]	; (8001380 <HAL_GPIO_Init+0x2f4>)
 800130c:	4598      	cmp	r8, r3
 800130e:	d01b      	beq.n	8001348 <HAL_GPIO_Init+0x2bc>
 8001310:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001314:	4598      	cmp	r8, r3
 8001316:	d017      	beq.n	8001348 <HAL_GPIO_Init+0x2bc>
 8001318:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800131c:	4598      	cmp	r8, r3
 800131e:	d013      	beq.n	8001348 <HAL_GPIO_Init+0x2bc>
 8001320:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001324:	4598      	cmp	r8, r3
 8001326:	d00f      	beq.n	8001348 <HAL_GPIO_Init+0x2bc>
 8001328:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800132c:	4598      	cmp	r8, r3
 800132e:	d00b      	beq.n	8001348 <HAL_GPIO_Init+0x2bc>
 8001330:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001334:	4598      	cmp	r8, r3
 8001336:	d007      	beq.n	8001348 <HAL_GPIO_Init+0x2bc>
 8001338:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800133c:	4598      	cmp	r8, r3
 800133e:	d003      	beq.n	8001348 <HAL_GPIO_Init+0x2bc>
 8001340:	21cd      	movs	r1, #205	; 0xcd
 8001342:	4810      	ldr	r0, [pc, #64]	; (8001384 <HAL_GPIO_Init+0x2f8>)
 8001344:	f004 f9c8 	bl	80056d8 <assert_failed>
      switch (GPIO_Init->Mode)
 8001348:	687b      	ldr	r3, [r7, #4]
 800134a:	2b12      	cmp	r3, #18
 800134c:	d086      	beq.n	800125c <HAL_GPIO_Init+0x1d0>
 800134e:	f63f af49 	bhi.w	80011e4 <HAL_GPIO_Init+0x158>
 8001352:	2b02      	cmp	r3, #2
 8001354:	f43f af75 	beq.w	8001242 <HAL_GPIO_Init+0x1b6>
 8001358:	f67f aef1 	bls.w	800113e <HAL_GPIO_Init+0xb2>
 800135c:	2b03      	cmp	r3, #3
 800135e:	d094      	beq.n	800128a <HAL_GPIO_Init+0x1fe>
 8001360:	2b11      	cmp	r3, #17
 8001362:	f47f aef6 	bne.w	8001152 <HAL_GPIO_Init+0xc6>
          assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
 8001366:	68fb      	ldr	r3, [r7, #12]
 8001368:	3b01      	subs	r3, #1
 800136a:	2b02      	cmp	r3, #2
 800136c:	f63f af64 	bhi.w	8001238 <HAL_GPIO_Init+0x1ac>
          config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_OD;
 8001370:	68fb      	ldr	r3, [r7, #12]
 8001372:	f103 0904 	add.w	r9, r3, #4
          break;
 8001376:	e6ec      	b.n	8001152 <HAL_GPIO_Init+0xc6>
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4u * (position & 0x03u)));
 8001378:	2301      	movs	r3, #1
 800137a:	e796      	b.n	80012aa <HAL_GPIO_Init+0x21e>
 800137c:	2302      	movs	r3, #2
 800137e:	e794      	b.n	80012aa <HAL_GPIO_Init+0x21e>
 8001380:	40010800 	.word	0x40010800
 8001384:	08005da0 	.word	0x08005da0
 8001388:	10110000 	.word	0x10110000
 800138c:	40021000 	.word	0x40021000
 8001390:	40010000 	.word	0x40010000
 8001394:	10210000 	.word	0x10210000
 8001398:	10310000 	.word	0x10310000
 800139c:	40010400 	.word	0x40010400
 80013a0:	2303      	movs	r3, #3
 80013a2:	e782      	b.n	80012aa <HAL_GPIO_Init+0x21e>
 80013a4:	2304      	movs	r3, #4
 80013a6:	e780      	b.n	80012aa <HAL_GPIO_Init+0x21e>
          CLEAR_BIT(EXTI->IMR, iocurrent);
 80013a8:	4a0d      	ldr	r2, [pc, #52]	; (80013e0 <HAL_GPIO_Init+0x354>)
 80013aa:	6813      	ldr	r3, [r2, #0]
 80013ac:	ea23 0304 	bic.w	r3, r3, r4
 80013b0:	6013      	str	r3, [r2, #0]
 80013b2:	e788      	b.n	80012c6 <HAL_GPIO_Init+0x23a>
          CLEAR_BIT(EXTI->EMR, iocurrent);
 80013b4:	4a0a      	ldr	r2, [pc, #40]	; (80013e0 <HAL_GPIO_Init+0x354>)
 80013b6:	6853      	ldr	r3, [r2, #4]
 80013b8:	ea23 0304 	bic.w	r3, r3, r4
 80013bc:	6053      	str	r3, [r2, #4]
 80013be:	e78a      	b.n	80012d6 <HAL_GPIO_Init+0x24a>
          CLEAR_BIT(EXTI->RTSR, iocurrent);
 80013c0:	4a07      	ldr	r2, [pc, #28]	; (80013e0 <HAL_GPIO_Init+0x354>)
 80013c2:	6893      	ldr	r3, [r2, #8]
 80013c4:	ea23 0304 	bic.w	r3, r3, r4
 80013c8:	6093      	str	r3, [r2, #8]
 80013ca:	e78c      	b.n	80012e6 <HAL_GPIO_Init+0x25a>
          CLEAR_BIT(EXTI->FTSR, iocurrent);
 80013cc:	4a04      	ldr	r2, [pc, #16]	; (80013e0 <HAL_GPIO_Init+0x354>)
 80013ce:	68d3      	ldr	r3, [r2, #12]
 80013d0:	ea23 0404 	bic.w	r4, r3, r4
 80013d4:	60d4      	str	r4, [r2, #12]
 80013d6:	e78e      	b.n	80012f6 <HAL_GPIO_Init+0x26a>
  }
}
 80013d8:	b003      	add	sp, #12
 80013da:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80013de:	bf00      	nop
 80013e0:	40010400 	.word	0x40010400

080013e4 <I2C_Master_SB>:
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_Master_SB(I2C_HandleTypeDef *hi2c)
{
  if (hi2c->Mode == HAL_I2C_MODE_MEM)
 80013e4:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
 80013e8:	b2db      	uxtb	r3, r3
 80013ea:	2b40      	cmp	r3, #64	; 0x40
 80013ec:	d00a      	beq.n	8001404 <I2C_Master_SB+0x20>
      hi2c->Instance->DR = I2C_7BIT_ADD_READ(hi2c->Devaddress);
    }
  }
  else
  {
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 80013ee:	6903      	ldr	r3, [r0, #16]
 80013f0:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 80013f4:	d015      	beq.n	8001422 <I2C_Master_SB+0x3e>
        SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
      }
    }
    else
    {
      if (hi2c->EventCount == 0U)
 80013f6:	6d03      	ldr	r3, [r0, #80]	; 0x50
 80013f8:	2b00      	cmp	r3, #0
 80013fa:	d034      	beq.n	8001466 <I2C_Master_SB+0x82>
      {
        /* Send header of slave address */
        hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(hi2c->Devaddress);
      }
      else if (hi2c->EventCount == 1U)
 80013fc:	6d03      	ldr	r3, [r0, #80]	; 0x50
 80013fe:	2b01      	cmp	r3, #1
 8001400:	d03b      	beq.n	800147a <I2C_Master_SB+0x96>
      {
        /* Do nothing */
      }
    }
  }
}
 8001402:	4770      	bx	lr
    if (hi2c->EventCount == 0U)
 8001404:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8001406:	b92b      	cbnz	r3, 8001414 <I2C_Master_SB+0x30>
      hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(hi2c->Devaddress);
 8001408:	6c43      	ldr	r3, [r0, #68]	; 0x44
 800140a:	6802      	ldr	r2, [r0, #0]
 800140c:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 8001410:	6113      	str	r3, [r2, #16]
 8001412:	4770      	bx	lr
      hi2c->Instance->DR = I2C_7BIT_ADD_READ(hi2c->Devaddress);
 8001414:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8001416:	6802      	ldr	r2, [r0, #0]
 8001418:	f043 0301 	orr.w	r3, r3, #1
 800141c:	b2db      	uxtb	r3, r3
 800141e:	6113      	str	r3, [r2, #16]
 8001420:	4770      	bx	lr
      if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
 8001422:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8001426:	b2db      	uxtb	r3, r3
 8001428:	2b21      	cmp	r3, #33	; 0x21
 800142a:	d00f      	beq.n	800144c <I2C_Master_SB+0x68>
        hi2c->Instance->DR = I2C_7BIT_ADD_READ(hi2c->Devaddress);
 800142c:	6c43      	ldr	r3, [r0, #68]	; 0x44
 800142e:	6802      	ldr	r2, [r0, #0]
 8001430:	f043 0301 	orr.w	r3, r3, #1
 8001434:	b2db      	uxtb	r3, r3
 8001436:	6113      	str	r3, [r2, #16]
      if (((hi2c->hdmatx != NULL) && (hi2c->hdmatx->XferCpltCallback != NULL))
 8001438:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800143a:	b16b      	cbz	r3, 8001458 <I2C_Master_SB+0x74>
 800143c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800143e:	b15b      	cbz	r3, 8001458 <I2C_Master_SB+0x74>
        SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
 8001440:	6802      	ldr	r2, [r0, #0]
 8001442:	6853      	ldr	r3, [r2, #4]
 8001444:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8001448:	6053      	str	r3, [r2, #4]
 800144a:	4770      	bx	lr
        hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(hi2c->Devaddress);
 800144c:	6c43      	ldr	r3, [r0, #68]	; 0x44
 800144e:	6802      	ldr	r2, [r0, #0]
 8001450:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 8001454:	6113      	str	r3, [r2, #16]
 8001456:	e7ef      	b.n	8001438 <I2C_Master_SB+0x54>
          || ((hi2c->hdmarx != NULL) && (hi2c->hdmarx->XferCpltCallback != NULL)))
 8001458:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800145a:	2b00      	cmp	r3, #0
 800145c:	d0d1      	beq.n	8001402 <I2C_Master_SB+0x1e>
 800145e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001460:	2b00      	cmp	r3, #0
 8001462:	d1ed      	bne.n	8001440 <I2C_Master_SB+0x5c>
 8001464:	e7cd      	b.n	8001402 <I2C_Master_SB+0x1e>
        hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(hi2c->Devaddress);
 8001466:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8001468:	f3c3 13c8 	ubfx	r3, r3, #7, #9
 800146c:	6802      	ldr	r2, [r0, #0]
 800146e:	f003 0306 	and.w	r3, r3, #6
 8001472:	f043 03f0 	orr.w	r3, r3, #240	; 0xf0
 8001476:	6113      	str	r3, [r2, #16]
 8001478:	4770      	bx	lr
        hi2c->Instance->DR = I2C_10BIT_HEADER_READ(hi2c->Devaddress);
 800147a:	6c43      	ldr	r3, [r0, #68]	; 0x44
 800147c:	f3c3 13c8 	ubfx	r3, r3, #7, #9
 8001480:	6802      	ldr	r2, [r0, #0]
 8001482:	f003 0306 	and.w	r3, r3, #6
 8001486:	f043 03f1 	orr.w	r3, r3, #241	; 0xf1
 800148a:	6113      	str	r3, [r2, #16]
}
 800148c:	e7b9      	b.n	8001402 <I2C_Master_SB+0x1e>

0800148e <I2C_Master_ADD10>:
  * @retval None
  */
static void I2C_Master_ADD10(I2C_HandleTypeDef *hi2c)
{
  /* Send slave address */
  hi2c->Instance->DR = I2C_10BIT_ADDRESS(hi2c->Devaddress);
 800148e:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8001490:	6802      	ldr	r2, [r0, #0]
 8001492:	b2db      	uxtb	r3, r3
 8001494:	6113      	str	r3, [r2, #16]

  if ((hi2c->hdmatx != NULL) || (hi2c->hdmarx != NULL))
 8001496:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8001498:	b13b      	cbz	r3, 80014aa <I2C_Master_ADD10+0x1c>
  {
    if ((hi2c->hdmatx->XferCpltCallback != NULL) || (hi2c->hdmarx->XferCpltCallback != NULL))
 800149a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800149c:	b14b      	cbz	r3, 80014b2 <I2C_Master_ADD10+0x24>
    {
      /* Enable DMA Request */
      SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
 800149e:	6802      	ldr	r2, [r0, #0]
 80014a0:	6853      	ldr	r3, [r2, #4]
 80014a2:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 80014a6:	6053      	str	r3, [r2, #4]
    }
  }
}
 80014a8:	4770      	bx	lr
  if ((hi2c->hdmatx != NULL) || (hi2c->hdmarx != NULL))
 80014aa:	6b82      	ldr	r2, [r0, #56]	; 0x38
 80014ac:	2a00      	cmp	r2, #0
 80014ae:	d1f4      	bne.n	800149a <I2C_Master_ADD10+0xc>
 80014b0:	e7fa      	b.n	80014a8 <I2C_Master_ADD10+0x1a>
    if ((hi2c->hdmatx->XferCpltCallback != NULL) || (hi2c->hdmarx->XferCpltCallback != NULL))
 80014b2:	6b83      	ldr	r3, [r0, #56]	; 0x38
 80014b4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80014b6:	2b00      	cmp	r3, #0
 80014b8:	d1f1      	bne.n	800149e <I2C_Master_ADD10+0x10>
 80014ba:	e7f5      	b.n	80014a8 <I2C_Master_ADD10+0x1a>

080014bc <I2C_Master_ADDR>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_Master_ADDR(I2C_HandleTypeDef *hi2c)
{
 80014bc:	b410      	push	{r4}
 80014be:	b08d      	sub	sp, #52	; 0x34
  /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
  HAL_I2C_ModeTypeDef CurrentMode       = hi2c->Mode;
 80014c0:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
 80014c4:	b2da      	uxtb	r2, r3
  uint32_t CurrentXferOptions           = hi2c->XferOptions;
 80014c6:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
  uint32_t Prev_State                   = hi2c->PreviousState;
 80014c8:	6b04      	ldr	r4, [r0, #48]	; 0x30

  if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
 80014ca:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 80014ce:	b2db      	uxtb	r3, r3
 80014d0:	2b22      	cmp	r3, #34	; 0x22
 80014d2:	d00a      	beq.n	80014ea <I2C_Master_ADDR+0x2e>
    }
  }
  else
  {
    /* Clear ADDR flag */
    __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 80014d4:	2300      	movs	r3, #0
 80014d6:	930b      	str	r3, [sp, #44]	; 0x2c
 80014d8:	6803      	ldr	r3, [r0, #0]
 80014da:	695a      	ldr	r2, [r3, #20]
 80014dc:	920b      	str	r2, [sp, #44]	; 0x2c
 80014de:	699b      	ldr	r3, [r3, #24]
 80014e0:	930b      	str	r3, [sp, #44]	; 0x2c
 80014e2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  }
}
 80014e4:	b00d      	add	sp, #52	; 0x34
 80014e6:	bc10      	pop	{r4}
 80014e8:	4770      	bx	lr
    if ((hi2c->EventCount == 0U) && (CurrentMode == HAL_I2C_MODE_MEM))
 80014ea:	6d03      	ldr	r3, [r0, #80]	; 0x50
 80014ec:	b90b      	cbnz	r3, 80014f2 <I2C_Master_ADDR+0x36>
 80014ee:	2a40      	cmp	r2, #64	; 0x40
 80014f0:	d017      	beq.n	8001522 <I2C_Master_ADDR+0x66>
    else if ((hi2c->EventCount == 0U) && (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT))
 80014f2:	6d03      	ldr	r3, [r0, #80]	; 0x50
 80014f4:	b91b      	cbnz	r3, 80014fe <I2C_Master_ADDR+0x42>
 80014f6:	6903      	ldr	r3, [r0, #16]
 80014f8:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
 80014fc:	d019      	beq.n	8001532 <I2C_Master_ADDR+0x76>
      if (hi2c->XferCount == 0U)
 80014fe:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8001500:	b29b      	uxth	r3, r3
 8001502:	2b00      	cmp	r3, #0
 8001504:	d125      	bne.n	8001552 <I2C_Master_ADDR+0x96>
        __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8001506:	9303      	str	r3, [sp, #12]
 8001508:	6803      	ldr	r3, [r0, #0]
 800150a:	695a      	ldr	r2, [r3, #20]
 800150c:	9203      	str	r2, [sp, #12]
 800150e:	699a      	ldr	r2, [r3, #24]
 8001510:	9203      	str	r2, [sp, #12]
 8001512:	9a03      	ldr	r2, [sp, #12]
        SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8001514:	681a      	ldr	r2, [r3, #0]
 8001516:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800151a:	601a      	str	r2, [r3, #0]
      hi2c->EventCount = 0U;
 800151c:	2300      	movs	r3, #0
 800151e:	6503      	str	r3, [r0, #80]	; 0x50
 8001520:	e7e0      	b.n	80014e4 <I2C_Master_ADDR+0x28>
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8001522:	9301      	str	r3, [sp, #4]
 8001524:	6803      	ldr	r3, [r0, #0]
 8001526:	695a      	ldr	r2, [r3, #20]
 8001528:	9201      	str	r2, [sp, #4]
 800152a:	699b      	ldr	r3, [r3, #24]
 800152c:	9301      	str	r3, [sp, #4]
 800152e:	9b01      	ldr	r3, [sp, #4]
 8001530:	e7d8      	b.n	80014e4 <I2C_Master_ADDR+0x28>
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8001532:	2300      	movs	r3, #0
 8001534:	9302      	str	r3, [sp, #8]
 8001536:	6803      	ldr	r3, [r0, #0]
 8001538:	695a      	ldr	r2, [r3, #20]
 800153a:	9202      	str	r2, [sp, #8]
 800153c:	699a      	ldr	r2, [r3, #24]
 800153e:	9202      	str	r2, [sp, #8]
 8001540:	9a02      	ldr	r2, [sp, #8]
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
 8001542:	681a      	ldr	r2, [r3, #0]
 8001544:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8001548:	601a      	str	r2, [r3, #0]
      hi2c->EventCount++;
 800154a:	6d03      	ldr	r3, [r0, #80]	; 0x50
 800154c:	3301      	adds	r3, #1
 800154e:	6503      	str	r3, [r0, #80]	; 0x50
 8001550:	e7c8      	b.n	80014e4 <I2C_Master_ADDR+0x28>
      else if (hi2c->XferCount == 1U)
 8001552:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8001554:	b29b      	uxth	r3, r3
 8001556:	2b01      	cmp	r3, #1
 8001558:	d025      	beq.n	80015a6 <I2C_Master_ADDR+0xea>
      else if (hi2c->XferCount == 2U)
 800155a:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 800155c:	b29b      	uxth	r3, r3
 800155e:	2b02      	cmp	r3, #2
 8001560:	d07b      	beq.n	800165a <I2C_Master_ADDR+0x19e>
        SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8001562:	6802      	ldr	r2, [r0, #0]
 8001564:	6813      	ldr	r3, [r2, #0]
 8001566:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 800156a:	6013      	str	r3, [r2, #0]
        if (((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN) && ((CurrentXferOptions == I2C_NO_OPTION_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME_NO_STOP) || (CurrentXferOptions == I2C_LAST_FRAME)))
 800156c:	6803      	ldr	r3, [r0, #0]
 800156e:	685a      	ldr	r2, [r3, #4]
 8001570:	f412 6f00 	tst.w	r2, #2048	; 0x800
 8001574:	d00e      	beq.n	8001594 <I2C_Master_ADDR+0xd8>
 8001576:	f511 3f80 	cmn.w	r1, #65536	; 0x10000
 800157a:	d007      	beq.n	800158c <I2C_Master_ADDR+0xd0>
 800157c:	2901      	cmp	r1, #1
 800157e:	d005      	beq.n	800158c <I2C_Master_ADDR+0xd0>
 8001580:	2908      	cmp	r1, #8
 8001582:	d003      	beq.n	800158c <I2C_Master_ADDR+0xd0>
 8001584:	2910      	cmp	r1, #16
 8001586:	d001      	beq.n	800158c <I2C_Master_ADDR+0xd0>
 8001588:	2920      	cmp	r1, #32
 800158a:	d103      	bne.n	8001594 <I2C_Master_ADDR+0xd8>
          SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
 800158c:	685a      	ldr	r2, [r3, #4]
 800158e:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8001592:	605a      	str	r2, [r3, #4]
        __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8001594:	2300      	movs	r3, #0
 8001596:	930a      	str	r3, [sp, #40]	; 0x28
 8001598:	6803      	ldr	r3, [r0, #0]
 800159a:	695a      	ldr	r2, [r3, #20]
 800159c:	920a      	str	r2, [sp, #40]	; 0x28
 800159e:	699b      	ldr	r3, [r3, #24]
 80015a0:	930a      	str	r3, [sp, #40]	; 0x28
 80015a2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80015a4:	e7ba      	b.n	800151c <I2C_Master_ADDR+0x60>
        if (CurrentXferOptions == I2C_NO_OPTION_FRAME)
 80015a6:	f511 3f80 	cmn.w	r1, #65536	; 0x10000
 80015aa:	d011      	beq.n	80015d0 <I2C_Master_ADDR+0x114>
        else if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) \
 80015ac:	2908      	cmp	r1, #8
 80015ae:	d034      	beq.n	800161a <I2C_Master_ADDR+0x15e>
 80015b0:	2920      	cmp	r1, #32
 80015b2:	d032      	beq.n	800161a <I2C_Master_ADDR+0x15e>
                 && ((Prev_State != I2C_STATE_MASTER_BUSY_RX) || (CurrentXferOptions == I2C_FIRST_FRAME)))
 80015b4:	2c12      	cmp	r4, #18
 80015b6:	d02e      	beq.n	8001616 <I2C_Master_ADDR+0x15a>
          if ((CurrentXferOptions != I2C_NEXT_FRAME) && (CurrentXferOptions != I2C_FIRST_AND_NEXT_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME_NO_STOP))
 80015b8:	2904      	cmp	r1, #4
 80015ba:	d040      	beq.n	800163e <I2C_Master_ADDR+0x182>
 80015bc:	2902      	cmp	r1, #2
 80015be:	d03e      	beq.n	800163e <I2C_Master_ADDR+0x182>
 80015c0:	2910      	cmp	r1, #16
 80015c2:	d03c      	beq.n	800163e <I2C_Master_ADDR+0x182>
            CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 80015c4:	6802      	ldr	r2, [r0, #0]
 80015c6:	6813      	ldr	r3, [r2, #0]
 80015c8:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80015cc:	6013      	str	r3, [r2, #0]
 80015ce:	e03b      	b.n	8001648 <I2C_Master_ADDR+0x18c>
          CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 80015d0:	6802      	ldr	r2, [r0, #0]
 80015d2:	6813      	ldr	r3, [r2, #0]
 80015d4:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80015d8:	6013      	str	r3, [r2, #0]
          if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
 80015da:	6803      	ldr	r3, [r0, #0]
 80015dc:	685a      	ldr	r2, [r3, #4]
 80015de:	f412 6f00 	tst.w	r2, #2048	; 0x800
 80015e2:	d00c      	beq.n	80015fe <I2C_Master_ADDR+0x142>
            CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 80015e4:	681a      	ldr	r2, [r3, #0]
 80015e6:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 80015ea:	601a      	str	r2, [r3, #0]
            __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 80015ec:	2300      	movs	r3, #0
 80015ee:	9304      	str	r3, [sp, #16]
 80015f0:	6803      	ldr	r3, [r0, #0]
 80015f2:	695a      	ldr	r2, [r3, #20]
 80015f4:	9204      	str	r2, [sp, #16]
 80015f6:	699b      	ldr	r3, [r3, #24]
 80015f8:	9304      	str	r3, [sp, #16]
 80015fa:	9b04      	ldr	r3, [sp, #16]
 80015fc:	e78e      	b.n	800151c <I2C_Master_ADDR+0x60>
            __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 80015fe:	2200      	movs	r2, #0
 8001600:	9205      	str	r2, [sp, #20]
 8001602:	695a      	ldr	r2, [r3, #20]
 8001604:	9205      	str	r2, [sp, #20]
 8001606:	699a      	ldr	r2, [r3, #24]
 8001608:	9205      	str	r2, [sp, #20]
 800160a:	9a05      	ldr	r2, [sp, #20]
            SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 800160c:	681a      	ldr	r2, [r3, #0]
 800160e:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8001612:	601a      	str	r2, [r3, #0]
 8001614:	e782      	b.n	800151c <I2C_Master_ADDR+0x60>
                 && ((Prev_State != I2C_STATE_MASTER_BUSY_RX) || (CurrentXferOptions == I2C_FIRST_FRAME)))
 8001616:	2901      	cmp	r1, #1
 8001618:	d0ce      	beq.n	80015b8 <I2C_Master_ADDR+0xfc>
          CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 800161a:	6802      	ldr	r2, [r0, #0]
 800161c:	6813      	ldr	r3, [r2, #0]
 800161e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8001622:	6013      	str	r3, [r2, #0]
          __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8001624:	2300      	movs	r3, #0
 8001626:	9307      	str	r3, [sp, #28]
 8001628:	6803      	ldr	r3, [r0, #0]
 800162a:	695a      	ldr	r2, [r3, #20]
 800162c:	9207      	str	r2, [sp, #28]
 800162e:	699a      	ldr	r2, [r3, #24]
 8001630:	9207      	str	r2, [sp, #28]
 8001632:	9a07      	ldr	r2, [sp, #28]
          SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8001634:	681a      	ldr	r2, [r3, #0]
 8001636:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800163a:	601a      	str	r2, [r3, #0]
 800163c:	e76e      	b.n	800151c <I2C_Master_ADDR+0x60>
            SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 800163e:	6802      	ldr	r2, [r0, #0]
 8001640:	6813      	ldr	r3, [r2, #0]
 8001642:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8001646:	6013      	str	r3, [r2, #0]
          __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8001648:	2300      	movs	r3, #0
 800164a:	9306      	str	r3, [sp, #24]
 800164c:	6803      	ldr	r3, [r0, #0]
 800164e:	695a      	ldr	r2, [r3, #20]
 8001650:	9206      	str	r2, [sp, #24]
 8001652:	699b      	ldr	r3, [r3, #24]
 8001654:	9306      	str	r3, [sp, #24]
 8001656:	9b06      	ldr	r3, [sp, #24]
 8001658:	e760      	b.n	800151c <I2C_Master_ADDR+0x60>
        if ((CurrentXferOptions != I2C_NEXT_FRAME) && (CurrentXferOptions != I2C_FIRST_AND_NEXT_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME_NO_STOP))
 800165a:	2904      	cmp	r1, #4
 800165c:	d015      	beq.n	800168a <I2C_Master_ADDR+0x1ce>
 800165e:	2902      	cmp	r1, #2
 8001660:	d013      	beq.n	800168a <I2C_Master_ADDR+0x1ce>
 8001662:	2910      	cmp	r1, #16
 8001664:	d011      	beq.n	800168a <I2C_Master_ADDR+0x1ce>
          SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
 8001666:	6802      	ldr	r2, [r0, #0]
 8001668:	6813      	ldr	r3, [r2, #0]
 800166a:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 800166e:	6013      	str	r3, [r2, #0]
          __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8001670:	2300      	movs	r3, #0
 8001672:	9308      	str	r3, [sp, #32]
 8001674:	6803      	ldr	r3, [r0, #0]
 8001676:	695a      	ldr	r2, [r3, #20]
 8001678:	9208      	str	r2, [sp, #32]
 800167a:	699a      	ldr	r2, [r3, #24]
 800167c:	9208      	str	r2, [sp, #32]
 800167e:	9a08      	ldr	r2, [sp, #32]
          CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8001680:	681a      	ldr	r2, [r3, #0]
 8001682:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8001686:	601a      	str	r2, [r3, #0]
 8001688:	e00c      	b.n	80016a4 <I2C_Master_ADDR+0x1e8>
          SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 800168a:	6802      	ldr	r2, [r0, #0]
 800168c:	6813      	ldr	r3, [r2, #0]
 800168e:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8001692:	6013      	str	r3, [r2, #0]
          __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8001694:	2300      	movs	r3, #0
 8001696:	9309      	str	r3, [sp, #36]	; 0x24
 8001698:	6803      	ldr	r3, [r0, #0]
 800169a:	695a      	ldr	r2, [r3, #20]
 800169c:	9209      	str	r2, [sp, #36]	; 0x24
 800169e:	699b      	ldr	r3, [r3, #24]
 80016a0:	9309      	str	r3, [sp, #36]	; 0x24
 80016a2:	9b09      	ldr	r3, [sp, #36]	; 0x24
        if (((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN) && ((CurrentXferOptions == I2C_NO_OPTION_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME_NO_STOP) || (CurrentXferOptions == I2C_LAST_FRAME)))
 80016a4:	6803      	ldr	r3, [r0, #0]
 80016a6:	685a      	ldr	r2, [r3, #4]
 80016a8:	f412 6f00 	tst.w	r2, #2048	; 0x800
 80016ac:	f43f af36 	beq.w	800151c <I2C_Master_ADDR+0x60>
 80016b0:	f511 3f80 	cmn.w	r1, #65536	; 0x10000
 80016b4:	d008      	beq.n	80016c8 <I2C_Master_ADDR+0x20c>
 80016b6:	2901      	cmp	r1, #1
 80016b8:	d006      	beq.n	80016c8 <I2C_Master_ADDR+0x20c>
 80016ba:	2908      	cmp	r1, #8
 80016bc:	d004      	beq.n	80016c8 <I2C_Master_ADDR+0x20c>
 80016be:	2910      	cmp	r1, #16
 80016c0:	d002      	beq.n	80016c8 <I2C_Master_ADDR+0x20c>
 80016c2:	2920      	cmp	r1, #32
 80016c4:	f47f af2a 	bne.w	800151c <I2C_Master_ADDR+0x60>
          SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
 80016c8:	685a      	ldr	r2, [r3, #4]
 80016ca:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 80016ce:	605a      	str	r2, [r3, #4]
 80016d0:	e724      	b.n	800151c <I2C_Master_ADDR+0x60>

080016d2 <I2C_SlaveTransmit_BTF>:
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_SlaveTransmit_BTF(I2C_HandleTypeDef *hi2c)
{
  if (hi2c->XferCount != 0U)
 80016d2:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 80016d4:	b29b      	uxth	r3, r3
 80016d6:	b153      	cbz	r3, 80016ee <I2C_SlaveTransmit_BTF+0x1c>
  {
    /* Write data to DR */
    hi2c->Instance->DR = *hi2c->pBuffPtr;
 80016d8:	6a42      	ldr	r2, [r0, #36]	; 0x24
 80016da:	6803      	ldr	r3, [r0, #0]
 80016dc:	7812      	ldrb	r2, [r2, #0]
 80016de:	611a      	str	r2, [r3, #16]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
 80016e0:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80016e2:	3301      	adds	r3, #1
 80016e4:	6243      	str	r3, [r0, #36]	; 0x24

    /* Update counter */
    hi2c->XferCount--;
 80016e6:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 80016e8:	3b01      	subs	r3, #1
 80016ea:	b29b      	uxth	r3, r3
 80016ec:	8543      	strh	r3, [r0, #42]	; 0x2a
  }
}
 80016ee:	4770      	bx	lr

080016f0 <I2C_SlaveReceive_BTF>:
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_SlaveReceive_BTF(I2C_HandleTypeDef *hi2c)
{
  if (hi2c->XferCount != 0U)
 80016f0:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 80016f2:	b29b      	uxth	r3, r3
 80016f4:	b153      	cbz	r3, 800170c <I2C_SlaveReceive_BTF+0x1c>
  {
    /* Read data from DR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 80016f6:	6803      	ldr	r3, [r0, #0]
 80016f8:	691a      	ldr	r2, [r3, #16]
 80016fa:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80016fc:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
 80016fe:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8001700:	3301      	adds	r3, #1
 8001702:	6243      	str	r3, [r0, #36]	; 0x24

    /* Update counter */
    hi2c->XferCount--;
 8001704:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8001706:	3b01      	subs	r3, #1
 8001708:	b29b      	uxth	r3, r3
 800170a:	8543      	strh	r3, [r0, #42]	; 0x2a
  }
}
 800170c:	4770      	bx	lr
	...

08001710 <I2C_WaitOnSTOPRequestThroughIT>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnSTOPRequestThroughIT(I2C_HandleTypeDef *hi2c)
{
 8001710:	b082      	sub	sp, #8
  __IO uint32_t count = 0U;
 8001712:	2300      	movs	r3, #0
 8001714:	9301      	str	r3, [sp, #4]

  /* Wait until STOP flag is reset */
  count = I2C_TIMEOUT_STOP_FLAG * (SystemCoreClock / 25U / 1000U);
 8001716:	4b0e      	ldr	r3, [pc, #56]	; (8001750 <I2C_WaitOnSTOPRequestThroughIT+0x40>)
 8001718:	681b      	ldr	r3, [r3, #0]
 800171a:	08db      	lsrs	r3, r3, #3
 800171c:	4a0d      	ldr	r2, [pc, #52]	; (8001754 <I2C_WaitOnSTOPRequestThroughIT+0x44>)
 800171e:	fba2 2303 	umull	r2, r3, r2, r3
 8001722:	0a1b      	lsrs	r3, r3, #8
 8001724:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8001728:	9301      	str	r3, [sp, #4]
  do
  {
    count--;
 800172a:	9b01      	ldr	r3, [sp, #4]
 800172c:	3b01      	subs	r3, #1
 800172e:	9301      	str	r3, [sp, #4]
    if (count == 0U)
 8001730:	9b01      	ldr	r3, [sp, #4]
 8001732:	b133      	cbz	r3, 8001742 <I2C_WaitOnSTOPRequestThroughIT+0x32>
      hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;

      return HAL_ERROR;
    }
  }
  while (READ_BIT(hi2c->Instance->CR1, I2C_CR1_STOP) == I2C_CR1_STOP);
 8001734:	6803      	ldr	r3, [r0, #0]
 8001736:	681b      	ldr	r3, [r3, #0]
 8001738:	f413 7f00 	tst.w	r3, #512	; 0x200
 800173c:	d1f5      	bne.n	800172a <I2C_WaitOnSTOPRequestThroughIT+0x1a>

  return HAL_OK;
 800173e:	2000      	movs	r0, #0
 8001740:	e004      	b.n	800174c <I2C_WaitOnSTOPRequestThroughIT+0x3c>
      hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
 8001742:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8001744:	f043 0320 	orr.w	r3, r3, #32
 8001748:	6403      	str	r3, [r0, #64]	; 0x40
      return HAL_ERROR;
 800174a:	2001      	movs	r0, #1
}
 800174c:	b002      	add	sp, #8
 800174e:	4770      	bx	lr
 8001750:	2000000c 	.word	0x2000000c
 8001754:	14f8b589 	.word	0x14f8b589

08001758 <I2C_ConvertOtherXferOptions>:
static void I2C_ConvertOtherXferOptions(I2C_HandleTypeDef *hi2c)
{
  /* if user set XferOptions to I2C_OTHER_FRAME            */
  /* it request implicitly to generate a restart condition */
  /* set XferOptions to I2C_FIRST_FRAME                    */
  if (hi2c->XferOptions == I2C_OTHER_FRAME)
 8001758:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800175a:	f5b3 0f2a 	cmp.w	r3, #11141120	; 0xaa0000
 800175e:	d004      	beq.n	800176a <I2C_ConvertOtherXferOptions+0x12>
  }
  /* else if user set XferOptions to I2C_OTHER_AND_LAST_FRAME */
  /* it request implicitly to generate a restart condition    */
  /* then generate a stop condition at the end of transfer    */
  /* set XferOptions to I2C_FIRST_AND_LAST_FRAME              */
  else if (hi2c->XferOptions == I2C_OTHER_AND_LAST_FRAME)
 8001760:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8001762:	f1b3 4f2a 	cmp.w	r3, #2852126720	; 0xaa000000
 8001766:	d003      	beq.n	8001770 <I2C_ConvertOtherXferOptions+0x18>
  }
  else
  {
    /* Nothing to do */
  }
}
 8001768:	4770      	bx	lr
    hi2c->XferOptions = I2C_FIRST_FRAME;
 800176a:	2301      	movs	r3, #1
 800176c:	62c3      	str	r3, [r0, #44]	; 0x2c
 800176e:	4770      	bx	lr
    hi2c->XferOptions = I2C_FIRST_AND_LAST_FRAME;
 8001770:	2308      	movs	r3, #8
 8001772:	62c3      	str	r3, [r0, #44]	; 0x2c
}
 8001774:	e7f8      	b.n	8001768 <I2C_ConvertOtherXferOptions+0x10>
	...

08001778 <HAL_I2C_Init>:
  if (hi2c == NULL)
 8001778:	2800      	cmp	r0, #0
 800177a:	f000 8137 	beq.w	80019ec <HAL_I2C_Init+0x274>
{
 800177e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001780:	4604      	mov	r4, r0
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8001782:	6803      	ldr	r3, [r0, #0]
 8001784:	4a9b      	ldr	r2, [pc, #620]	; (80019f4 <HAL_I2C_Init+0x27c>)
 8001786:	4293      	cmp	r3, r2
 8001788:	d008      	beq.n	800179c <HAL_I2C_Init+0x24>
 800178a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800178e:	4293      	cmp	r3, r2
 8001790:	d004      	beq.n	800179c <HAL_I2C_Init+0x24>
 8001792:	f240 11d1 	movw	r1, #465	; 0x1d1
 8001796:	4898      	ldr	r0, [pc, #608]	; (80019f8 <HAL_I2C_Init+0x280>)
 8001798:	f003 ff9e 	bl	80056d8 <assert_failed>
  assert_param(IS_I2C_CLOCK_SPEED(hi2c->Init.ClockSpeed));
 800179c:	6863      	ldr	r3, [r4, #4]
 800179e:	3b01      	subs	r3, #1
 80017a0:	4a96      	ldr	r2, [pc, #600]	; (80019fc <HAL_I2C_Init+0x284>)
 80017a2:	4293      	cmp	r3, r2
 80017a4:	f200 80a5 	bhi.w	80018f2 <HAL_I2C_Init+0x17a>
  assert_param(IS_I2C_DUTY_CYCLE(hi2c->Init.DutyCycle));
 80017a8:	68a3      	ldr	r3, [r4, #8]
 80017aa:	b11b      	cbz	r3, 80017b4 <HAL_I2C_Init+0x3c>
 80017ac:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 80017b0:	f040 80a5 	bne.w	80018fe <HAL_I2C_Init+0x186>
  assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
 80017b4:	68e3      	ldr	r3, [r4, #12]
 80017b6:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
 80017ba:	f023 0303 	bic.w	r3, r3, #3
 80017be:	2b00      	cmp	r3, #0
 80017c0:	f040 80a3 	bne.w	800190a <HAL_I2C_Init+0x192>
  assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
 80017c4:	6923      	ldr	r3, [r4, #16]
 80017c6:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 80017ca:	d003      	beq.n	80017d4 <HAL_I2C_Init+0x5c>
 80017cc:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
 80017d0:	f040 80a1 	bne.w	8001916 <HAL_I2C_Init+0x19e>
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
 80017d4:	6963      	ldr	r3, [r4, #20]
 80017d6:	2b01      	cmp	r3, #1
 80017d8:	f200 80a3 	bhi.w	8001922 <HAL_I2C_Init+0x1aa>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
 80017dc:	69a3      	ldr	r3, [r4, #24]
 80017de:	f033 03fe 	bics.w	r3, r3, #254	; 0xfe
 80017e2:	f040 80a4 	bne.w	800192e <HAL_I2C_Init+0x1b6>
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
 80017e6:	69e3      	ldr	r3, [r4, #28]
 80017e8:	b113      	cbz	r3, 80017f0 <HAL_I2C_Init+0x78>
 80017ea:	2b40      	cmp	r3, #64	; 0x40
 80017ec:	f040 80a5 	bne.w	800193a <HAL_I2C_Init+0x1c2>
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
 80017f0:	6a23      	ldr	r3, [r4, #32]
 80017f2:	b113      	cbz	r3, 80017fa <HAL_I2C_Init+0x82>
 80017f4:	2b80      	cmp	r3, #128	; 0x80
 80017f6:	f040 80a6 	bne.w	8001946 <HAL_I2C_Init+0x1ce>
  if (hi2c->State == HAL_I2C_STATE_RESET)
 80017fa:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
 80017fe:	2b00      	cmp	r3, #0
 8001800:	f000 80a7 	beq.w	8001952 <HAL_I2C_Init+0x1da>
  hi2c->State = HAL_I2C_STATE_BUSY;
 8001804:	2324      	movs	r3, #36	; 0x24
 8001806:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  __HAL_I2C_DISABLE(hi2c);
 800180a:	6822      	ldr	r2, [r4, #0]
 800180c:	6813      	ldr	r3, [r2, #0]
 800180e:	f023 0301 	bic.w	r3, r3, #1
 8001812:	6013      	str	r3, [r2, #0]
  hi2c->Instance->CR1 |= I2C_CR1_SWRST;
 8001814:	6822      	ldr	r2, [r4, #0]
 8001816:	6813      	ldr	r3, [r2, #0]
 8001818:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800181c:	6013      	str	r3, [r2, #0]
  hi2c->Instance->CR1 &= ~I2C_CR1_SWRST;
 800181e:	6822      	ldr	r2, [r4, #0]
 8001820:	6813      	ldr	r3, [r2, #0]
 8001822:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8001826:	6013      	str	r3, [r2, #0]
  pclk1 = HAL_RCC_GetPCLK1Freq();
 8001828:	f001 faea 	bl	8002e00 <HAL_RCC_GetPCLK1Freq>
  if (I2C_MIN_PCLK_FREQ(pclk1, hi2c->Init.ClockSpeed) == 1U)
 800182c:	6862      	ldr	r2, [r4, #4]
 800182e:	4b74      	ldr	r3, [pc, #464]	; (8001a00 <HAL_I2C_Init+0x288>)
 8001830:	429a      	cmp	r2, r3
 8001832:	f200 8094 	bhi.w	800195e <HAL_I2C_Init+0x1e6>
 8001836:	4b73      	ldr	r3, [pc, #460]	; (8001a04 <HAL_I2C_Init+0x28c>)
 8001838:	4298      	cmp	r0, r3
 800183a:	bf8c      	ite	hi
 800183c:	2300      	movhi	r3, #0
 800183e:	2301      	movls	r3, #1
 8001840:	2b00      	cmp	r3, #0
 8001842:	f040 80d5 	bne.w	80019f0 <HAL_I2C_Init+0x278>
  freqrange = I2C_FREQRANGE(pclk1);
 8001846:	4b70      	ldr	r3, [pc, #448]	; (8001a08 <HAL_I2C_Init+0x290>)
 8001848:	fba3 2300 	umull	r2, r3, r3, r0
 800184c:	0c9b      	lsrs	r3, r3, #18
  MODIFY_REG(hi2c->Instance->CR2, I2C_CR2_FREQ, freqrange);
 800184e:	6821      	ldr	r1, [r4, #0]
 8001850:	684a      	ldr	r2, [r1, #4]
 8001852:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
 8001856:	431a      	orrs	r2, r3
 8001858:	604a      	str	r2, [r1, #4]
  MODIFY_REG(hi2c->Instance->TRISE, I2C_TRISE_TRISE, I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed));
 800185a:	6825      	ldr	r5, [r4, #0]
 800185c:	6a2a      	ldr	r2, [r5, #32]
 800185e:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
 8001862:	6866      	ldr	r6, [r4, #4]
 8001864:	4966      	ldr	r1, [pc, #408]	; (8001a00 <HAL_I2C_Init+0x288>)
 8001866:	428e      	cmp	r6, r1
 8001868:	d87f      	bhi.n	800196a <HAL_I2C_Init+0x1f2>
 800186a:	3301      	adds	r3, #1
 800186c:	4313      	orrs	r3, r2
 800186e:	622b      	str	r3, [r5, #32]
  MODIFY_REG(hi2c->Instance->CCR, (I2C_CCR_FS | I2C_CCR_DUTY | I2C_CCR_CCR), I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle));
 8001870:	6825      	ldr	r5, [r4, #0]
 8001872:	69e9      	ldr	r1, [r5, #28]
 8001874:	f421 414f 	bic.w	r1, r1, #52992	; 0xcf00
 8001878:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
 800187c:	6863      	ldr	r3, [r4, #4]
 800187e:	4a60      	ldr	r2, [pc, #384]	; (8001a00 <HAL_I2C_Init+0x288>)
 8001880:	4293      	cmp	r3, r2
 8001882:	d87c      	bhi.n	800197e <HAL_I2C_Init+0x206>
 8001884:	3801      	subs	r0, #1
 8001886:	005b      	lsls	r3, r3, #1
 8001888:	fbb0 f3f3 	udiv	r3, r0, r3
 800188c:	3301      	adds	r3, #1
 800188e:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8001892:	2b04      	cmp	r3, #4
 8001894:	bf38      	it	cc
 8001896:	2304      	movcc	r3, #4
 8001898:	430b      	orrs	r3, r1
 800189a:	61eb      	str	r3, [r5, #28]
  MODIFY_REG(hi2c->Instance->CR1, (I2C_CR1_ENGC | I2C_CR1_NOSTRETCH), (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode));
 800189c:	6821      	ldr	r1, [r4, #0]
 800189e:	680b      	ldr	r3, [r1, #0]
 80018a0:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 80018a4:	69e2      	ldr	r2, [r4, #28]
 80018a6:	6a20      	ldr	r0, [r4, #32]
 80018a8:	4302      	orrs	r2, r0
 80018aa:	4313      	orrs	r3, r2
 80018ac:	600b      	str	r3, [r1, #0]
  MODIFY_REG(hi2c->Instance->OAR1, (I2C_OAR1_ADDMODE | I2C_OAR1_ADD8_9 | I2C_OAR1_ADD1_7 | I2C_OAR1_ADD0), (hi2c->Init.AddressingMode | hi2c->Init.OwnAddress1));
 80018ae:	6821      	ldr	r1, [r4, #0]
 80018b0:	688b      	ldr	r3, [r1, #8]
 80018b2:	f423 4303 	bic.w	r3, r3, #33536	; 0x8300
 80018b6:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 80018ba:	6922      	ldr	r2, [r4, #16]
 80018bc:	68e0      	ldr	r0, [r4, #12]
 80018be:	4302      	orrs	r2, r0
 80018c0:	4313      	orrs	r3, r2
 80018c2:	608b      	str	r3, [r1, #8]
  MODIFY_REG(hi2c->Instance->OAR2, (I2C_OAR2_ENDUAL | I2C_OAR2_ADD2), (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2));
 80018c4:	6821      	ldr	r1, [r4, #0]
 80018c6:	68cb      	ldr	r3, [r1, #12]
 80018c8:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 80018cc:	6962      	ldr	r2, [r4, #20]
 80018ce:	69a0      	ldr	r0, [r4, #24]
 80018d0:	4302      	orrs	r2, r0
 80018d2:	4313      	orrs	r3, r2
 80018d4:	60cb      	str	r3, [r1, #12]
  __HAL_I2C_ENABLE(hi2c);
 80018d6:	6822      	ldr	r2, [r4, #0]
 80018d8:	6813      	ldr	r3, [r2, #0]
 80018da:	f043 0301 	orr.w	r3, r3, #1
 80018de:	6013      	str	r3, [r2, #0]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80018e0:	2000      	movs	r0, #0
 80018e2:	6420      	str	r0, [r4, #64]	; 0x40
  hi2c->State = HAL_I2C_STATE_READY;
 80018e4:	2320      	movs	r3, #32
 80018e6:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  hi2c->PreviousState = I2C_STATE_NONE;
 80018ea:	6320      	str	r0, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 80018ec:	f884 003e 	strb.w	r0, [r4, #62]	; 0x3e
}
 80018f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_I2C_CLOCK_SPEED(hi2c->Init.ClockSpeed));
 80018f2:	f44f 71e9 	mov.w	r1, #466	; 0x1d2
 80018f6:	4840      	ldr	r0, [pc, #256]	; (80019f8 <HAL_I2C_Init+0x280>)
 80018f8:	f003 feee 	bl	80056d8 <assert_failed>
 80018fc:	e754      	b.n	80017a8 <HAL_I2C_Init+0x30>
  assert_param(IS_I2C_DUTY_CYCLE(hi2c->Init.DutyCycle));
 80018fe:	f240 11d3 	movw	r1, #467	; 0x1d3
 8001902:	483d      	ldr	r0, [pc, #244]	; (80019f8 <HAL_I2C_Init+0x280>)
 8001904:	f003 fee8 	bl	80056d8 <assert_failed>
 8001908:	e754      	b.n	80017b4 <HAL_I2C_Init+0x3c>
  assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
 800190a:	f44f 71ea 	mov.w	r1, #468	; 0x1d4
 800190e:	483a      	ldr	r0, [pc, #232]	; (80019f8 <HAL_I2C_Init+0x280>)
 8001910:	f003 fee2 	bl	80056d8 <assert_failed>
 8001914:	e756      	b.n	80017c4 <HAL_I2C_Init+0x4c>
  assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
 8001916:	f240 11d5 	movw	r1, #469	; 0x1d5
 800191a:	4837      	ldr	r0, [pc, #220]	; (80019f8 <HAL_I2C_Init+0x280>)
 800191c:	f003 fedc 	bl	80056d8 <assert_failed>
 8001920:	e758      	b.n	80017d4 <HAL_I2C_Init+0x5c>
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
 8001922:	f44f 71eb 	mov.w	r1, #470	; 0x1d6
 8001926:	4834      	ldr	r0, [pc, #208]	; (80019f8 <HAL_I2C_Init+0x280>)
 8001928:	f003 fed6 	bl	80056d8 <assert_failed>
 800192c:	e756      	b.n	80017dc <HAL_I2C_Init+0x64>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
 800192e:	f240 11d7 	movw	r1, #471	; 0x1d7
 8001932:	4831      	ldr	r0, [pc, #196]	; (80019f8 <HAL_I2C_Init+0x280>)
 8001934:	f003 fed0 	bl	80056d8 <assert_failed>
 8001938:	e755      	b.n	80017e6 <HAL_I2C_Init+0x6e>
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
 800193a:	f44f 71ec 	mov.w	r1, #472	; 0x1d8
 800193e:	482e      	ldr	r0, [pc, #184]	; (80019f8 <HAL_I2C_Init+0x280>)
 8001940:	f003 feca 	bl	80056d8 <assert_failed>
 8001944:	e754      	b.n	80017f0 <HAL_I2C_Init+0x78>
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
 8001946:	f240 11d9 	movw	r1, #473	; 0x1d9
 800194a:	482b      	ldr	r0, [pc, #172]	; (80019f8 <HAL_I2C_Init+0x280>)
 800194c:	f003 fec4 	bl	80056d8 <assert_failed>
 8001950:	e753      	b.n	80017fa <HAL_I2C_Init+0x82>
    hi2c->Lock = HAL_UNLOCKED;
 8001952:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
    HAL_I2C_MspInit(hi2c);
 8001956:	4620      	mov	r0, r4
 8001958:	f003 feea 	bl	8005730 <HAL_I2C_MspInit>
 800195c:	e752      	b.n	8001804 <HAL_I2C_Init+0x8c>
  if (I2C_MIN_PCLK_FREQ(pclk1, hi2c->Init.ClockSpeed) == 1U)
 800195e:	4b2b      	ldr	r3, [pc, #172]	; (8001a0c <HAL_I2C_Init+0x294>)
 8001960:	4298      	cmp	r0, r3
 8001962:	bf8c      	ite	hi
 8001964:	2300      	movhi	r3, #0
 8001966:	2301      	movls	r3, #1
 8001968:	e76a      	b.n	8001840 <HAL_I2C_Init+0xc8>
  MODIFY_REG(hi2c->Instance->TRISE, I2C_TRISE_TRISE, I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed));
 800196a:	f44f 7196 	mov.w	r1, #300	; 0x12c
 800196e:	fb01 f303 	mul.w	r3, r1, r3
 8001972:	4927      	ldr	r1, [pc, #156]	; (8001a10 <HAL_I2C_Init+0x298>)
 8001974:	fba1 1303 	umull	r1, r3, r1, r3
 8001978:	099b      	lsrs	r3, r3, #6
 800197a:	3301      	adds	r3, #1
 800197c:	e776      	b.n	800186c <HAL_I2C_Init+0xf4>
  MODIFY_REG(hi2c->Instance->CCR, (I2C_CCR_FS | I2C_CCR_DUTY | I2C_CCR_CCR), I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle));
 800197e:	68a2      	ldr	r2, [r4, #8]
 8001980:	b9ba      	cbnz	r2, 80019b2 <HAL_I2C_Init+0x23a>
 8001982:	1e46      	subs	r6, r0, #1
 8001984:	eb03 0743 	add.w	r7, r3, r3, lsl #1
 8001988:	fbb6 f6f7 	udiv	r6, r6, r7
 800198c:	3601      	adds	r6, #1
 800198e:	f3c6 060b 	ubfx	r6, r6, #0, #12
 8001992:	fab6 f686 	clz	r6, r6
 8001996:	0976      	lsrs	r6, r6, #5
 8001998:	bb36      	cbnz	r6, 80019e8 <HAL_I2C_Init+0x270>
 800199a:	b9c2      	cbnz	r2, 80019ce <HAL_I2C_Init+0x256>
 800199c:	3801      	subs	r0, #1
 800199e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80019a2:	fbb0 f3f3 	udiv	r3, r0, r3
 80019a6:	3301      	adds	r3, #1
 80019a8:	f3c3 020b 	ubfx	r2, r3, #0, #12
 80019ac:	f442 4300 	orr.w	r3, r2, #32768	; 0x8000
 80019b0:	e772      	b.n	8001898 <HAL_I2C_Init+0x120>
 80019b2:	1e46      	subs	r6, r0, #1
 80019b4:	eb03 0783 	add.w	r7, r3, r3, lsl #2
 80019b8:	eb07 0787 	add.w	r7, r7, r7, lsl #2
 80019bc:	fbb6 f6f7 	udiv	r6, r6, r7
 80019c0:	3601      	adds	r6, #1
 80019c2:	f3c6 060b 	ubfx	r6, r6, #0, #12
 80019c6:	fab6 f686 	clz	r6, r6
 80019ca:	0976      	lsrs	r6, r6, #5
 80019cc:	e7e4      	b.n	8001998 <HAL_I2C_Init+0x220>
 80019ce:	3801      	subs	r0, #1
 80019d0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80019d4:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80019d8:	fbb0 f2f3 	udiv	r2, r0, r3
 80019dc:	3201      	adds	r2, #1
 80019de:	f3c2 020b 	ubfx	r2, r2, #0, #12
 80019e2:	f442 4340 	orr.w	r3, r2, #49152	; 0xc000
 80019e6:	e757      	b.n	8001898 <HAL_I2C_Init+0x120>
 80019e8:	2301      	movs	r3, #1
 80019ea:	e755      	b.n	8001898 <HAL_I2C_Init+0x120>
    return HAL_ERROR;
 80019ec:	2001      	movs	r0, #1
}
 80019ee:	4770      	bx	lr
    return HAL_ERROR;
 80019f0:	2001      	movs	r0, #1
 80019f2:	e77d      	b.n	80018f0 <HAL_I2C_Init+0x178>
 80019f4:	40005400 	.word	0x40005400
 80019f8:	08005ddc 	.word	0x08005ddc
 80019fc:	00061a7f 	.word	0x00061a7f
 8001a00:	000186a0 	.word	0x000186a0
 8001a04:	001e847f 	.word	0x001e847f
 8001a08:	431bde83 	.word	0x431bde83
 8001a0c:	003d08ff 	.word	0x003d08ff
 8001a10:	10624dd3 	.word	0x10624dd3

08001a14 <HAL_I2C_MasterTxCpltCallback>:
}
 8001a14:	4770      	bx	lr

08001a16 <I2C_MasterTransmit_BTF>:
{
 8001a16:	b508      	push	{r3, lr}
  uint32_t CurrentXferOptions = hi2c->XferOptions;
 8001a18:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
 8001a1a:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8001a1e:	b2db      	uxtb	r3, r3
 8001a20:	2b21      	cmp	r3, #33	; 0x21
 8001a22:	d000      	beq.n	8001a26 <I2C_MasterTransmit_BTF+0x10>
}
 8001a24:	bd08      	pop	{r3, pc}
    if (hi2c->XferCount != 0U)
 8001a26:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8001a28:	b29b      	uxth	r3, r3
 8001a2a:	b9d3      	cbnz	r3, 8001a62 <I2C_MasterTransmit_BTF+0x4c>
      if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
 8001a2c:	2a08      	cmp	r2, #8
 8001a2e:	d004      	beq.n	8001a3a <I2C_MasterTransmit_BTF+0x24>
 8001a30:	2a20      	cmp	r2, #32
 8001a32:	d002      	beq.n	8001a3a <I2C_MasterTransmit_BTF+0x24>
 8001a34:	f512 3f80 	cmn.w	r2, #65536	; 0x10000
 8001a38:	d11f      	bne.n	8001a7a <I2C_MasterTransmit_BTF+0x64>
        __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8001a3a:	6802      	ldr	r2, [r0, #0]
 8001a3c:	6853      	ldr	r3, [r2, #4]
 8001a3e:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8001a42:	6053      	str	r3, [r2, #4]
        SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8001a44:	6802      	ldr	r2, [r0, #0]
 8001a46:	6813      	ldr	r3, [r2, #0]
 8001a48:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8001a4c:	6013      	str	r3, [r2, #0]
        hi2c->PreviousState = I2C_STATE_NONE;
 8001a4e:	2300      	movs	r3, #0
 8001a50:	6303      	str	r3, [r0, #48]	; 0x30
        hi2c->State = HAL_I2C_STATE_READY;
 8001a52:	2220      	movs	r2, #32
 8001a54:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8001a58:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
        HAL_I2C_MasterTxCpltCallback(hi2c);
 8001a5c:	f7ff ffda 	bl	8001a14 <HAL_I2C_MasterTxCpltCallback>
}
 8001a60:	e7e0      	b.n	8001a24 <I2C_MasterTransmit_BTF+0xe>
      hi2c->Instance->DR = *hi2c->pBuffPtr;
 8001a62:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8001a64:	6803      	ldr	r3, [r0, #0]
 8001a66:	7812      	ldrb	r2, [r2, #0]
 8001a68:	611a      	str	r2, [r3, #16]
      hi2c->pBuffPtr++;
 8001a6a:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8001a6c:	3301      	adds	r3, #1
 8001a6e:	6243      	str	r3, [r0, #36]	; 0x24
      hi2c->XferCount--;
 8001a70:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8001a72:	3b01      	subs	r3, #1
 8001a74:	b29b      	uxth	r3, r3
 8001a76:	8543      	strh	r3, [r0, #42]	; 0x2a
 8001a78:	e7d4      	b.n	8001a24 <I2C_MasterTransmit_BTF+0xe>
        __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8001a7a:	6802      	ldr	r2, [r0, #0]
 8001a7c:	6853      	ldr	r3, [r2, #4]
 8001a7e:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8001a82:	6053      	str	r3, [r2, #4]
        hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
 8001a84:	2311      	movs	r3, #17
 8001a86:	6303      	str	r3, [r0, #48]	; 0x30
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8001a88:	2300      	movs	r3, #0
 8001a8a:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
        hi2c->State = HAL_I2C_STATE_READY;
 8001a8e:	2320      	movs	r3, #32
 8001a90:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
        HAL_I2C_MasterTxCpltCallback(hi2c);
 8001a94:	f7ff ffbe 	bl	8001a14 <HAL_I2C_MasterTxCpltCallback>
 8001a98:	e7c4      	b.n	8001a24 <I2C_MasterTransmit_BTF+0xe>

08001a9a <HAL_I2C_MasterRxCpltCallback>:
}
 8001a9a:	4770      	bx	lr

08001a9c <HAL_I2C_SlaveTxCpltCallback>:
}
 8001a9c:	4770      	bx	lr

08001a9e <I2C_SlaveTransmit_TXE>:
{
 8001a9e:	b508      	push	{r3, lr}
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 8001aa0:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8001aa4:	b2da      	uxtb	r2, r3
  if (hi2c->XferCount != 0U)
 8001aa6:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8001aa8:	b29b      	uxth	r3, r3
 8001aaa:	b17b      	cbz	r3, 8001acc <I2C_SlaveTransmit_TXE+0x2e>
    hi2c->Instance->DR = *hi2c->pBuffPtr;
 8001aac:	6a41      	ldr	r1, [r0, #36]	; 0x24
 8001aae:	6803      	ldr	r3, [r0, #0]
 8001ab0:	7809      	ldrb	r1, [r1, #0]
 8001ab2:	6119      	str	r1, [r3, #16]
    hi2c->pBuffPtr++;
 8001ab4:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8001ab6:	3301      	adds	r3, #1
 8001ab8:	6243      	str	r3, [r0, #36]	; 0x24
    hi2c->XferCount--;
 8001aba:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8001abc:	3b01      	subs	r3, #1
 8001abe:	b29b      	uxth	r3, r3
 8001ac0:	8543      	strh	r3, [r0, #42]	; 0x2a
    if ((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN))
 8001ac2:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8001ac4:	b29b      	uxth	r3, r3
 8001ac6:	b90b      	cbnz	r3, 8001acc <I2C_SlaveTransmit_TXE+0x2e>
 8001ac8:	2a29      	cmp	r2, #41	; 0x29
 8001aca:	d000      	beq.n	8001ace <I2C_SlaveTransmit_TXE+0x30>
}
 8001acc:	bd08      	pop	{r3, pc}
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 8001ace:	6802      	ldr	r2, [r0, #0]
 8001ad0:	6853      	ldr	r3, [r2, #4]
 8001ad2:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8001ad6:	6053      	str	r3, [r2, #4]
      hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
 8001ad8:	2321      	movs	r3, #33	; 0x21
 8001ada:	6303      	str	r3, [r0, #48]	; 0x30
      hi2c->State = HAL_I2C_STATE_LISTEN;
 8001adc:	2328      	movs	r3, #40	; 0x28
 8001ade:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
      HAL_I2C_SlaveTxCpltCallback(hi2c);
 8001ae2:	f7ff ffdb 	bl	8001a9c <HAL_I2C_SlaveTxCpltCallback>
}
 8001ae6:	e7f1      	b.n	8001acc <I2C_SlaveTransmit_TXE+0x2e>

08001ae8 <HAL_I2C_SlaveRxCpltCallback>:
}
 8001ae8:	4770      	bx	lr

08001aea <I2C_SlaveReceive_RXNE>:
{
 8001aea:	b508      	push	{r3, lr}
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 8001aec:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8001af0:	b2da      	uxtb	r2, r3
  if (hi2c->XferCount != 0U)
 8001af2:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8001af4:	b29b      	uxth	r3, r3
 8001af6:	b17b      	cbz	r3, 8001b18 <I2C_SlaveReceive_RXNE+0x2e>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8001af8:	6803      	ldr	r3, [r0, #0]
 8001afa:	6919      	ldr	r1, [r3, #16]
 8001afc:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8001afe:	7019      	strb	r1, [r3, #0]
    hi2c->pBuffPtr++;
 8001b00:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8001b02:	3301      	adds	r3, #1
 8001b04:	6243      	str	r3, [r0, #36]	; 0x24
    hi2c->XferCount--;
 8001b06:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8001b08:	3b01      	subs	r3, #1
 8001b0a:	b29b      	uxth	r3, r3
 8001b0c:	8543      	strh	r3, [r0, #42]	; 0x2a
    if ((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN))
 8001b0e:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8001b10:	b29b      	uxth	r3, r3
 8001b12:	b90b      	cbnz	r3, 8001b18 <I2C_SlaveReceive_RXNE+0x2e>
 8001b14:	2a2a      	cmp	r2, #42	; 0x2a
 8001b16:	d000      	beq.n	8001b1a <I2C_SlaveReceive_RXNE+0x30>
}
 8001b18:	bd08      	pop	{r3, pc}
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 8001b1a:	6802      	ldr	r2, [r0, #0]
 8001b1c:	6853      	ldr	r3, [r2, #4]
 8001b1e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8001b22:	6053      	str	r3, [r2, #4]
      hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
 8001b24:	2322      	movs	r3, #34	; 0x22
 8001b26:	6303      	str	r3, [r0, #48]	; 0x30
      hi2c->State = HAL_I2C_STATE_LISTEN;
 8001b28:	2328      	movs	r3, #40	; 0x28
 8001b2a:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
      HAL_I2C_SlaveRxCpltCallback(hi2c);
 8001b2e:	f7ff ffdb 	bl	8001ae8 <HAL_I2C_SlaveRxCpltCallback>
}
 8001b32:	e7f1      	b.n	8001b18 <I2C_SlaveReceive_RXNE+0x2e>

08001b34 <HAL_I2C_AddrCallback>:
}
 8001b34:	4770      	bx	lr

08001b36 <I2C_Slave_ADDR>:
{
 8001b36:	b508      	push	{r3, lr}
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
 8001b38:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8001b3c:	f003 0328 	and.w	r3, r3, #40	; 0x28
 8001b40:	2b28      	cmp	r3, #40	; 0x28
 8001b42:	d007      	beq.n	8001b54 <I2C_Slave_ADDR+0x1e>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
 8001b44:	6803      	ldr	r3, [r0, #0]
 8001b46:	f06f 0202 	mvn.w	r2, #2
 8001b4a:	615a      	str	r2, [r3, #20]
    __HAL_UNLOCK(hi2c);
 8001b4c:	2300      	movs	r3, #0
 8001b4e:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
}
 8001b52:	bd08      	pop	{r3, pc}
    __HAL_I2C_DISABLE_IT(hi2c, (I2C_IT_BUF));
 8001b54:	6802      	ldr	r2, [r0, #0]
 8001b56:	6853      	ldr	r3, [r2, #4]
 8001b58:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8001b5c:	6053      	str	r3, [r2, #4]
    if (I2C_CHECK_FLAG(IT2Flags, I2C_FLAG_TRA) == RESET)
 8001b5e:	f011 0f04 	tst.w	r1, #4
 8001b62:	d00b      	beq.n	8001b7c <I2C_Slave_ADDR+0x46>
  uint8_t TransferDirection = I2C_DIRECTION_RECEIVE;
 8001b64:	2300      	movs	r3, #0
    if (I2C_CHECK_FLAG(IT2Flags, I2C_FLAG_DUALF) == RESET)
 8001b66:	f011 0f80 	tst.w	r1, #128	; 0x80
 8001b6a:	d109      	bne.n	8001b80 <I2C_Slave_ADDR+0x4a>
      SlaveAddrCode = (uint16_t)hi2c->Init.OwnAddress1;
 8001b6c:	8982      	ldrh	r2, [r0, #12]
    __HAL_UNLOCK(hi2c);
 8001b6e:	2100      	movs	r1, #0
 8001b70:	f880 103c 	strb.w	r1, [r0, #60]	; 0x3c
    HAL_I2C_AddrCallback(hi2c, TransferDirection, SlaveAddrCode);
 8001b74:	4619      	mov	r1, r3
 8001b76:	f7ff ffdd 	bl	8001b34 <HAL_I2C_AddrCallback>
 8001b7a:	e7ea      	b.n	8001b52 <I2C_Slave_ADDR+0x1c>
      TransferDirection = I2C_DIRECTION_TRANSMIT;
 8001b7c:	2301      	movs	r3, #1
 8001b7e:	e7f2      	b.n	8001b66 <I2C_Slave_ADDR+0x30>
      SlaveAddrCode = (uint16_t)hi2c->Init.OwnAddress2;
 8001b80:	8b02      	ldrh	r2, [r0, #24]
 8001b82:	e7f4      	b.n	8001b6e <I2C_Slave_ADDR+0x38>

08001b84 <HAL_I2C_ListenCpltCallback>:
}
 8001b84:	4770      	bx	lr
	...

08001b88 <I2C_Slave_AF>:
{
 8001b88:	b508      	push	{r3, lr}
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 8001b8a:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8001b8e:	b2db      	uxtb	r3, r3
  uint32_t CurrentXferOptions       = hi2c->XferOptions;
 8001b90:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  if (((CurrentXferOptions ==  I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME)) && \
 8001b92:	2a08      	cmp	r2, #8
 8001b94:	d001      	beq.n	8001b9a <I2C_Slave_AF+0x12>
 8001b96:	2a20      	cmp	r2, #32
 8001b98:	d101      	bne.n	8001b9e <I2C_Slave_AF+0x16>
 8001b9a:	2b28      	cmp	r3, #40	; 0x28
 8001b9c:	d006      	beq.n	8001bac <I2C_Slave_AF+0x24>
  else if (CurrentState == HAL_I2C_STATE_BUSY_TX)
 8001b9e:	2b21      	cmp	r3, #33	; 0x21
 8001ba0:	d01e      	beq.n	8001be0 <I2C_Slave_AF+0x58>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8001ba2:	6803      	ldr	r3, [r0, #0]
 8001ba4:	f46f 6280 	mvn.w	r2, #1024	; 0x400
 8001ba8:	615a      	str	r2, [r3, #20]
}
 8001baa:	bd08      	pop	{r3, pc}
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8001bac:	4b1a      	ldr	r3, [pc, #104]	; (8001c18 <I2C_Slave_AF+0x90>)
 8001bae:	62c3      	str	r3, [r0, #44]	; 0x2c
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8001bb0:	6802      	ldr	r2, [r0, #0]
 8001bb2:	6853      	ldr	r3, [r2, #4]
 8001bb4:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8001bb8:	6053      	str	r3, [r2, #4]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8001bba:	6803      	ldr	r3, [r0, #0]
 8001bbc:	f46f 6280 	mvn.w	r2, #1024	; 0x400
 8001bc0:	615a      	str	r2, [r3, #20]
    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8001bc2:	6802      	ldr	r2, [r0, #0]
 8001bc4:	6813      	ldr	r3, [r2, #0]
 8001bc6:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8001bca:	6013      	str	r3, [r2, #0]
    hi2c->PreviousState = I2C_STATE_NONE;
 8001bcc:	2300      	movs	r3, #0
 8001bce:	6303      	str	r3, [r0, #48]	; 0x30
    hi2c->State         = HAL_I2C_STATE_READY;
 8001bd0:	2220      	movs	r2, #32
 8001bd2:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d
    hi2c->Mode          = HAL_I2C_MODE_NONE;
 8001bd6:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
    HAL_I2C_ListenCpltCallback(hi2c);
 8001bda:	f7ff ffd3 	bl	8001b84 <HAL_I2C_ListenCpltCallback>
 8001bde:	e7e4      	b.n	8001baa <I2C_Slave_AF+0x22>
    hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 8001be0:	4b0d      	ldr	r3, [pc, #52]	; (8001c18 <I2C_Slave_AF+0x90>)
 8001be2:	62c3      	str	r3, [r0, #44]	; 0x2c
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
 8001be4:	2321      	movs	r3, #33	; 0x21
 8001be6:	6303      	str	r3, [r0, #48]	; 0x30
    hi2c->State         = HAL_I2C_STATE_READY;
 8001be8:	2320      	movs	r3, #32
 8001bea:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
    hi2c->Mode          = HAL_I2C_MODE_NONE;
 8001bee:	2300      	movs	r3, #0
 8001bf0:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8001bf4:	6802      	ldr	r2, [r0, #0]
 8001bf6:	6853      	ldr	r3, [r2, #4]
 8001bf8:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8001bfc:	6053      	str	r3, [r2, #4]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8001bfe:	6803      	ldr	r3, [r0, #0]
 8001c00:	f46f 6280 	mvn.w	r2, #1024	; 0x400
 8001c04:	615a      	str	r2, [r3, #20]
    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8001c06:	6802      	ldr	r2, [r0, #0]
 8001c08:	6813      	ldr	r3, [r2, #0]
 8001c0a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8001c0e:	6013      	str	r3, [r2, #0]
    HAL_I2C_SlaveTxCpltCallback(hi2c);
 8001c10:	f7ff ff44 	bl	8001a9c <HAL_I2C_SlaveTxCpltCallback>
 8001c14:	e7c9      	b.n	8001baa <I2C_Slave_AF+0x22>
 8001c16:	bf00      	nop
 8001c18:	ffff0000 	.word	0xffff0000

08001c1c <HAL_I2C_MemTxCpltCallback>:
}
 8001c1c:	4770      	bx	lr

08001c1e <I2C_MemoryTransmit_TXE_BTF>:
{
 8001c1e:	b508      	push	{r3, lr}
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 8001c20:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
  if (hi2c->EventCount == 0U)
 8001c24:	6d02      	ldr	r2, [r0, #80]	; 0x50
 8001c26:	b99a      	cbnz	r2, 8001c50 <I2C_MemoryTransmit_TXE_BTF+0x32>
    if (hi2c->MemaddSize == I2C_MEMADD_SIZE_8BIT)
 8001c28:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8001c2a:	2b01      	cmp	r3, #1
 8001c2c:	d008      	beq.n	8001c40 <I2C_MemoryTransmit_TXE_BTF+0x22>
      hi2c->Instance->DR = I2C_MEM_ADD_MSB(hi2c->Memaddress);
 8001c2e:	6c83      	ldr	r3, [r0, #72]	; 0x48
 8001c30:	f3c3 2307 	ubfx	r3, r3, #8, #8
 8001c34:	6802      	ldr	r2, [r0, #0]
 8001c36:	6113      	str	r3, [r2, #16]
      hi2c->EventCount++;
 8001c38:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8001c3a:	3301      	adds	r3, #1
 8001c3c:	6503      	str	r3, [r0, #80]	; 0x50
}
 8001c3e:	bd08      	pop	{r3, pc}
      hi2c->Instance->DR = I2C_MEM_ADD_LSB(hi2c->Memaddress);
 8001c40:	6c83      	ldr	r3, [r0, #72]	; 0x48
 8001c42:	6802      	ldr	r2, [r0, #0]
 8001c44:	b2db      	uxtb	r3, r3
 8001c46:	6113      	str	r3, [r2, #16]
      hi2c->EventCount += 2U;
 8001c48:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8001c4a:	3302      	adds	r3, #2
 8001c4c:	6503      	str	r3, [r0, #80]	; 0x50
 8001c4e:	e7f6      	b.n	8001c3e <I2C_MemoryTransmit_TXE_BTF+0x20>
 8001c50:	b2db      	uxtb	r3, r3
  else if (hi2c->EventCount == 1U)
 8001c52:	6d02      	ldr	r2, [r0, #80]	; 0x50
 8001c54:	2a01      	cmp	r2, #1
 8001c56:	d023      	beq.n	8001ca0 <I2C_MemoryTransmit_TXE_BTF+0x82>
  else if (hi2c->EventCount == 2U)
 8001c58:	6d02      	ldr	r2, [r0, #80]	; 0x50
 8001c5a:	2a02      	cmp	r2, #2
 8001c5c:	d1ef      	bne.n	8001c3e <I2C_MemoryTransmit_TXE_BTF+0x20>
    if (CurrentState == HAL_I2C_STATE_BUSY_RX)
 8001c5e:	2b22      	cmp	r3, #34	; 0x22
 8001c60:	d026      	beq.n	8001cb0 <I2C_MemoryTransmit_TXE_BTF+0x92>
    else if ((hi2c->XferCount > 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX))
 8001c62:	8d42      	ldrh	r2, [r0, #42]	; 0x2a
 8001c64:	b292      	uxth	r2, r2
 8001c66:	b10a      	cbz	r2, 8001c6c <I2C_MemoryTransmit_TXE_BTF+0x4e>
 8001c68:	2b21      	cmp	r3, #33	; 0x21
 8001c6a:	d027      	beq.n	8001cbc <I2C_MemoryTransmit_TXE_BTF+0x9e>
    else if ((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX))
 8001c6c:	8d42      	ldrh	r2, [r0, #42]	; 0x2a
 8001c6e:	b292      	uxth	r2, r2
 8001c70:	2a00      	cmp	r2, #0
 8001c72:	d1e4      	bne.n	8001c3e <I2C_MemoryTransmit_TXE_BTF+0x20>
 8001c74:	2b21      	cmp	r3, #33	; 0x21
 8001c76:	d1e2      	bne.n	8001c3e <I2C_MemoryTransmit_TXE_BTF+0x20>
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8001c78:	6802      	ldr	r2, [r0, #0]
 8001c7a:	6853      	ldr	r3, [r2, #4]
 8001c7c:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8001c80:	6053      	str	r3, [r2, #4]
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8001c82:	6802      	ldr	r2, [r0, #0]
 8001c84:	6813      	ldr	r3, [r2, #0]
 8001c86:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8001c8a:	6013      	str	r3, [r2, #0]
      hi2c->PreviousState = I2C_STATE_NONE;
 8001c8c:	2300      	movs	r3, #0
 8001c8e:	6303      	str	r3, [r0, #48]	; 0x30
      hi2c->State = HAL_I2C_STATE_READY;
 8001c90:	2220      	movs	r2, #32
 8001c92:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d
      hi2c->Mode = HAL_I2C_MODE_NONE;
 8001c96:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
      HAL_I2C_MemTxCpltCallback(hi2c);
 8001c9a:	f7ff ffbf 	bl	8001c1c <HAL_I2C_MemTxCpltCallback>
}
 8001c9e:	e7ce      	b.n	8001c3e <I2C_MemoryTransmit_TXE_BTF+0x20>
    hi2c->Instance->DR = I2C_MEM_ADD_LSB(hi2c->Memaddress);
 8001ca0:	6c83      	ldr	r3, [r0, #72]	; 0x48
 8001ca2:	6802      	ldr	r2, [r0, #0]
 8001ca4:	b2db      	uxtb	r3, r3
 8001ca6:	6113      	str	r3, [r2, #16]
    hi2c->EventCount++;
 8001ca8:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8001caa:	3301      	adds	r3, #1
 8001cac:	6503      	str	r3, [r0, #80]	; 0x50
 8001cae:	e7c6      	b.n	8001c3e <I2C_MemoryTransmit_TXE_BTF+0x20>
      hi2c->Instance->CR1 |= I2C_CR1_START;
 8001cb0:	6802      	ldr	r2, [r0, #0]
 8001cb2:	6813      	ldr	r3, [r2, #0]
 8001cb4:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001cb8:	6013      	str	r3, [r2, #0]
 8001cba:	e7c0      	b.n	8001c3e <I2C_MemoryTransmit_TXE_BTF+0x20>
      hi2c->Instance->DR = *hi2c->pBuffPtr;
 8001cbc:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8001cbe:	6803      	ldr	r3, [r0, #0]
 8001cc0:	7812      	ldrb	r2, [r2, #0]
 8001cc2:	611a      	str	r2, [r3, #16]
      hi2c->pBuffPtr++;
 8001cc4:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8001cc6:	3301      	adds	r3, #1
 8001cc8:	6243      	str	r3, [r0, #36]	; 0x24
      hi2c->XferCount--;
 8001cca:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8001ccc:	3b01      	subs	r3, #1
 8001cce:	b29b      	uxth	r3, r3
 8001cd0:	8543      	strh	r3, [r0, #42]	; 0x2a
 8001cd2:	e7b4      	b.n	8001c3e <I2C_MemoryTransmit_TXE_BTF+0x20>

08001cd4 <I2C_MasterTransmit_TXE>:
{
 8001cd4:	b510      	push	{r4, lr}
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 8001cd6:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8001cda:	b2db      	uxtb	r3, r3
  HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
 8001cdc:	f890 203e 	ldrb.w	r2, [r0, #62]	; 0x3e
 8001ce0:	b2d2      	uxtb	r2, r2
  uint32_t CurrentXferOptions       = hi2c->XferOptions;
 8001ce2:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
  if ((hi2c->XferSize == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX))
 8001ce4:	8d01      	ldrh	r1, [r0, #40]	; 0x28
 8001ce6:	b909      	cbnz	r1, 8001cec <I2C_MasterTransmit_TXE+0x18>
 8001ce8:	2b21      	cmp	r3, #33	; 0x21
 8001cea:	d004      	beq.n	8001cf6 <I2C_MasterTransmit_TXE+0x22>
  else if ((CurrentState == HAL_I2C_STATE_BUSY_TX) || \
 8001cec:	2b21      	cmp	r3, #33	; 0x21
 8001cee:	d03b      	beq.n	8001d68 <I2C_MasterTransmit_TXE+0x94>
 8001cf0:	2a40      	cmp	r2, #64	; 0x40
 8001cf2:	d037      	beq.n	8001d64 <I2C_MasterTransmit_TXE+0x90>
}
 8001cf4:	bd10      	pop	{r4, pc}
    if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
 8001cf6:	2c08      	cmp	r4, #8
 8001cf8:	d004      	beq.n	8001d04 <I2C_MasterTransmit_TXE+0x30>
 8001cfa:	2c20      	cmp	r4, #32
 8001cfc:	d002      	beq.n	8001d04 <I2C_MasterTransmit_TXE+0x30>
 8001cfe:	f514 3f80 	cmn.w	r4, #65536	; 0x10000
 8001d02:	d119      	bne.n	8001d38 <I2C_MasterTransmit_TXE+0x64>
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8001d04:	6802      	ldr	r2, [r0, #0]
 8001d06:	6853      	ldr	r3, [r2, #4]
 8001d08:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8001d0c:	6053      	str	r3, [r2, #4]
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8001d0e:	6802      	ldr	r2, [r0, #0]
 8001d10:	6813      	ldr	r3, [r2, #0]
 8001d12:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8001d16:	6013      	str	r3, [r2, #0]
      hi2c->PreviousState = I2C_STATE_NONE;
 8001d18:	2300      	movs	r3, #0
 8001d1a:	6303      	str	r3, [r0, #48]	; 0x30
      hi2c->State = HAL_I2C_STATE_READY;
 8001d1c:	2320      	movs	r3, #32
 8001d1e:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
      if (hi2c->Mode == HAL_I2C_MODE_MEM)
 8001d22:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
 8001d26:	b2db      	uxtb	r3, r3
 8001d28:	2b40      	cmp	r3, #64	; 0x40
 8001d2a:	d015      	beq.n	8001d58 <I2C_MasterTransmit_TXE+0x84>
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8001d2c:	2300      	movs	r3, #0
 8001d2e:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
        HAL_I2C_MasterTxCpltCallback(hi2c);
 8001d32:	f7ff fe6f 	bl	8001a14 <HAL_I2C_MasterTxCpltCallback>
 8001d36:	e7dd      	b.n	8001cf4 <I2C_MasterTransmit_TXE+0x20>
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8001d38:	6802      	ldr	r2, [r0, #0]
 8001d3a:	6853      	ldr	r3, [r2, #4]
 8001d3c:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8001d40:	6053      	str	r3, [r2, #4]
      hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
 8001d42:	2311      	movs	r3, #17
 8001d44:	6303      	str	r3, [r0, #48]	; 0x30
      hi2c->Mode = HAL_I2C_MODE_NONE;
 8001d46:	2300      	movs	r3, #0
 8001d48:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
      hi2c->State = HAL_I2C_STATE_READY;
 8001d4c:	2320      	movs	r3, #32
 8001d4e:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
      HAL_I2C_MasterTxCpltCallback(hi2c);
 8001d52:	f7ff fe5f 	bl	8001a14 <HAL_I2C_MasterTxCpltCallback>
 8001d56:	e7cd      	b.n	8001cf4 <I2C_MasterTransmit_TXE+0x20>
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8001d58:	2300      	movs	r3, #0
 8001d5a:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
        HAL_I2C_MemTxCpltCallback(hi2c);
 8001d5e:	f7ff ff5d 	bl	8001c1c <HAL_I2C_MemTxCpltCallback>
 8001d62:	e7c7      	b.n	8001cf4 <I2C_MasterTransmit_TXE+0x20>
           ((CurrentMode == HAL_I2C_MODE_MEM) && (CurrentState == HAL_I2C_STATE_BUSY_RX)))
 8001d64:	2b22      	cmp	r3, #34	; 0x22
 8001d66:	d1c5      	bne.n	8001cf4 <I2C_MasterTransmit_TXE+0x20>
    if (hi2c->XferCount == 0U)
 8001d68:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8001d6a:	b29b      	uxth	r3, r3
 8001d6c:	b183      	cbz	r3, 8001d90 <I2C_MasterTransmit_TXE+0xbc>
      if (hi2c->Mode == HAL_I2C_MODE_MEM)
 8001d6e:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
 8001d72:	b2db      	uxtb	r3, r3
 8001d74:	2b40      	cmp	r3, #64	; 0x40
 8001d76:	d011      	beq.n	8001d9c <I2C_MasterTransmit_TXE+0xc8>
        hi2c->Instance->DR = *hi2c->pBuffPtr;
 8001d78:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8001d7a:	6803      	ldr	r3, [r0, #0]
 8001d7c:	7812      	ldrb	r2, [r2, #0]
 8001d7e:	611a      	str	r2, [r3, #16]
        hi2c->pBuffPtr++;
 8001d80:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8001d82:	3301      	adds	r3, #1
 8001d84:	6243      	str	r3, [r0, #36]	; 0x24
        hi2c->XferCount--;
 8001d86:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8001d88:	3b01      	subs	r3, #1
 8001d8a:	b29b      	uxth	r3, r3
 8001d8c:	8543      	strh	r3, [r0, #42]	; 0x2a
}
 8001d8e:	e7b1      	b.n	8001cf4 <I2C_MasterTransmit_TXE+0x20>
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 8001d90:	6802      	ldr	r2, [r0, #0]
 8001d92:	6853      	ldr	r3, [r2, #4]
 8001d94:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8001d98:	6053      	str	r3, [r2, #4]
 8001d9a:	e7ab      	b.n	8001cf4 <I2C_MasterTransmit_TXE+0x20>
        I2C_MemoryTransmit_TXE_BTF(hi2c);
 8001d9c:	f7ff ff3f 	bl	8001c1e <I2C_MemoryTransmit_TXE_BTF>
 8001da0:	e7a8      	b.n	8001cf4 <I2C_MasterTransmit_TXE+0x20>

08001da2 <HAL_I2C_MemRxCpltCallback>:
}
 8001da2:	4770      	bx	lr

08001da4 <I2C_MasterReceive_BTF>:
{
 8001da4:	b508      	push	{r3, lr}
  uint32_t CurrentXferOptions = hi2c->XferOptions;
 8001da6:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  if (hi2c->XferCount == 4U)
 8001da8:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8001daa:	b29b      	uxth	r3, r3
 8001dac:	2b04      	cmp	r3, #4
 8001dae:	d013      	beq.n	8001dd8 <I2C_MasterReceive_BTF+0x34>
  else if (hi2c->XferCount == 3U)
 8001db0:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8001db2:	b29b      	uxth	r3, r3
 8001db4:	2b03      	cmp	r3, #3
 8001db6:	d020      	beq.n	8001dfa <I2C_MasterReceive_BTF+0x56>
  else if (hi2c->XferCount == 2U)
 8001db8:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8001dba:	b29b      	uxth	r3, r3
 8001dbc:	2b02      	cmp	r3, #2
 8001dbe:	d036      	beq.n	8001e2e <I2C_MasterReceive_BTF+0x8a>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8001dc0:	6803      	ldr	r3, [r0, #0]
 8001dc2:	691a      	ldr	r2, [r3, #16]
 8001dc4:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8001dc6:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
 8001dc8:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8001dca:	3301      	adds	r3, #1
 8001dcc:	6243      	str	r3, [r0, #36]	; 0x24
    hi2c->XferCount--;
 8001dce:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8001dd0:	3b01      	subs	r3, #1
 8001dd2:	b29b      	uxth	r3, r3
 8001dd4:	8543      	strh	r3, [r0, #42]	; 0x2a
}
 8001dd6:	e00f      	b.n	8001df8 <I2C_MasterReceive_BTF+0x54>
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 8001dd8:	6802      	ldr	r2, [r0, #0]
 8001dda:	6853      	ldr	r3, [r2, #4]
 8001ddc:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8001de0:	6053      	str	r3, [r2, #4]
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8001de2:	6803      	ldr	r3, [r0, #0]
 8001de4:	691a      	ldr	r2, [r3, #16]
 8001de6:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8001de8:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
 8001dea:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8001dec:	3301      	adds	r3, #1
 8001dee:	6243      	str	r3, [r0, #36]	; 0x24
    hi2c->XferCount--;
 8001df0:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8001df2:	3b01      	subs	r3, #1
 8001df4:	b29b      	uxth	r3, r3
 8001df6:	8543      	strh	r3, [r0, #42]	; 0x2a
}
 8001df8:	bd08      	pop	{r3, pc}
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 8001dfa:	6801      	ldr	r1, [r0, #0]
 8001dfc:	684b      	ldr	r3, [r1, #4]
 8001dfe:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8001e02:	604b      	str	r3, [r1, #4]
    if ((CurrentXferOptions != I2C_NEXT_FRAME) && (CurrentXferOptions != I2C_FIRST_AND_NEXT_FRAME))
 8001e04:	2a04      	cmp	r2, #4
 8001e06:	d006      	beq.n	8001e16 <I2C_MasterReceive_BTF+0x72>
 8001e08:	2a02      	cmp	r2, #2
 8001e0a:	d004      	beq.n	8001e16 <I2C_MasterReceive_BTF+0x72>
      CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8001e0c:	6802      	ldr	r2, [r0, #0]
 8001e0e:	6813      	ldr	r3, [r2, #0]
 8001e10:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8001e14:	6013      	str	r3, [r2, #0]
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8001e16:	6803      	ldr	r3, [r0, #0]
 8001e18:	691a      	ldr	r2, [r3, #16]
 8001e1a:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8001e1c:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
 8001e1e:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8001e20:	3301      	adds	r3, #1
 8001e22:	6243      	str	r3, [r0, #36]	; 0x24
    hi2c->XferCount--;
 8001e24:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8001e26:	3b01      	subs	r3, #1
 8001e28:	b29b      	uxth	r3, r3
 8001e2a:	8543      	strh	r3, [r0, #42]	; 0x2a
 8001e2c:	e7e4      	b.n	8001df8 <I2C_MasterReceive_BTF+0x54>
    if ((CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME_NO_STOP))
 8001e2e:	2a01      	cmp	r2, #1
 8001e30:	d00b      	beq.n	8001e4a <I2C_MasterReceive_BTF+0xa6>
 8001e32:	2a10      	cmp	r2, #16
 8001e34:	d009      	beq.n	8001e4a <I2C_MasterReceive_BTF+0xa6>
    else if ((CurrentXferOptions == I2C_NEXT_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_NEXT_FRAME))
 8001e36:	2a04      	cmp	r2, #4
 8001e38:	d036      	beq.n	8001ea8 <I2C_MasterReceive_BTF+0x104>
 8001e3a:	2a02      	cmp	r2, #2
 8001e3c:	d034      	beq.n	8001ea8 <I2C_MasterReceive_BTF+0x104>
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8001e3e:	6802      	ldr	r2, [r0, #0]
 8001e40:	6813      	ldr	r3, [r2, #0]
 8001e42:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8001e46:	6013      	str	r3, [r2, #0]
 8001e48:	e004      	b.n	8001e54 <I2C_MasterReceive_BTF+0xb0>
      CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8001e4a:	6802      	ldr	r2, [r0, #0]
 8001e4c:	6813      	ldr	r3, [r2, #0]
 8001e4e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8001e52:	6013      	str	r3, [r2, #0]
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8001e54:	6803      	ldr	r3, [r0, #0]
 8001e56:	691a      	ldr	r2, [r3, #16]
 8001e58:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8001e5a:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
 8001e5c:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8001e5e:	1c53      	adds	r3, r2, #1
 8001e60:	6243      	str	r3, [r0, #36]	; 0x24
    hi2c->XferCount--;
 8001e62:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8001e64:	3b01      	subs	r3, #1
 8001e66:	b29b      	uxth	r3, r3
 8001e68:	8543      	strh	r3, [r0, #42]	; 0x2a
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8001e6a:	6803      	ldr	r3, [r0, #0]
 8001e6c:	691b      	ldr	r3, [r3, #16]
 8001e6e:	7053      	strb	r3, [r2, #1]
    hi2c->pBuffPtr++;
 8001e70:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8001e72:	3301      	adds	r3, #1
 8001e74:	6243      	str	r3, [r0, #36]	; 0x24
    hi2c->XferCount--;
 8001e76:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8001e78:	3b01      	subs	r3, #1
 8001e7a:	b29b      	uxth	r3, r3
 8001e7c:	8543      	strh	r3, [r0, #42]	; 0x2a
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
 8001e7e:	6802      	ldr	r2, [r0, #0]
 8001e80:	6853      	ldr	r3, [r2, #4]
 8001e82:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8001e86:	6053      	str	r3, [r2, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 8001e88:	2320      	movs	r3, #32
 8001e8a:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
 8001e8e:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
 8001e92:	b2db      	uxtb	r3, r3
 8001e94:	2b40      	cmp	r3, #64	; 0x40
 8001e96:	d00d      	beq.n	8001eb4 <I2C_MasterReceive_BTF+0x110>
      hi2c->Mode = HAL_I2C_MODE_NONE;
 8001e98:	2300      	movs	r3, #0
 8001e9a:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
      hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
 8001e9e:	2312      	movs	r3, #18
 8001ea0:	6303      	str	r3, [r0, #48]	; 0x30
      HAL_I2C_MasterRxCpltCallback(hi2c);
 8001ea2:	f7ff fdfa 	bl	8001a9a <HAL_I2C_MasterRxCpltCallback>
 8001ea6:	e7a7      	b.n	8001df8 <I2C_MasterReceive_BTF+0x54>
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8001ea8:	6802      	ldr	r2, [r0, #0]
 8001eaa:	6813      	ldr	r3, [r2, #0]
 8001eac:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8001eb0:	6013      	str	r3, [r2, #0]
 8001eb2:	e7cf      	b.n	8001e54 <I2C_MasterReceive_BTF+0xb0>
      hi2c->Mode = HAL_I2C_MODE_NONE;
 8001eb4:	2300      	movs	r3, #0
 8001eb6:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
      hi2c->PreviousState = I2C_STATE_NONE;
 8001eba:	6303      	str	r3, [r0, #48]	; 0x30
      HAL_I2C_MemRxCpltCallback(hi2c);
 8001ebc:	f7ff ff71 	bl	8001da2 <HAL_I2C_MemRxCpltCallback>
 8001ec0:	e79a      	b.n	8001df8 <I2C_MasterReceive_BTF+0x54>

08001ec2 <HAL_I2C_ErrorCallback>:
}
 8001ec2:	4770      	bx	lr

08001ec4 <I2C_MasterReceive_RXNE>:
  if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
 8001ec4:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8001ec8:	b2db      	uxtb	r3, r3
 8001eca:	2b22      	cmp	r3, #34	; 0x22
 8001ecc:	d000      	beq.n	8001ed0 <I2C_MasterReceive_RXNE+0xc>
 8001ece:	4770      	bx	lr
    tmp = hi2c->XferCount;
 8001ed0:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8001ed2:	b29b      	uxth	r3, r3
    if (tmp > 3U)
 8001ed4:	2b03      	cmp	r3, #3
 8001ed6:	d914      	bls.n	8001f02 <I2C_MasterReceive_RXNE+0x3e>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8001ed8:	6803      	ldr	r3, [r0, #0]
 8001eda:	691a      	ldr	r2, [r3, #16]
 8001edc:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8001ede:	701a      	strb	r2, [r3, #0]
      hi2c->pBuffPtr++;
 8001ee0:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8001ee2:	3301      	adds	r3, #1
 8001ee4:	6243      	str	r3, [r0, #36]	; 0x24
      hi2c->XferCount--;
 8001ee6:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8001ee8:	3b01      	subs	r3, #1
 8001eea:	b29b      	uxth	r3, r3
 8001eec:	8543      	strh	r3, [r0, #42]	; 0x2a
      if (hi2c->XferCount == (uint16_t)3)
 8001eee:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8001ef0:	b29b      	uxth	r3, r3
 8001ef2:	2b03      	cmp	r3, #3
 8001ef4:	d1eb      	bne.n	8001ece <I2C_MasterReceive_RXNE+0xa>
        __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 8001ef6:	6802      	ldr	r2, [r0, #0]
 8001ef8:	6853      	ldr	r3, [r2, #4]
 8001efa:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8001efe:	6053      	str	r3, [r2, #4]
 8001f00:	4770      	bx	lr
    else if ((hi2c->XferOptions != I2C_FIRST_AND_NEXT_FRAME) && ((tmp == 1U) || (tmp == 0U)))
 8001f02:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8001f04:	2a02      	cmp	r2, #2
 8001f06:	d0e2      	beq.n	8001ece <I2C_MasterReceive_RXNE+0xa>
 8001f08:	2b01      	cmp	r3, #1
 8001f0a:	d8e0      	bhi.n	8001ece <I2C_MasterReceive_RXNE+0xa>
{
 8001f0c:	b510      	push	{r4, lr}
 8001f0e:	4604      	mov	r4, r0
      if (I2C_WaitOnSTOPRequestThroughIT(hi2c) == HAL_OK)
 8001f10:	f7ff fbfe 	bl	8001710 <I2C_WaitOnSTOPRequestThroughIT>
 8001f14:	bb68      	cbnz	r0, 8001f72 <I2C_MasterReceive_RXNE+0xae>
        CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8001f16:	6822      	ldr	r2, [r4, #0]
 8001f18:	6813      	ldr	r3, [r2, #0]
 8001f1a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8001f1e:	6013      	str	r3, [r2, #0]
        __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8001f20:	6822      	ldr	r2, [r4, #0]
 8001f22:	6853      	ldr	r3, [r2, #4]
 8001f24:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8001f28:	6053      	str	r3, [r2, #4]
        *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8001f2a:	6823      	ldr	r3, [r4, #0]
 8001f2c:	691a      	ldr	r2, [r3, #16]
 8001f2e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8001f30:	701a      	strb	r2, [r3, #0]
        hi2c->pBuffPtr++;
 8001f32:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8001f34:	3301      	adds	r3, #1
 8001f36:	6263      	str	r3, [r4, #36]	; 0x24
        hi2c->XferCount--;
 8001f38:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8001f3a:	3b01      	subs	r3, #1
 8001f3c:	b29b      	uxth	r3, r3
 8001f3e:	8563      	strh	r3, [r4, #42]	; 0x2a
        hi2c->State = HAL_I2C_STATE_READY;
 8001f40:	2320      	movs	r3, #32
 8001f42:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
        if (hi2c->Mode == HAL_I2C_MODE_MEM)
 8001f46:	f894 303e 	ldrb.w	r3, [r4, #62]	; 0x3e
 8001f4a:	b2db      	uxtb	r3, r3
 8001f4c:	2b40      	cmp	r3, #64	; 0x40
 8001f4e:	d008      	beq.n	8001f62 <I2C_MasterReceive_RXNE+0x9e>
          hi2c->Mode = HAL_I2C_MODE_NONE;
 8001f50:	2300      	movs	r3, #0
 8001f52:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
          hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
 8001f56:	2312      	movs	r3, #18
 8001f58:	6323      	str	r3, [r4, #48]	; 0x30
          HAL_I2C_MasterRxCpltCallback(hi2c);
 8001f5a:	4620      	mov	r0, r4
 8001f5c:	f7ff fd9d 	bl	8001a9a <HAL_I2C_MasterRxCpltCallback>
}
 8001f60:	bd10      	pop	{r4, pc}
          hi2c->Mode = HAL_I2C_MODE_NONE;
 8001f62:	2300      	movs	r3, #0
 8001f64:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
          hi2c->PreviousState = I2C_STATE_NONE;
 8001f68:	6323      	str	r3, [r4, #48]	; 0x30
          HAL_I2C_MemRxCpltCallback(hi2c);
 8001f6a:	4620      	mov	r0, r4
 8001f6c:	f7ff ff19 	bl	8001da2 <HAL_I2C_MemRxCpltCallback>
 8001f70:	e7f6      	b.n	8001f60 <I2C_MasterReceive_RXNE+0x9c>
        __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8001f72:	6822      	ldr	r2, [r4, #0]
 8001f74:	6853      	ldr	r3, [r2, #4]
 8001f76:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8001f7a:	6053      	str	r3, [r2, #4]
        *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8001f7c:	6823      	ldr	r3, [r4, #0]
 8001f7e:	691a      	ldr	r2, [r3, #16]
 8001f80:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8001f82:	701a      	strb	r2, [r3, #0]
        hi2c->pBuffPtr++;
 8001f84:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8001f86:	3301      	adds	r3, #1
 8001f88:	6263      	str	r3, [r4, #36]	; 0x24
        hi2c->XferCount--;
 8001f8a:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8001f8c:	3b01      	subs	r3, #1
 8001f8e:	b29b      	uxth	r3, r3
 8001f90:	8563      	strh	r3, [r4, #42]	; 0x2a
        hi2c->State = HAL_I2C_STATE_READY;
 8001f92:	2320      	movs	r3, #32
 8001f94:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8001f98:	2300      	movs	r3, #0
 8001f9a:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
        HAL_I2C_ErrorCallback(hi2c);
 8001f9e:	4620      	mov	r0, r4
 8001fa0:	f7ff ff8f 	bl	8001ec2 <HAL_I2C_ErrorCallback>
}
 8001fa4:	e7dc      	b.n	8001f60 <I2C_MasterReceive_RXNE+0x9c>

08001fa6 <HAL_I2C_AbortCpltCallback>:
}
 8001fa6:	4770      	bx	lr

08001fa8 <I2C_DMAAbort>:
{
 8001fa8:	b500      	push	{lr}
 8001faa:	b083      	sub	sp, #12
  __IO uint32_t count = 0U;
 8001fac:	2300      	movs	r3, #0
 8001fae:	9301      	str	r3, [sp, #4]
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent; /* Derogation MISRAC2012-Rule-11.5 */
 8001fb0:	6a40      	ldr	r0, [r0, #36]	; 0x24
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 8001fb2:	f890 203d 	ldrb.w	r2, [r0, #61]	; 0x3d
 8001fb6:	b2d2      	uxtb	r2, r2
  count = I2C_TIMEOUT_FLAG * (SystemCoreClock / 25U / 1000U);
 8001fb8:	4b32      	ldr	r3, [pc, #200]	; (8002084 <I2C_DMAAbort+0xdc>)
 8001fba:	681b      	ldr	r3, [r3, #0]
 8001fbc:	08db      	lsrs	r3, r3, #3
 8001fbe:	4932      	ldr	r1, [pc, #200]	; (8002088 <I2C_DMAAbort+0xe0>)
 8001fc0:	fba1 1303 	umull	r1, r3, r1, r3
 8001fc4:	0a1b      	lsrs	r3, r3, #8
 8001fc6:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8001fca:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 8001fce:	9301      	str	r3, [sp, #4]
    if (count == 0U)
 8001fd0:	9b01      	ldr	r3, [sp, #4]
 8001fd2:	b143      	cbz	r3, 8001fe6 <I2C_DMAAbort+0x3e>
    count--;
 8001fd4:	9b01      	ldr	r3, [sp, #4]
 8001fd6:	3b01      	subs	r3, #1
 8001fd8:	9301      	str	r3, [sp, #4]
  while (READ_BIT(hi2c->Instance->CR1, I2C_CR1_STOP) == I2C_CR1_STOP);
 8001fda:	6803      	ldr	r3, [r0, #0]
 8001fdc:	681b      	ldr	r3, [r3, #0]
 8001fde:	f413 7f00 	tst.w	r3, #512	; 0x200
 8001fe2:	d1f5      	bne.n	8001fd0 <I2C_DMAAbort+0x28>
 8001fe4:	e003      	b.n	8001fee <I2C_DMAAbort+0x46>
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8001fe6:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8001fe8:	f043 0320 	orr.w	r3, r3, #32
 8001fec:	6403      	str	r3, [r0, #64]	; 0x40
  if (hi2c->hdmatx != NULL)
 8001fee:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8001ff0:	b10b      	cbz	r3, 8001ff6 <I2C_DMAAbort+0x4e>
    hi2c->hdmatx->XferCpltCallback = NULL;
 8001ff2:	2100      	movs	r1, #0
 8001ff4:	6299      	str	r1, [r3, #40]	; 0x28
  if (hi2c->hdmarx != NULL)
 8001ff6:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8001ff8:	b10b      	cbz	r3, 8001ffe <I2C_DMAAbort+0x56>
    hi2c->hdmarx->XferCpltCallback = NULL;
 8001ffa:	2100      	movs	r1, #0
 8001ffc:	6299      	str	r1, [r3, #40]	; 0x28
  CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8001ffe:	6801      	ldr	r1, [r0, #0]
 8002000:	680b      	ldr	r3, [r1, #0]
 8002002:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8002006:	600b      	str	r3, [r1, #0]
  hi2c->XferCount = 0U;
 8002008:	2300      	movs	r3, #0
 800200a:	8543      	strh	r3, [r0, #42]	; 0x2a
  if (hi2c->hdmatx != NULL)
 800200c:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800200e:	b10b      	cbz	r3, 8002014 <I2C_DMAAbort+0x6c>
    hi2c->hdmatx->XferAbortCallback = NULL;
 8002010:	2100      	movs	r1, #0
 8002012:	6359      	str	r1, [r3, #52]	; 0x34
  if (hi2c->hdmarx != NULL)
 8002014:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8002016:	b10b      	cbz	r3, 800201c <I2C_DMAAbort+0x74>
    hi2c->hdmarx->XferAbortCallback = NULL;
 8002018:	2100      	movs	r1, #0
 800201a:	6359      	str	r1, [r3, #52]	; 0x34
  __HAL_I2C_DISABLE(hi2c);
 800201c:	6801      	ldr	r1, [r0, #0]
 800201e:	680b      	ldr	r3, [r1, #0]
 8002020:	f023 0301 	bic.w	r3, r3, #1
 8002024:	600b      	str	r3, [r1, #0]
  if (hi2c->State == HAL_I2C_STATE_ABORT)
 8002026:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 800202a:	b2db      	uxtb	r3, r3
 800202c:	2b60      	cmp	r3, #96	; 0x60
 800202e:	d00e      	beq.n	800204e <I2C_DMAAbort+0xa6>
    if (((uint32_t)CurrentState & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
 8002030:	f002 0228 	and.w	r2, r2, #40	; 0x28
 8002034:	2a28      	cmp	r2, #40	; 0x28
 8002036:	d014      	beq.n	8002062 <I2C_DMAAbort+0xba>
      hi2c->State = HAL_I2C_STATE_READY;
 8002038:	2320      	movs	r3, #32
 800203a:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
      hi2c->Mode = HAL_I2C_MODE_NONE;
 800203e:	2300      	movs	r3, #0
 8002040:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
    HAL_I2C_ErrorCallback(hi2c);
 8002044:	f7ff ff3d 	bl	8001ec2 <HAL_I2C_ErrorCallback>
}
 8002048:	b003      	add	sp, #12
 800204a:	f85d fb04 	ldr.w	pc, [sp], #4
    hi2c->State         = HAL_I2C_STATE_READY;
 800204e:	2320      	movs	r3, #32
 8002050:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
    hi2c->Mode          = HAL_I2C_MODE_NONE;
 8002054:	2300      	movs	r3, #0
 8002056:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
    hi2c->ErrorCode     = HAL_I2C_ERROR_NONE;
 800205a:	6403      	str	r3, [r0, #64]	; 0x40
    HAL_I2C_AbortCpltCallback(hi2c);
 800205c:	f7ff ffa3 	bl	8001fa6 <HAL_I2C_AbortCpltCallback>
 8002060:	e7f2      	b.n	8002048 <I2C_DMAAbort+0xa0>
      __HAL_I2C_ENABLE(hi2c);
 8002062:	6802      	ldr	r2, [r0, #0]
 8002064:	6813      	ldr	r3, [r2, #0]
 8002066:	f043 0301 	orr.w	r3, r3, #1
 800206a:	6013      	str	r3, [r2, #0]
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 800206c:	6802      	ldr	r2, [r0, #0]
 800206e:	6813      	ldr	r3, [r2, #0]
 8002070:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8002074:	6013      	str	r3, [r2, #0]
      hi2c->PreviousState = I2C_STATE_NONE;
 8002076:	2300      	movs	r3, #0
 8002078:	6303      	str	r3, [r0, #48]	; 0x30
      hi2c->State = HAL_I2C_STATE_LISTEN;
 800207a:	2328      	movs	r3, #40	; 0x28
 800207c:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
 8002080:	e7e0      	b.n	8002044 <I2C_DMAAbort+0x9c>
 8002082:	bf00      	nop
 8002084:	2000000c 	.word	0x2000000c
 8002088:	14f8b589 	.word	0x14f8b589

0800208c <I2C_ITError>:
{
 800208c:	b510      	push	{r4, lr}
 800208e:	4604      	mov	r4, r0
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 8002090:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8002094:	b2db      	uxtb	r3, r3
  HAL_I2C_ModeTypeDef CurrentMode = hi2c->Mode;
 8002096:	f890 203e 	ldrb.w	r2, [r0, #62]	; 0x3e
 800209a:	b2d2      	uxtb	r2, r2
  if (((CurrentMode == HAL_I2C_MODE_MASTER) || (CurrentMode == HAL_I2C_MODE_MEM)) && (CurrentState == HAL_I2C_STATE_BUSY_RX))
 800209c:	2a10      	cmp	r2, #16
 800209e:	d035      	beq.n	800210c <I2C_ITError+0x80>
 80020a0:	2a40      	cmp	r2, #64	; 0x40
 80020a2:	d033      	beq.n	800210c <I2C_ITError+0x80>
  if (((uint32_t)CurrentState & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
 80020a4:	f003 0228 	and.w	r2, r3, #40	; 0x28
 80020a8:	2a28      	cmp	r2, #40	; 0x28
 80020aa:	d037      	beq.n	800211c <I2C_ITError+0x90>
    if ((READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) != I2C_CR2_DMAEN) && (CurrentState != HAL_I2C_STATE_ABORT))
 80020ac:	6822      	ldr	r2, [r4, #0]
 80020ae:	6852      	ldr	r2, [r2, #4]
 80020b0:	f412 6f00 	tst.w	r2, #2048	; 0x800
 80020b4:	d107      	bne.n	80020c6 <I2C_ITError+0x3a>
 80020b6:	2b60      	cmp	r3, #96	; 0x60
 80020b8:	d005      	beq.n	80020c6 <I2C_ITError+0x3a>
      hi2c->State = HAL_I2C_STATE_READY;
 80020ba:	2320      	movs	r3, #32
 80020bc:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
      hi2c->Mode = HAL_I2C_MODE_NONE;
 80020c0:	2300      	movs	r3, #0
 80020c2:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
    hi2c->PreviousState = I2C_STATE_NONE;
 80020c6:	2300      	movs	r3, #0
 80020c8:	6323      	str	r3, [r4, #48]	; 0x30
  if (READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
 80020ca:	6823      	ldr	r3, [r4, #0]
 80020cc:	685a      	ldr	r2, [r3, #4]
 80020ce:	f412 6f00 	tst.w	r2, #2048	; 0x800
 80020d2:	d047      	beq.n	8002164 <I2C_ITError+0xd8>
    hi2c->Instance->CR2 &= ~I2C_CR2_DMAEN;
 80020d4:	685a      	ldr	r2, [r3, #4]
 80020d6:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 80020da:	605a      	str	r2, [r3, #4]
    if (hi2c->hdmatx->State != HAL_DMA_STATE_READY)
 80020dc:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80020de:	f893 2021 	ldrb.w	r2, [r3, #33]	; 0x21
 80020e2:	2a01      	cmp	r2, #1
 80020e4:	d020      	beq.n	8002128 <I2C_ITError+0x9c>
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 80020e6:	4a44      	ldr	r2, [pc, #272]	; (80021f8 <I2C_ITError+0x16c>)
 80020e8:	635a      	str	r2, [r3, #52]	; 0x34
      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
 80020ea:	6b60      	ldr	r0, [r4, #52]	; 0x34
 80020ec:	f7fe fda0 	bl	8000c30 <HAL_DMA_Abort_IT>
 80020f0:	2800      	cmp	r0, #0
 80020f2:	d049      	beq.n	8002188 <I2C_ITError+0xfc>
        __HAL_I2C_DISABLE(hi2c);
 80020f4:	6822      	ldr	r2, [r4, #0]
 80020f6:	6813      	ldr	r3, [r2, #0]
 80020f8:	f023 0301 	bic.w	r3, r3, #1
 80020fc:	6013      	str	r3, [r2, #0]
        hi2c->State = HAL_I2C_STATE_READY;
 80020fe:	2320      	movs	r3, #32
 8002100:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 8002104:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8002106:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8002108:	4798      	blx	r3
 800210a:	e03d      	b.n	8002188 <I2C_ITError+0xfc>
  if (((CurrentMode == HAL_I2C_MODE_MASTER) || (CurrentMode == HAL_I2C_MODE_MEM)) && (CurrentState == HAL_I2C_STATE_BUSY_RX))
 800210c:	2b22      	cmp	r3, #34	; 0x22
 800210e:	d1c9      	bne.n	80020a4 <I2C_ITError+0x18>
    hi2c->Instance->CR1 &= ~I2C_CR1_POS;
 8002110:	6821      	ldr	r1, [r4, #0]
 8002112:	680a      	ldr	r2, [r1, #0]
 8002114:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8002118:	600a      	str	r2, [r1, #0]
 800211a:	e7c3      	b.n	80020a4 <I2C_ITError+0x18>
    hi2c->PreviousState = I2C_STATE_NONE;
 800211c:	2300      	movs	r3, #0
 800211e:	6323      	str	r3, [r4, #48]	; 0x30
    hi2c->State = HAL_I2C_STATE_LISTEN;
 8002120:	2328      	movs	r3, #40	; 0x28
 8002122:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
 8002126:	e7d0      	b.n	80020ca <I2C_ITError+0x3e>
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 8002128:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800212a:	4a33      	ldr	r2, [pc, #204]	; (80021f8 <I2C_ITError+0x16c>)
 800212c:	635a      	str	r2, [r3, #52]	; 0x34
      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
 800212e:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8002130:	f7fe fd7e 	bl	8000c30 <HAL_DMA_Abort_IT>
 8002134:	b340      	cbz	r0, 8002188 <I2C_ITError+0xfc>
        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
 8002136:	6823      	ldr	r3, [r4, #0]
 8002138:	695a      	ldr	r2, [r3, #20]
 800213a:	f012 0f40 	tst.w	r2, #64	; 0x40
 800213e:	d005      	beq.n	800214c <I2C_ITError+0xc0>
          *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8002140:	691a      	ldr	r2, [r3, #16]
 8002142:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8002144:	701a      	strb	r2, [r3, #0]
          hi2c->pBuffPtr++;
 8002146:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8002148:	3301      	adds	r3, #1
 800214a:	6263      	str	r3, [r4, #36]	; 0x24
        __HAL_I2C_DISABLE(hi2c);
 800214c:	6822      	ldr	r2, [r4, #0]
 800214e:	6813      	ldr	r3, [r2, #0]
 8002150:	f023 0301 	bic.w	r3, r3, #1
 8002154:	6013      	str	r3, [r2, #0]
        hi2c->State = HAL_I2C_STATE_READY;
 8002156:	2320      	movs	r3, #32
 8002158:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 800215c:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 800215e:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8002160:	4798      	blx	r3
 8002162:	e011      	b.n	8002188 <I2C_ITError+0xfc>
  else if (hi2c->State == HAL_I2C_STATE_ABORT)
 8002164:	f894 203d 	ldrb.w	r2, [r4, #61]	; 0x3d
 8002168:	b2d2      	uxtb	r2, r2
 800216a:	2a60      	cmp	r2, #96	; 0x60
 800216c:	d01f      	beq.n	80021ae <I2C_ITError+0x122>
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
 800216e:	695a      	ldr	r2, [r3, #20]
 8002170:	f012 0f40 	tst.w	r2, #64	; 0x40
 8002174:	d005      	beq.n	8002182 <I2C_ITError+0xf6>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8002176:	691a      	ldr	r2, [r3, #16]
 8002178:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800217a:	701a      	strb	r2, [r3, #0]
      hi2c->pBuffPtr++;
 800217c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800217e:	3301      	adds	r3, #1
 8002180:	6263      	str	r3, [r4, #36]	; 0x24
    HAL_I2C_ErrorCallback(hi2c);
 8002182:	4620      	mov	r0, r4
 8002184:	f7ff fe9d 	bl	8001ec2 <HAL_I2C_ErrorCallback>
  CurrentError = hi2c->ErrorCode;
 8002188:	6c23      	ldr	r3, [r4, #64]	; 0x40
  if (((CurrentError & HAL_I2C_ERROR_BERR) == HAL_I2C_ERROR_BERR) || \
 800218a:	f013 0f0f 	tst.w	r3, #15
 800218e:	d004      	beq.n	800219a <I2C_ITError+0x10e>
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8002190:	6822      	ldr	r2, [r4, #0]
 8002192:	6853      	ldr	r3, [r2, #4]
 8002194:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8002198:	6053      	str	r3, [r2, #4]
  CurrentState = hi2c->State;
 800219a:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
 800219e:	b2db      	uxtb	r3, r3
  if (((hi2c->ErrorCode & HAL_I2C_ERROR_AF) == HAL_I2C_ERROR_AF) && (CurrentState == HAL_I2C_STATE_LISTEN))
 80021a0:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80021a2:	f012 0f04 	tst.w	r2, #4
 80021a6:	d001      	beq.n	80021ac <I2C_ITError+0x120>
 80021a8:	2b28      	cmp	r3, #40	; 0x28
 80021aa:	d018      	beq.n	80021de <I2C_ITError+0x152>
}
 80021ac:	bd10      	pop	{r4, pc}
    hi2c->State = HAL_I2C_STATE_READY;
 80021ae:	2220      	movs	r2, #32
 80021b0:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80021b4:	2200      	movs	r2, #0
 80021b6:	6422      	str	r2, [r4, #64]	; 0x40
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
 80021b8:	695a      	ldr	r2, [r3, #20]
 80021ba:	f012 0f40 	tst.w	r2, #64	; 0x40
 80021be:	d005      	beq.n	80021cc <I2C_ITError+0x140>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 80021c0:	691a      	ldr	r2, [r3, #16]
 80021c2:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80021c4:	701a      	strb	r2, [r3, #0]
      hi2c->pBuffPtr++;
 80021c6:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80021c8:	3301      	adds	r3, #1
 80021ca:	6263      	str	r3, [r4, #36]	; 0x24
    __HAL_I2C_DISABLE(hi2c);
 80021cc:	6822      	ldr	r2, [r4, #0]
 80021ce:	6813      	ldr	r3, [r2, #0]
 80021d0:	f023 0301 	bic.w	r3, r3, #1
 80021d4:	6013      	str	r3, [r2, #0]
    HAL_I2C_AbortCpltCallback(hi2c);
 80021d6:	4620      	mov	r0, r4
 80021d8:	f7ff fee5 	bl	8001fa6 <HAL_I2C_AbortCpltCallback>
 80021dc:	e7d4      	b.n	8002188 <I2C_ITError+0xfc>
    hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 80021de:	4b07      	ldr	r3, [pc, #28]	; (80021fc <I2C_ITError+0x170>)
 80021e0:	62e3      	str	r3, [r4, #44]	; 0x2c
    hi2c->PreviousState = I2C_STATE_NONE;
 80021e2:	2300      	movs	r3, #0
 80021e4:	6323      	str	r3, [r4, #48]	; 0x30
    hi2c->State         = HAL_I2C_STATE_READY;
 80021e6:	2220      	movs	r2, #32
 80021e8:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
    hi2c->Mode          = HAL_I2C_MODE_NONE;
 80021ec:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
    HAL_I2C_ListenCpltCallback(hi2c);
 80021f0:	4620      	mov	r0, r4
 80021f2:	f7ff fcc7 	bl	8001b84 <HAL_I2C_ListenCpltCallback>
}
 80021f6:	e7d9      	b.n	80021ac <I2C_ITError+0x120>
 80021f8:	08001fa9 	.word	0x08001fa9
 80021fc:	ffff0000 	.word	0xffff0000

08002200 <I2C_Slave_STOPF>:
{
 8002200:	b530      	push	{r4, r5, lr}
 8002202:	b083      	sub	sp, #12
 8002204:	4604      	mov	r4, r0
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 8002206:	f890 503d 	ldrb.w	r5, [r0, #61]	; 0x3d
 800220a:	b2ed      	uxtb	r5, r5
  __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 800220c:	6802      	ldr	r2, [r0, #0]
 800220e:	6853      	ldr	r3, [r2, #4]
 8002210:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8002214:	6053      	str	r3, [r2, #4]
  __HAL_I2C_CLEAR_STOPFLAG(hi2c);
 8002216:	2300      	movs	r3, #0
 8002218:	9301      	str	r3, [sp, #4]
 800221a:	6803      	ldr	r3, [r0, #0]
 800221c:	695a      	ldr	r2, [r3, #20]
 800221e:	9201      	str	r2, [sp, #4]
 8002220:	681a      	ldr	r2, [r3, #0]
 8002222:	f042 0201 	orr.w	r2, r2, #1
 8002226:	601a      	str	r2, [r3, #0]
 8002228:	9b01      	ldr	r3, [sp, #4]
  CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 800222a:	6802      	ldr	r2, [r0, #0]
 800222c:	6813      	ldr	r3, [r2, #0]
 800222e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8002232:	6013      	str	r3, [r2, #0]
  if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
 8002234:	6803      	ldr	r3, [r0, #0]
 8002236:	685a      	ldr	r2, [r3, #4]
 8002238:	f412 6f00 	tst.w	r2, #2048	; 0x800
 800223c:	d038      	beq.n	80022b0 <I2C_Slave_STOPF+0xb0>
    if ((CurrentState == HAL_I2C_STATE_BUSY_RX) || (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN))
 800223e:	2d22      	cmp	r5, #34	; 0x22
 8002240:	d021      	beq.n	8002286 <I2C_Slave_STOPF+0x86>
 8002242:	2d2a      	cmp	r5, #42	; 0x2a
 8002244:	d01f      	beq.n	8002286 <I2C_Slave_STOPF+0x86>
      hi2c->XferCount = (uint16_t)(__HAL_DMA_GET_COUNTER(hi2c->hdmatx));
 8002246:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8002248:	6812      	ldr	r2, [r2, #0]
 800224a:	6852      	ldr	r2, [r2, #4]
 800224c:	b292      	uxth	r2, r2
 800224e:	8542      	strh	r2, [r0, #42]	; 0x2a
      if (hi2c->XferCount != 0U)
 8002250:	8d42      	ldrh	r2, [r0, #42]	; 0x2a
 8002252:	b292      	uxth	r2, r2
 8002254:	b11a      	cbz	r2, 800225e <I2C_Slave_STOPF+0x5e>
        hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8002256:	6c02      	ldr	r2, [r0, #64]	; 0x40
 8002258:	f042 0204 	orr.w	r2, r2, #4
 800225c:	6402      	str	r2, [r0, #64]	; 0x40
      CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
 800225e:	685a      	ldr	r2, [r3, #4]
 8002260:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8002264:	605a      	str	r2, [r3, #4]
      if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
 8002266:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8002268:	f7fe ff0c 	bl	8001084 <HAL_DMA_GetState>
 800226c:	2801      	cmp	r0, #1
 800226e:	d01f      	beq.n	80022b0 <I2C_Slave_STOPF+0xb0>
        hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 8002270:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8002272:	4a43      	ldr	r2, [pc, #268]	; (8002380 <I2C_Slave_STOPF+0x180>)
 8002274:	635a      	str	r2, [r3, #52]	; 0x34
        if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
 8002276:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8002278:	f7fe fcda 	bl	8000c30 <HAL_DMA_Abort_IT>
 800227c:	b1c0      	cbz	r0, 80022b0 <I2C_Slave_STOPF+0xb0>
          hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 800227e:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8002280:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8002282:	4798      	blx	r3
 8002284:	e014      	b.n	80022b0 <I2C_Slave_STOPF+0xb0>
      hi2c->XferCount = (uint16_t)(__HAL_DMA_GET_COUNTER(hi2c->hdmarx));
 8002286:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8002288:	6812      	ldr	r2, [r2, #0]
 800228a:	6852      	ldr	r2, [r2, #4]
 800228c:	b292      	uxth	r2, r2
 800228e:	8562      	strh	r2, [r4, #42]	; 0x2a
      if (hi2c->XferCount != 0U)
 8002290:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 8002292:	b292      	uxth	r2, r2
 8002294:	b11a      	cbz	r2, 800229e <I2C_Slave_STOPF+0x9e>
        hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8002296:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8002298:	f042 0204 	orr.w	r2, r2, #4
 800229c:	6422      	str	r2, [r4, #64]	; 0x40
      CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
 800229e:	685a      	ldr	r2, [r3, #4]
 80022a0:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 80022a4:	605a      	str	r2, [r3, #4]
      if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
 80022a6:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 80022a8:	f7fe feec 	bl	8001084 <HAL_DMA_GetState>
 80022ac:	2801      	cmp	r0, #1
 80022ae:	d140      	bne.n	8002332 <I2C_Slave_STOPF+0x132>
  if (hi2c->XferCount != 0U)
 80022b0:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 80022b2:	b29b      	uxth	r3, r3
 80022b4:	b323      	cbz	r3, 8002300 <I2C_Slave_STOPF+0x100>
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
 80022b6:	6823      	ldr	r3, [r4, #0]
 80022b8:	695a      	ldr	r2, [r3, #20]
 80022ba:	f012 0f04 	tst.w	r2, #4
 80022be:	d009      	beq.n	80022d4 <I2C_Slave_STOPF+0xd4>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 80022c0:	691a      	ldr	r2, [r3, #16]
 80022c2:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80022c4:	701a      	strb	r2, [r3, #0]
      hi2c->pBuffPtr++;
 80022c6:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80022c8:	3301      	adds	r3, #1
 80022ca:	6263      	str	r3, [r4, #36]	; 0x24
      hi2c->XferCount--;
 80022cc:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 80022ce:	3b01      	subs	r3, #1
 80022d0:	b29b      	uxth	r3, r3
 80022d2:	8563      	strh	r3, [r4, #42]	; 0x2a
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
 80022d4:	6823      	ldr	r3, [r4, #0]
 80022d6:	695a      	ldr	r2, [r3, #20]
 80022d8:	f012 0f40 	tst.w	r2, #64	; 0x40
 80022dc:	d009      	beq.n	80022f2 <I2C_Slave_STOPF+0xf2>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 80022de:	691a      	ldr	r2, [r3, #16]
 80022e0:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80022e2:	701a      	strb	r2, [r3, #0]
      hi2c->pBuffPtr++;
 80022e4:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80022e6:	3301      	adds	r3, #1
 80022e8:	6263      	str	r3, [r4, #36]	; 0x24
      hi2c->XferCount--;
 80022ea:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 80022ec:	3b01      	subs	r3, #1
 80022ee:	b29b      	uxth	r3, r3
 80022f0:	8563      	strh	r3, [r4, #42]	; 0x2a
    if (hi2c->XferCount != 0U)
 80022f2:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 80022f4:	b29b      	uxth	r3, r3
 80022f6:	b11b      	cbz	r3, 8002300 <I2C_Slave_STOPF+0x100>
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 80022f8:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80022fa:	f043 0304 	orr.w	r3, r3, #4
 80022fe:	6423      	str	r3, [r4, #64]	; 0x40
  if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8002300:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8002302:	bb13      	cbnz	r3, 800234a <I2C_Slave_STOPF+0x14a>
    if (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN)
 8002304:	2d2a      	cmp	r5, #42	; 0x2a
 8002306:	d025      	beq.n	8002354 <I2C_Slave_STOPF+0x154>
    if (hi2c->State == HAL_I2C_STATE_LISTEN)
 8002308:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
 800230c:	b2db      	uxtb	r3, r3
 800230e:	2b28      	cmp	r3, #40	; 0x28
 8002310:	d029      	beq.n	8002366 <I2C_Slave_STOPF+0x166>
      if ((hi2c->PreviousState  == I2C_STATE_SLAVE_BUSY_RX) || (CurrentState == HAL_I2C_STATE_BUSY_RX))
 8002312:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002314:	2b22      	cmp	r3, #34	; 0x22
 8002316:	d001      	beq.n	800231c <I2C_Slave_STOPF+0x11c>
 8002318:	2d22      	cmp	r5, #34	; 0x22
 800231a:	d119      	bne.n	8002350 <I2C_Slave_STOPF+0x150>
        hi2c->PreviousState = I2C_STATE_NONE;
 800231c:	2300      	movs	r3, #0
 800231e:	6323      	str	r3, [r4, #48]	; 0x30
        hi2c->State = HAL_I2C_STATE_READY;
 8002320:	2220      	movs	r2, #32
 8002322:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8002326:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
        HAL_I2C_SlaveRxCpltCallback(hi2c);
 800232a:	4620      	mov	r0, r4
 800232c:	f7ff fbdc 	bl	8001ae8 <HAL_I2C_SlaveRxCpltCallback>
}
 8002330:	e00e      	b.n	8002350 <I2C_Slave_STOPF+0x150>
        hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 8002332:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002334:	4a12      	ldr	r2, [pc, #72]	; (8002380 <I2C_Slave_STOPF+0x180>)
 8002336:	635a      	str	r2, [r3, #52]	; 0x34
        if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
 8002338:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 800233a:	f7fe fc79 	bl	8000c30 <HAL_DMA_Abort_IT>
 800233e:	2800      	cmp	r0, #0
 8002340:	d0b6      	beq.n	80022b0 <I2C_Slave_STOPF+0xb0>
          hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 8002342:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8002344:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8002346:	4798      	blx	r3
 8002348:	e7b2      	b.n	80022b0 <I2C_Slave_STOPF+0xb0>
    I2C_ITError(hi2c);
 800234a:	4620      	mov	r0, r4
 800234c:	f7ff fe9e 	bl	800208c <I2C_ITError>
}
 8002350:	b003      	add	sp, #12
 8002352:	bd30      	pop	{r4, r5, pc}
      hi2c->PreviousState = I2C_STATE_NONE;
 8002354:	2300      	movs	r3, #0
 8002356:	6323      	str	r3, [r4, #48]	; 0x30
      hi2c->State = HAL_I2C_STATE_LISTEN;
 8002358:	2328      	movs	r3, #40	; 0x28
 800235a:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
      HAL_I2C_SlaveRxCpltCallback(hi2c);
 800235e:	4620      	mov	r0, r4
 8002360:	f7ff fbc2 	bl	8001ae8 <HAL_I2C_SlaveRxCpltCallback>
 8002364:	e7d0      	b.n	8002308 <I2C_Slave_STOPF+0x108>
      hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8002366:	4b07      	ldr	r3, [pc, #28]	; (8002384 <I2C_Slave_STOPF+0x184>)
 8002368:	62e3      	str	r3, [r4, #44]	; 0x2c
      hi2c->PreviousState = I2C_STATE_NONE;
 800236a:	2300      	movs	r3, #0
 800236c:	6323      	str	r3, [r4, #48]	; 0x30
      hi2c->State = HAL_I2C_STATE_READY;
 800236e:	2220      	movs	r2, #32
 8002370:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
      hi2c->Mode = HAL_I2C_MODE_NONE;
 8002374:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
      HAL_I2C_ListenCpltCallback(hi2c);
 8002378:	4620      	mov	r0, r4
 800237a:	f7ff fc03 	bl	8001b84 <HAL_I2C_ListenCpltCallback>
 800237e:	e7e7      	b.n	8002350 <I2C_Slave_STOPF+0x150>
 8002380:	08001fa9 	.word	0x08001fa9
 8002384:	ffff0000 	.word	0xffff0000

08002388 <HAL_I2C_EV_IRQHandler>:
{
 8002388:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800238a:	4604      	mov	r4, r0
  uint32_t itsources                = READ_REG(hi2c->Instance->CR2);
 800238c:	6802      	ldr	r2, [r0, #0]
 800238e:	6855      	ldr	r5, [r2, #4]
  uint32_t CurrentXferOptions       = hi2c->XferOptions;
 8002390:	6ac6      	ldr	r6, [r0, #44]	; 0x2c
  HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
 8002392:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
 8002396:	b2db      	uxtb	r3, r3
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 8002398:	f890 103d 	ldrb.w	r1, [r0, #61]	; 0x3d
  if ((CurrentMode == HAL_I2C_MODE_MASTER) || (CurrentMode == HAL_I2C_MODE_MEM))
 800239c:	2b10      	cmp	r3, #16
 800239e:	d014      	beq.n	80023ca <HAL_I2C_EV_IRQHandler+0x42>
 80023a0:	b2c8      	uxtb	r0, r1
 80023a2:	2b40      	cmp	r3, #64	; 0x40
 80023a4:	d011      	beq.n	80023ca <HAL_I2C_EV_IRQHandler+0x42>
    if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 80023a6:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80023a8:	2b00      	cmp	r3, #0
 80023aa:	d077      	beq.n	800249c <HAL_I2C_EV_IRQHandler+0x114>
      sr1itflags   = READ_REG(hi2c->Instance->SR1);
 80023ac:	6953      	ldr	r3, [r2, #20]
  uint32_t sr2itflags               = 0U;
 80023ae:	2100      	movs	r1, #0
    if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 80023b0:	f013 0f02 	tst.w	r3, #2
 80023b4:	d075      	beq.n	80024a2 <HAL_I2C_EV_IRQHandler+0x11a>
 80023b6:	f415 7f00 	tst.w	r5, #512	; 0x200
 80023ba:	d072      	beq.n	80024a2 <HAL_I2C_EV_IRQHandler+0x11a>
      if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 80023bc:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80023be:	b103      	cbz	r3, 80023c2 <HAL_I2C_EV_IRQHandler+0x3a>
        sr2itflags   = READ_REG(hi2c->Instance->SR2);
 80023c0:	6991      	ldr	r1, [r2, #24]
      I2C_Slave_ADDR(hi2c, sr2itflags);
 80023c2:	4620      	mov	r0, r4
 80023c4:	f7ff fbb7 	bl	8001b36 <I2C_Slave_ADDR>
}
 80023c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    sr2itflags   = READ_REG(hi2c->Instance->SR2);
 80023ca:	6997      	ldr	r7, [r2, #24]
    sr1itflags   = READ_REG(hi2c->Instance->SR1);
 80023cc:	6951      	ldr	r1, [r2, #20]
    if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_SB) == RESET) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(CurrentXferOptions) == 1U))
 80023ce:	f011 0001 	ands.w	r0, r1, #1
 80023d2:	d105      	bne.n	80023e0 <HAL_I2C_EV_IRQHandler+0x58>
 80023d4:	f5b6 0f2a 	cmp.w	r6, #11141120	; 0xaa0000
 80023d8:	d0f6      	beq.n	80023c8 <HAL_I2C_EV_IRQHandler+0x40>
 80023da:	f1b6 4f2a 	cmp.w	r6, #2852126720	; 0xaa000000
 80023de:	d0f3      	beq.n	80023c8 <HAL_I2C_EV_IRQHandler+0x40>
    if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_SB) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 80023e0:	b110      	cbz	r0, 80023e8 <HAL_I2C_EV_IRQHandler+0x60>
 80023e2:	f415 7f00 	tst.w	r5, #512	; 0x200
 80023e6:	d127      	bne.n	8002438 <HAL_I2C_EV_IRQHandler+0xb0>
    else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ADD10) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 80023e8:	f011 0f08 	tst.w	r1, #8
 80023ec:	d002      	beq.n	80023f4 <HAL_I2C_EV_IRQHandler+0x6c>
 80023ee:	f415 7f00 	tst.w	r5, #512	; 0x200
 80023f2:	d128      	bne.n	8002446 <HAL_I2C_EV_IRQHandler+0xbe>
    else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 80023f4:	f011 0f02 	tst.w	r1, #2
 80023f8:	d002      	beq.n	8002400 <HAL_I2C_EV_IRQHandler+0x78>
 80023fa:	f415 7f00 	tst.w	r5, #512	; 0x200
 80023fe:	d126      	bne.n	800244e <HAL_I2C_EV_IRQHandler+0xc6>
    else if (I2C_CHECK_FLAG(sr2itflags, I2C_FLAG_TRA) != RESET)
 8002400:	f017 0f04 	tst.w	r7, #4
 8002404:	d02f      	beq.n	8002466 <HAL_I2C_EV_IRQHandler+0xde>
      if (READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) != I2C_CR2_DMAEN)
 8002406:	6852      	ldr	r2, [r2, #4]
 8002408:	f412 6f00 	tst.w	r2, #2048	; 0x800
 800240c:	d1dc      	bne.n	80023c8 <HAL_I2C_EV_IRQHandler+0x40>
        if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_TXE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
 800240e:	f011 0f80 	tst.w	r1, #128	; 0x80
 8002412:	d005      	beq.n	8002420 <HAL_I2C_EV_IRQHandler+0x98>
 8002414:	f415 6f80 	tst.w	r5, #1024	; 0x400
 8002418:	d002      	beq.n	8002420 <HAL_I2C_EV_IRQHandler+0x98>
 800241a:	f011 0f04 	tst.w	r1, #4
 800241e:	d01a      	beq.n	8002456 <HAL_I2C_EV_IRQHandler+0xce>
        else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8002420:	f011 0f04 	tst.w	r1, #4
 8002424:	d0d0      	beq.n	80023c8 <HAL_I2C_EV_IRQHandler+0x40>
 8002426:	f415 7f00 	tst.w	r5, #512	; 0x200
 800242a:	d0cd      	beq.n	80023c8 <HAL_I2C_EV_IRQHandler+0x40>
          if (CurrentMode == HAL_I2C_MODE_MASTER)
 800242c:	2b10      	cmp	r3, #16
 800242e:	d016      	beq.n	800245e <HAL_I2C_EV_IRQHandler+0xd6>
            I2C_MemoryTransmit_TXE_BTF(hi2c);
 8002430:	4620      	mov	r0, r4
 8002432:	f7ff fbf4 	bl	8001c1e <I2C_MemoryTransmit_TXE_BTF>
 8002436:	e7c7      	b.n	80023c8 <HAL_I2C_EV_IRQHandler+0x40>
      I2C_ConvertOtherXferOptions(hi2c);
 8002438:	4620      	mov	r0, r4
 800243a:	f7ff f98d 	bl	8001758 <I2C_ConvertOtherXferOptions>
      I2C_Master_SB(hi2c);
 800243e:	4620      	mov	r0, r4
 8002440:	f7fe ffd0 	bl	80013e4 <I2C_Master_SB>
 8002444:	e7c0      	b.n	80023c8 <HAL_I2C_EV_IRQHandler+0x40>
      I2C_Master_ADD10(hi2c);
 8002446:	4620      	mov	r0, r4
 8002448:	f7ff f821 	bl	800148e <I2C_Master_ADD10>
 800244c:	e7bc      	b.n	80023c8 <HAL_I2C_EV_IRQHandler+0x40>
      I2C_Master_ADDR(hi2c);
 800244e:	4620      	mov	r0, r4
 8002450:	f7ff f834 	bl	80014bc <I2C_Master_ADDR>
 8002454:	e7b8      	b.n	80023c8 <HAL_I2C_EV_IRQHandler+0x40>
          I2C_MasterTransmit_TXE(hi2c);
 8002456:	4620      	mov	r0, r4
 8002458:	f7ff fc3c 	bl	8001cd4 <I2C_MasterTransmit_TXE>
 800245c:	e7b4      	b.n	80023c8 <HAL_I2C_EV_IRQHandler+0x40>
            I2C_MasterTransmit_BTF(hi2c);
 800245e:	4620      	mov	r0, r4
 8002460:	f7ff fad9 	bl	8001a16 <I2C_MasterTransmit_BTF>
 8002464:	e7b0      	b.n	80023c8 <HAL_I2C_EV_IRQHandler+0x40>
      if (READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) != I2C_CR2_DMAEN)
 8002466:	6853      	ldr	r3, [r2, #4]
 8002468:	f413 6f00 	tst.w	r3, #2048	; 0x800
 800246c:	d1ac      	bne.n	80023c8 <HAL_I2C_EV_IRQHandler+0x40>
        if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
 800246e:	f011 0f40 	tst.w	r1, #64	; 0x40
 8002472:	d005      	beq.n	8002480 <HAL_I2C_EV_IRQHandler+0xf8>
 8002474:	f415 6f80 	tst.w	r5, #1024	; 0x400
 8002478:	d002      	beq.n	8002480 <HAL_I2C_EV_IRQHandler+0xf8>
 800247a:	f011 0f04 	tst.w	r1, #4
 800247e:	d009      	beq.n	8002494 <HAL_I2C_EV_IRQHandler+0x10c>
        else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8002480:	f011 0f04 	tst.w	r1, #4
 8002484:	d0a0      	beq.n	80023c8 <HAL_I2C_EV_IRQHandler+0x40>
 8002486:	f415 7f00 	tst.w	r5, #512	; 0x200
 800248a:	d09d      	beq.n	80023c8 <HAL_I2C_EV_IRQHandler+0x40>
          I2C_MasterReceive_BTF(hi2c);
 800248c:	4620      	mov	r0, r4
 800248e:	f7ff fc89 	bl	8001da4 <I2C_MasterReceive_BTF>
 8002492:	e799      	b.n	80023c8 <HAL_I2C_EV_IRQHandler+0x40>
          I2C_MasterReceive_RXNE(hi2c);
 8002494:	4620      	mov	r0, r4
 8002496:	f7ff fd15 	bl	8001ec4 <I2C_MasterReceive_RXNE>
 800249a:	e795      	b.n	80023c8 <HAL_I2C_EV_IRQHandler+0x40>
      sr2itflags   = READ_REG(hi2c->Instance->SR2);
 800249c:	6991      	ldr	r1, [r2, #24]
      sr1itflags   = READ_REG(hi2c->Instance->SR1);
 800249e:	6953      	ldr	r3, [r2, #20]
 80024a0:	e786      	b.n	80023b0 <HAL_I2C_EV_IRQHandler+0x28>
    else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 80024a2:	f013 0f10 	tst.w	r3, #16
 80024a6:	d002      	beq.n	80024ae <HAL_I2C_EV_IRQHandler+0x126>
 80024a8:	f415 7f00 	tst.w	r5, #512	; 0x200
 80024ac:	d118      	bne.n	80024e0 <HAL_I2C_EV_IRQHandler+0x158>
    else if ((CurrentState == HAL_I2C_STATE_BUSY_TX) || (CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN))
 80024ae:	2821      	cmp	r0, #33	; 0x21
 80024b0:	d01a      	beq.n	80024e8 <HAL_I2C_EV_IRQHandler+0x160>
 80024b2:	2829      	cmp	r0, #41	; 0x29
 80024b4:	d018      	beq.n	80024e8 <HAL_I2C_EV_IRQHandler+0x160>
      if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
 80024b6:	f013 0f40 	tst.w	r3, #64	; 0x40
 80024ba:	d005      	beq.n	80024c8 <HAL_I2C_EV_IRQHandler+0x140>
 80024bc:	f415 6f80 	tst.w	r5, #1024	; 0x400
 80024c0:	d002      	beq.n	80024c8 <HAL_I2C_EV_IRQHandler+0x140>
 80024c2:	f013 0f04 	tst.w	r3, #4
 80024c6:	d028      	beq.n	800251a <HAL_I2C_EV_IRQHandler+0x192>
      else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 80024c8:	f013 0f04 	tst.w	r3, #4
 80024cc:	f43f af7c 	beq.w	80023c8 <HAL_I2C_EV_IRQHandler+0x40>
 80024d0:	f415 7f00 	tst.w	r5, #512	; 0x200
 80024d4:	f43f af78 	beq.w	80023c8 <HAL_I2C_EV_IRQHandler+0x40>
        I2C_SlaveReceive_BTF(hi2c);
 80024d8:	4620      	mov	r0, r4
 80024da:	f7ff f909 	bl	80016f0 <I2C_SlaveReceive_BTF>
 80024de:	e773      	b.n	80023c8 <HAL_I2C_EV_IRQHandler+0x40>
      I2C_Slave_STOPF(hi2c);
 80024e0:	4620      	mov	r0, r4
 80024e2:	f7ff fe8d 	bl	8002200 <I2C_Slave_STOPF>
 80024e6:	e76f      	b.n	80023c8 <HAL_I2C_EV_IRQHandler+0x40>
      if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_TXE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
 80024e8:	f013 0f80 	tst.w	r3, #128	; 0x80
 80024ec:	d005      	beq.n	80024fa <HAL_I2C_EV_IRQHandler+0x172>
 80024ee:	f415 6f80 	tst.w	r5, #1024	; 0x400
 80024f2:	d002      	beq.n	80024fa <HAL_I2C_EV_IRQHandler+0x172>
 80024f4:	f013 0f04 	tst.w	r3, #4
 80024f8:	d00b      	beq.n	8002512 <HAL_I2C_EV_IRQHandler+0x18a>
      else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 80024fa:	f013 0f04 	tst.w	r3, #4
 80024fe:	f43f af63 	beq.w	80023c8 <HAL_I2C_EV_IRQHandler+0x40>
 8002502:	f415 7f00 	tst.w	r5, #512	; 0x200
 8002506:	f43f af5f 	beq.w	80023c8 <HAL_I2C_EV_IRQHandler+0x40>
        I2C_SlaveTransmit_BTF(hi2c);
 800250a:	4620      	mov	r0, r4
 800250c:	f7ff f8e1 	bl	80016d2 <I2C_SlaveTransmit_BTF>
 8002510:	e75a      	b.n	80023c8 <HAL_I2C_EV_IRQHandler+0x40>
        I2C_SlaveTransmit_TXE(hi2c);
 8002512:	4620      	mov	r0, r4
 8002514:	f7ff fac3 	bl	8001a9e <I2C_SlaveTransmit_TXE>
 8002518:	e756      	b.n	80023c8 <HAL_I2C_EV_IRQHandler+0x40>
        I2C_SlaveReceive_RXNE(hi2c);
 800251a:	4620      	mov	r0, r4
 800251c:	f7ff fae5 	bl	8001aea <I2C_SlaveReceive_RXNE>
 8002520:	e752      	b.n	80023c8 <HAL_I2C_EV_IRQHandler+0x40>

08002522 <HAL_I2C_ER_IRQHandler>:
{
 8002522:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002524:	4604      	mov	r4, r0
  uint32_t sr1itflags = READ_REG(hi2c->Instance->SR1);
 8002526:	6803      	ldr	r3, [r0, #0]
 8002528:	695d      	ldr	r5, [r3, #20]
  uint32_t itsources  = READ_REG(hi2c->Instance->CR2);
 800252a:	685f      	ldr	r7, [r3, #4]
  HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
 800252c:	f890 203e 	ldrb.w	r2, [r0, #62]	; 0x3e
 8002530:	b2d2      	uxtb	r2, r2
  if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BERR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
 8002532:	f415 7f80 	tst.w	r5, #256	; 0x100
 8002536:	d00c      	beq.n	8002552 <HAL_I2C_ER_IRQHandler+0x30>
 8002538:	f417 7f80 	tst.w	r7, #256	; 0x100
 800253c:	d041      	beq.n	80025c2 <HAL_I2C_ER_IRQHandler+0xa0>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 800253e:	f46f 7180 	mvn.w	r1, #256	; 0x100
 8002542:	6159      	str	r1, [r3, #20]
    SET_BIT(hi2c->Instance->CR1, I2C_CR1_SWRST);
 8002544:	6801      	ldr	r1, [r0, #0]
 8002546:	680b      	ldr	r3, [r1, #0]
 8002548:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800254c:	600b      	str	r3, [r1, #0]
    error |= HAL_I2C_ERROR_BERR;
 800254e:	2601      	movs	r6, #1
 8002550:	e000      	b.n	8002554 <HAL_I2C_ER_IRQHandler+0x32>
  uint32_t error      = HAL_I2C_ERROR_NONE;
 8002552:	2600      	movs	r6, #0
  if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ARLO) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
 8002554:	f415 7f00 	tst.w	r5, #512	; 0x200
 8002558:	d008      	beq.n	800256c <HAL_I2C_ER_IRQHandler+0x4a>
 800255a:	f417 7f80 	tst.w	r7, #256	; 0x100
 800255e:	d005      	beq.n	800256c <HAL_I2C_ER_IRQHandler+0x4a>
    error |= HAL_I2C_ERROR_ARLO;
 8002560:	f046 0602 	orr.w	r6, r6, #2
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 8002564:	6823      	ldr	r3, [r4, #0]
 8002566:	f46f 7100 	mvn.w	r1, #512	; 0x200
 800256a:	6159      	str	r1, [r3, #20]
  if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
 800256c:	f415 6f80 	tst.w	r5, #1024	; 0x400
 8002570:	d019      	beq.n	80025a6 <HAL_I2C_ER_IRQHandler+0x84>
 8002572:	f417 7f80 	tst.w	r7, #256	; 0x100
 8002576:	d016      	beq.n	80025a6 <HAL_I2C_ER_IRQHandler+0x84>
    tmp2 = hi2c->XferCount;
 8002578:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800257a:	b299      	uxth	r1, r3
    tmp3 = hi2c->State;
 800257c:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
 8002580:	b2db      	uxtb	r3, r3
    tmp4 = hi2c->PreviousState;
 8002582:	6b20      	ldr	r0, [r4, #48]	; 0x30
    if ((tmp1 == HAL_I2C_MODE_SLAVE) && (tmp2 == 0U) && \
 8002584:	2a20      	cmp	r2, #32
 8002586:	d01e      	beq.n	80025c6 <HAL_I2C_ER_IRQHandler+0xa4>
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8002588:	6823      	ldr	r3, [r4, #0]
 800258a:	f46f 6180 	mvn.w	r1, #1024	; 0x400
 800258e:	6159      	str	r1, [r3, #20]
      error |= HAL_I2C_ERROR_AF;
 8002590:	f046 0604 	orr.w	r6, r6, #4
      if ((CurrentMode == HAL_I2C_MODE_MASTER) || (CurrentMode == HAL_I2C_MODE_MEM))
 8002594:	2a10      	cmp	r2, #16
 8002596:	d001      	beq.n	800259c <HAL_I2C_ER_IRQHandler+0x7a>
 8002598:	2a40      	cmp	r2, #64	; 0x40
 800259a:	d104      	bne.n	80025a6 <HAL_I2C_ER_IRQHandler+0x84>
        SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 800259c:	6822      	ldr	r2, [r4, #0]
 800259e:	6813      	ldr	r3, [r2, #0]
 80025a0:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80025a4:	6013      	str	r3, [r2, #0]
  if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_OVR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
 80025a6:	f415 6f00 	tst.w	r5, #2048	; 0x800
 80025aa:	d008      	beq.n	80025be <HAL_I2C_ER_IRQHandler+0x9c>
 80025ac:	f417 7f80 	tst.w	r7, #256	; 0x100
 80025b0:	d005      	beq.n	80025be <HAL_I2C_ER_IRQHandler+0x9c>
    error |= HAL_I2C_ERROR_OVR;
 80025b2:	f046 0608 	orr.w	r6, r6, #8
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 80025b6:	6823      	ldr	r3, [r4, #0]
 80025b8:	f46f 6200 	mvn.w	r2, #2048	; 0x800
 80025bc:	615a      	str	r2, [r3, #20]
  if (error != HAL_I2C_ERROR_NONE)
 80025be:	b986      	cbnz	r6, 80025e2 <HAL_I2C_ER_IRQHandler+0xc0>
}
 80025c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  uint32_t error      = HAL_I2C_ERROR_NONE;
 80025c2:	2600      	movs	r6, #0
 80025c4:	e7c6      	b.n	8002554 <HAL_I2C_ER_IRQHandler+0x32>
    if ((tmp1 == HAL_I2C_MODE_SLAVE) && (tmp2 == 0U) && \
 80025c6:	2900      	cmp	r1, #0
 80025c8:	d1de      	bne.n	8002588 <HAL_I2C_ER_IRQHandler+0x66>
 80025ca:	2b21      	cmp	r3, #33	; 0x21
 80025cc:	d005      	beq.n	80025da <HAL_I2C_ER_IRQHandler+0xb8>
        ((tmp3 == HAL_I2C_STATE_BUSY_TX) || (tmp3 == HAL_I2C_STATE_BUSY_TX_LISTEN) || \
 80025ce:	2b29      	cmp	r3, #41	; 0x29
 80025d0:	d003      	beq.n	80025da <HAL_I2C_ER_IRQHandler+0xb8>
 80025d2:	2b28      	cmp	r3, #40	; 0x28
 80025d4:	d1d8      	bne.n	8002588 <HAL_I2C_ER_IRQHandler+0x66>
         ((tmp3 == HAL_I2C_STATE_LISTEN) && (tmp4 == I2C_STATE_SLAVE_BUSY_TX))))
 80025d6:	2821      	cmp	r0, #33	; 0x21
 80025d8:	d1d6      	bne.n	8002588 <HAL_I2C_ER_IRQHandler+0x66>
      I2C_Slave_AF(hi2c);
 80025da:	4620      	mov	r0, r4
 80025dc:	f7ff fad4 	bl	8001b88 <I2C_Slave_AF>
 80025e0:	e7e1      	b.n	80025a6 <HAL_I2C_ER_IRQHandler+0x84>
    hi2c->ErrorCode |= error;
 80025e2:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80025e4:	431e      	orrs	r6, r3
 80025e6:	6426      	str	r6, [r4, #64]	; 0x40
    I2C_ITError(hi2c);
 80025e8:	4620      	mov	r0, r4
 80025ea:	f7ff fd4f 	bl	800208c <I2C_ITError>
}
 80025ee:	e7e7      	b.n	80025c0 <HAL_I2C_ER_IRQHandler+0x9e>

080025f0 <RCC_Delay>:
  * @brief  This function provides delay (in milliseconds) based on CPU cycles method.
  * @param  mdelay: specifies the delay time length, in milliseconds.
  * @retval None
  */
static void RCC_Delay(uint32_t mdelay)
{
 80025f0:	b082      	sub	sp, #8
  __IO uint32_t Delay = mdelay * (SystemCoreClock / 8U / 1000U);
 80025f2:	4b08      	ldr	r3, [pc, #32]	; (8002614 <RCC_Delay+0x24>)
 80025f4:	681b      	ldr	r3, [r3, #0]
 80025f6:	4a08      	ldr	r2, [pc, #32]	; (8002618 <RCC_Delay+0x28>)
 80025f8:	fba2 2303 	umull	r2, r3, r2, r3
 80025fc:	0a5b      	lsrs	r3, r3, #9
 80025fe:	fb00 f003 	mul.w	r0, r0, r3
 8002602:	9001      	str	r0, [sp, #4]
  do
  {
    __NOP();
 8002604:	bf00      	nop
  }
  while (Delay --);
 8002606:	9b01      	ldr	r3, [sp, #4]
 8002608:	1e5a      	subs	r2, r3, #1
 800260a:	9201      	str	r2, [sp, #4]
 800260c:	2b00      	cmp	r3, #0
 800260e:	d1f9      	bne.n	8002604 <RCC_Delay+0x14>
}
 8002610:	b002      	add	sp, #8
 8002612:	4770      	bx	lr
 8002614:	2000000c 	.word	0x2000000c
 8002618:	10624dd3 	.word	0x10624dd3

0800261c <HAL_RCC_OscConfig>:
  if (RCC_OscInitStruct == NULL)
 800261c:	2800      	cmp	r0, #0
 800261e:	f000 828c 	beq.w	8002b3a <HAL_RCC_OscConfig+0x51e>
{
 8002622:	b570      	push	{r4, r5, r6, lr}
 8002624:	b082      	sub	sp, #8
 8002626:	4604      	mov	r4, r0
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
 8002628:	6803      	ldr	r3, [r0, #0]
 800262a:	b113      	cbz	r3, 8002632 <HAL_RCC_OscConfig+0x16>
 800262c:	f013 0f0f 	tst.w	r3, #15
 8002630:	d02a      	beq.n	8002688 <HAL_RCC_OscConfig+0x6c>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8002632:	6823      	ldr	r3, [r4, #0]
 8002634:	f013 0f01 	tst.w	r3, #1
 8002638:	d040      	beq.n	80026bc <HAL_RCC_OscConfig+0xa0>
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
 800263a:	6863      	ldr	r3, [r4, #4]
 800263c:	b12b      	cbz	r3, 800264a <HAL_RCC_OscConfig+0x2e>
 800263e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8002642:	d002      	beq.n	800264a <HAL_RCC_OscConfig+0x2e>
 8002644:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8002648:	d124      	bne.n	8002694 <HAL_RCC_OscConfig+0x78>
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE)
 800264a:	4ba9      	ldr	r3, [pc, #676]	; (80028f0 <HAL_RCC_OscConfig+0x2d4>)
 800264c:	685b      	ldr	r3, [r3, #4]
 800264e:	f003 030c 	and.w	r3, r3, #12
 8002652:	2b04      	cmp	r3, #4
 8002654:	d029      	beq.n	80026aa <HAL_RCC_OscConfig+0x8e>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 8002656:	4ba6      	ldr	r3, [pc, #664]	; (80028f0 <HAL_RCC_OscConfig+0x2d4>)
 8002658:	685b      	ldr	r3, [r3, #4]
 800265a:	f003 030c 	and.w	r3, r3, #12
 800265e:	2b08      	cmp	r3, #8
 8002660:	d01e      	beq.n	80026a0 <HAL_RCC_OscConfig+0x84>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8002662:	6863      	ldr	r3, [r4, #4]
 8002664:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8002668:	d055      	beq.n	8002716 <HAL_RCC_OscConfig+0xfa>
 800266a:	2b00      	cmp	r3, #0
 800266c:	d169      	bne.n	8002742 <HAL_RCC_OscConfig+0x126>
 800266e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8002672:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
 8002676:	681a      	ldr	r2, [r3, #0]
 8002678:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800267c:	601a      	str	r2, [r3, #0]
 800267e:	681a      	ldr	r2, [r3, #0]
 8002680:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8002684:	601a      	str	r2, [r3, #0]
 8002686:	e04b      	b.n	8002720 <HAL_RCC_OscConfig+0x104>
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
 8002688:	f240 1167 	movw	r1, #359	; 0x167
 800268c:	4899      	ldr	r0, [pc, #612]	; (80028f4 <HAL_RCC_OscConfig+0x2d8>)
 800268e:	f003 f823 	bl	80056d8 <assert_failed>
 8002692:	e7ce      	b.n	8002632 <HAL_RCC_OscConfig+0x16>
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
 8002694:	f240 116d 	movw	r1, #365	; 0x16d
 8002698:	4896      	ldr	r0, [pc, #600]	; (80028f4 <HAL_RCC_OscConfig+0x2d8>)
 800269a:	f003 f81d 	bl	80056d8 <assert_failed>
 800269e:	e7d4      	b.n	800264a <HAL_RCC_OscConfig+0x2e>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 80026a0:	4b93      	ldr	r3, [pc, #588]	; (80028f0 <HAL_RCC_OscConfig+0x2d4>)
 80026a2:	685b      	ldr	r3, [r3, #4]
 80026a4:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 80026a8:	d0db      	beq.n	8002662 <HAL_RCC_OscConfig+0x46>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80026aa:	4b91      	ldr	r3, [pc, #580]	; (80028f0 <HAL_RCC_OscConfig+0x2d4>)
 80026ac:	681b      	ldr	r3, [r3, #0]
 80026ae:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 80026b2:	d003      	beq.n	80026bc <HAL_RCC_OscConfig+0xa0>
 80026b4:	6863      	ldr	r3, [r4, #4]
 80026b6:	2b00      	cmp	r3, #0
 80026b8:	f000 8241 	beq.w	8002b3e <HAL_RCC_OscConfig+0x522>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80026bc:	6823      	ldr	r3, [r4, #0]
 80026be:	f013 0f02 	tst.w	r3, #2
 80026c2:	f000 808a 	beq.w	80027da <HAL_RCC_OscConfig+0x1be>
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
 80026c6:	6923      	ldr	r3, [r4, #16]
 80026c8:	2b01      	cmp	r3, #1
 80026ca:	d863      	bhi.n	8002794 <HAL_RCC_OscConfig+0x178>
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
 80026cc:	6963      	ldr	r3, [r4, #20]
 80026ce:	2b1f      	cmp	r3, #31
 80026d0:	d866      	bhi.n	80027a0 <HAL_RCC_OscConfig+0x184>
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
 80026d2:	4b87      	ldr	r3, [pc, #540]	; (80028f0 <HAL_RCC_OscConfig+0x2d4>)
 80026d4:	685b      	ldr	r3, [r3, #4]
 80026d6:	f013 0f0c 	tst.w	r3, #12
 80026da:	d06c      	beq.n	80027b6 <HAL_RCC_OscConfig+0x19a>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI_DIV2)))
 80026dc:	4b84      	ldr	r3, [pc, #528]	; (80028f0 <HAL_RCC_OscConfig+0x2d4>)
 80026de:	685b      	ldr	r3, [r3, #4]
 80026e0:	f003 030c 	and.w	r3, r3, #12
 80026e4:	2b08      	cmp	r3, #8
 80026e6:	d061      	beq.n	80027ac <HAL_RCC_OscConfig+0x190>
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 80026e8:	6923      	ldr	r3, [r4, #16]
 80026ea:	2b00      	cmp	r3, #0
 80026ec:	f000 809a 	beq.w	8002824 <HAL_RCC_OscConfig+0x208>
        __HAL_RCC_HSI_ENABLE();
 80026f0:	4b81      	ldr	r3, [pc, #516]	; (80028f8 <HAL_RCC_OscConfig+0x2dc>)
 80026f2:	2201      	movs	r2, #1
 80026f4:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80026f6:	f7fe f8d1 	bl	800089c <HAL_GetTick>
 80026fa:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80026fc:	4b7c      	ldr	r3, [pc, #496]	; (80028f0 <HAL_RCC_OscConfig+0x2d4>)
 80026fe:	681b      	ldr	r3, [r3, #0]
 8002700:	f013 0f02 	tst.w	r3, #2
 8002704:	f040 8085 	bne.w	8002812 <HAL_RCC_OscConfig+0x1f6>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8002708:	f7fe f8c8 	bl	800089c <HAL_GetTick>
 800270c:	1b40      	subs	r0, r0, r5
 800270e:	2802      	cmp	r0, #2
 8002710:	d9f4      	bls.n	80026fc <HAL_RCC_OscConfig+0xe0>
            return HAL_TIMEOUT;
 8002712:	2003      	movs	r0, #3
 8002714:	e216      	b.n	8002b44 <HAL_RCC_OscConfig+0x528>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8002716:	4a76      	ldr	r2, [pc, #472]	; (80028f0 <HAL_RCC_OscConfig+0x2d4>)
 8002718:	6813      	ldr	r3, [r2, #0]
 800271a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800271e:	6013      	str	r3, [r2, #0]
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8002720:	6863      	ldr	r3, [r4, #4]
 8002722:	b343      	cbz	r3, 8002776 <HAL_RCC_OscConfig+0x15a>
        tickstart = HAL_GetTick();
 8002724:	f7fe f8ba 	bl	800089c <HAL_GetTick>
 8002728:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800272a:	4b71      	ldr	r3, [pc, #452]	; (80028f0 <HAL_RCC_OscConfig+0x2d4>)
 800272c:	681b      	ldr	r3, [r3, #0]
 800272e:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8002732:	d1c3      	bne.n	80026bc <HAL_RCC_OscConfig+0xa0>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8002734:	f7fe f8b2 	bl	800089c <HAL_GetTick>
 8002738:	1b40      	subs	r0, r0, r5
 800273a:	2864      	cmp	r0, #100	; 0x64
 800273c:	d9f5      	bls.n	800272a <HAL_RCC_OscConfig+0x10e>
            return HAL_TIMEOUT;
 800273e:	2003      	movs	r0, #3
 8002740:	e200      	b.n	8002b44 <HAL_RCC_OscConfig+0x528>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8002742:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8002746:	d009      	beq.n	800275c <HAL_RCC_OscConfig+0x140>
 8002748:	4b69      	ldr	r3, [pc, #420]	; (80028f0 <HAL_RCC_OscConfig+0x2d4>)
 800274a:	681a      	ldr	r2, [r3, #0]
 800274c:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8002750:	601a      	str	r2, [r3, #0]
 8002752:	681a      	ldr	r2, [r3, #0]
 8002754:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8002758:	601a      	str	r2, [r3, #0]
 800275a:	e7e1      	b.n	8002720 <HAL_RCC_OscConfig+0x104>
 800275c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8002760:	f5a3 333c 	sub.w	r3, r3, #192512	; 0x2f000
 8002764:	681a      	ldr	r2, [r3, #0]
 8002766:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 800276a:	601a      	str	r2, [r3, #0]
 800276c:	681a      	ldr	r2, [r3, #0]
 800276e:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8002772:	601a      	str	r2, [r3, #0]
 8002774:	e7d4      	b.n	8002720 <HAL_RCC_OscConfig+0x104>
        tickstart = HAL_GetTick();
 8002776:	f7fe f891 	bl	800089c <HAL_GetTick>
 800277a:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800277c:	4b5c      	ldr	r3, [pc, #368]	; (80028f0 <HAL_RCC_OscConfig+0x2d4>)
 800277e:	681b      	ldr	r3, [r3, #0]
 8002780:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8002784:	d09a      	beq.n	80026bc <HAL_RCC_OscConfig+0xa0>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8002786:	f7fe f889 	bl	800089c <HAL_GetTick>
 800278a:	1b40      	subs	r0, r0, r5
 800278c:	2864      	cmp	r0, #100	; 0x64
 800278e:	d9f5      	bls.n	800277c <HAL_RCC_OscConfig+0x160>
            return HAL_TIMEOUT;
 8002790:	2003      	movs	r0, #3
 8002792:	e1d7      	b.n	8002b44 <HAL_RCC_OscConfig+0x528>
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
 8002794:	f240 11a1 	movw	r1, #417	; 0x1a1
 8002798:	4856      	ldr	r0, [pc, #344]	; (80028f4 <HAL_RCC_OscConfig+0x2d8>)
 800279a:	f002 ff9d 	bl	80056d8 <assert_failed>
 800279e:	e795      	b.n	80026cc <HAL_RCC_OscConfig+0xb0>
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
 80027a0:	f44f 71d1 	mov.w	r1, #418	; 0x1a2
 80027a4:	4853      	ldr	r0, [pc, #332]	; (80028f4 <HAL_RCC_OscConfig+0x2d8>)
 80027a6:	f002 ff97 	bl	80056d8 <assert_failed>
 80027aa:	e792      	b.n	80026d2 <HAL_RCC_OscConfig+0xb6>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI_DIV2)))
 80027ac:	4b50      	ldr	r3, [pc, #320]	; (80028f0 <HAL_RCC_OscConfig+0x2d4>)
 80027ae:	685b      	ldr	r3, [r3, #4]
 80027b0:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 80027b4:	d198      	bne.n	80026e8 <HAL_RCC_OscConfig+0xcc>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80027b6:	4b4e      	ldr	r3, [pc, #312]	; (80028f0 <HAL_RCC_OscConfig+0x2d4>)
 80027b8:	681b      	ldr	r3, [r3, #0]
 80027ba:	f013 0f02 	tst.w	r3, #2
 80027be:	d004      	beq.n	80027ca <HAL_RCC_OscConfig+0x1ae>
 80027c0:	6923      	ldr	r3, [r4, #16]
 80027c2:	2b01      	cmp	r3, #1
 80027c4:	d001      	beq.n	80027ca <HAL_RCC_OscConfig+0x1ae>
        return HAL_ERROR;
 80027c6:	2001      	movs	r0, #1
 80027c8:	e1bc      	b.n	8002b44 <HAL_RCC_OscConfig+0x528>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80027ca:	4a49      	ldr	r2, [pc, #292]	; (80028f0 <HAL_RCC_OscConfig+0x2d4>)
 80027cc:	6813      	ldr	r3, [r2, #0]
 80027ce:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 80027d2:	6961      	ldr	r1, [r4, #20]
 80027d4:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 80027d8:	6013      	str	r3, [r2, #0]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80027da:	6823      	ldr	r3, [r4, #0]
 80027dc:	f013 0f08 	tst.w	r3, #8
 80027e0:	d03b      	beq.n	800285a <HAL_RCC_OscConfig+0x23e>
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
 80027e2:	69a3      	ldr	r3, [r4, #24]
 80027e4:	2b01      	cmp	r3, #1
 80027e6:	d82f      	bhi.n	8002848 <HAL_RCC_OscConfig+0x22c>
    if (RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 80027e8:	69a3      	ldr	r3, [r4, #24]
 80027ea:	2b00      	cmp	r3, #0
 80027ec:	d066      	beq.n	80028bc <HAL_RCC_OscConfig+0x2a0>
      __HAL_RCC_LSI_ENABLE();
 80027ee:	4b43      	ldr	r3, [pc, #268]	; (80028fc <HAL_RCC_OscConfig+0x2e0>)
 80027f0:	2201      	movs	r2, #1
 80027f2:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 80027f4:	f7fe f852 	bl	800089c <HAL_GetTick>
 80027f8:	4605      	mov	r5, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80027fa:	4b3d      	ldr	r3, [pc, #244]	; (80028f0 <HAL_RCC_OscConfig+0x2d4>)
 80027fc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80027fe:	f013 0f02 	tst.w	r3, #2
 8002802:	d127      	bne.n	8002854 <HAL_RCC_OscConfig+0x238>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8002804:	f7fe f84a 	bl	800089c <HAL_GetTick>
 8002808:	1b40      	subs	r0, r0, r5
 800280a:	2802      	cmp	r0, #2
 800280c:	d9f5      	bls.n	80027fa <HAL_RCC_OscConfig+0x1de>
          return HAL_TIMEOUT;
 800280e:	2003      	movs	r0, #3
 8002810:	e198      	b.n	8002b44 <HAL_RCC_OscConfig+0x528>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8002812:	4a37      	ldr	r2, [pc, #220]	; (80028f0 <HAL_RCC_OscConfig+0x2d4>)
 8002814:	6813      	ldr	r3, [r2, #0]
 8002816:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 800281a:	6961      	ldr	r1, [r4, #20]
 800281c:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8002820:	6013      	str	r3, [r2, #0]
 8002822:	e7da      	b.n	80027da <HAL_RCC_OscConfig+0x1be>
        __HAL_RCC_HSI_DISABLE();
 8002824:	4b34      	ldr	r3, [pc, #208]	; (80028f8 <HAL_RCC_OscConfig+0x2dc>)
 8002826:	2200      	movs	r2, #0
 8002828:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 800282a:	f7fe f837 	bl	800089c <HAL_GetTick>
 800282e:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8002830:	4b2f      	ldr	r3, [pc, #188]	; (80028f0 <HAL_RCC_OscConfig+0x2d4>)
 8002832:	681b      	ldr	r3, [r3, #0]
 8002834:	f013 0f02 	tst.w	r3, #2
 8002838:	d0cf      	beq.n	80027da <HAL_RCC_OscConfig+0x1be>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 800283a:	f7fe f82f 	bl	800089c <HAL_GetTick>
 800283e:	1b40      	subs	r0, r0, r5
 8002840:	2802      	cmp	r0, #2
 8002842:	d9f5      	bls.n	8002830 <HAL_RCC_OscConfig+0x214>
            return HAL_TIMEOUT;
 8002844:	2003      	movs	r0, #3
 8002846:	e17d      	b.n	8002b44 <HAL_RCC_OscConfig+0x528>
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
 8002848:	f44f 71f1 	mov.w	r1, #482	; 0x1e2
 800284c:	4829      	ldr	r0, [pc, #164]	; (80028f4 <HAL_RCC_OscConfig+0x2d8>)
 800284e:	f002 ff43 	bl	80056d8 <assert_failed>
 8002852:	e7c9      	b.n	80027e8 <HAL_RCC_OscConfig+0x1cc>
      RCC_Delay(1);
 8002854:	2001      	movs	r0, #1
 8002856:	f7ff fecb 	bl	80025f0 <RCC_Delay>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800285a:	6823      	ldr	r3, [r4, #0]
 800285c:	f013 0f04 	tst.w	r3, #4
 8002860:	f000 80a5 	beq.w	80029ae <HAL_RCC_OscConfig+0x392>
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
 8002864:	68e3      	ldr	r3, [r4, #12]
 8002866:	2b01      	cmp	r3, #1
 8002868:	d901      	bls.n	800286e <HAL_RCC_OscConfig+0x252>
 800286a:	2b05      	cmp	r3, #5
 800286c:	d138      	bne.n	80028e0 <HAL_RCC_OscConfig+0x2c4>
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 800286e:	4b20      	ldr	r3, [pc, #128]	; (80028f0 <HAL_RCC_OscConfig+0x2d4>)
 8002870:	69db      	ldr	r3, [r3, #28]
 8002872:	f013 5f80 	tst.w	r3, #268435456	; 0x10000000
 8002876:	d139      	bne.n	80028ec <HAL_RCC_OscConfig+0x2d0>
      __HAL_RCC_PWR_CLK_ENABLE();
 8002878:	4b1d      	ldr	r3, [pc, #116]	; (80028f0 <HAL_RCC_OscConfig+0x2d4>)
 800287a:	69da      	ldr	r2, [r3, #28]
 800287c:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8002880:	61da      	str	r2, [r3, #28]
 8002882:	69db      	ldr	r3, [r3, #28]
 8002884:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8002888:	9301      	str	r3, [sp, #4]
 800288a:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 800288c:	2501      	movs	r5, #1
    if (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800288e:	4b1c      	ldr	r3, [pc, #112]	; (8002900 <HAL_RCC_OscConfig+0x2e4>)
 8002890:	681b      	ldr	r3, [r3, #0]
 8002892:	f413 7f80 	tst.w	r3, #256	; 0x100
 8002896:	d035      	beq.n	8002904 <HAL_RCC_OscConfig+0x2e8>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8002898:	68e3      	ldr	r3, [r4, #12]
 800289a:	2b01      	cmp	r3, #1
 800289c:	d046      	beq.n	800292c <HAL_RCC_OscConfig+0x310>
 800289e:	2b00      	cmp	r3, #0
 80028a0:	d15c      	bne.n	800295c <HAL_RCC_OscConfig+0x340>
 80028a2:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80028a6:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
 80028aa:	6a1a      	ldr	r2, [r3, #32]
 80028ac:	f022 0201 	bic.w	r2, r2, #1
 80028b0:	621a      	str	r2, [r3, #32]
 80028b2:	6a1a      	ldr	r2, [r3, #32]
 80028b4:	f022 0204 	bic.w	r2, r2, #4
 80028b8:	621a      	str	r2, [r3, #32]
 80028ba:	e03c      	b.n	8002936 <HAL_RCC_OscConfig+0x31a>
      __HAL_RCC_LSI_DISABLE();
 80028bc:	4b0f      	ldr	r3, [pc, #60]	; (80028fc <HAL_RCC_OscConfig+0x2e0>)
 80028be:	2200      	movs	r2, #0
 80028c0:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 80028c2:	f7fd ffeb 	bl	800089c <HAL_GetTick>
 80028c6:	4605      	mov	r5, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80028c8:	4b09      	ldr	r3, [pc, #36]	; (80028f0 <HAL_RCC_OscConfig+0x2d4>)
 80028ca:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80028cc:	f013 0f02 	tst.w	r3, #2
 80028d0:	d0c3      	beq.n	800285a <HAL_RCC_OscConfig+0x23e>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 80028d2:	f7fd ffe3 	bl	800089c <HAL_GetTick>
 80028d6:	1b40      	subs	r0, r0, r5
 80028d8:	2802      	cmp	r0, #2
 80028da:	d9f5      	bls.n	80028c8 <HAL_RCC_OscConfig+0x2ac>
          return HAL_TIMEOUT;
 80028dc:	2003      	movs	r0, #3
 80028de:	e131      	b.n	8002b44 <HAL_RCC_OscConfig+0x528>
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
 80028e0:	f240 2111 	movw	r1, #529	; 0x211
 80028e4:	4803      	ldr	r0, [pc, #12]	; (80028f4 <HAL_RCC_OscConfig+0x2d8>)
 80028e6:	f002 fef7 	bl	80056d8 <assert_failed>
 80028ea:	e7c0      	b.n	800286e <HAL_RCC_OscConfig+0x252>
    FlagStatus       pwrclkchanged = RESET;
 80028ec:	2500      	movs	r5, #0
 80028ee:	e7ce      	b.n	800288e <HAL_RCC_OscConfig+0x272>
 80028f0:	40021000 	.word	0x40021000
 80028f4:	08005e14 	.word	0x08005e14
 80028f8:	42420000 	.word	0x42420000
 80028fc:	42420480 	.word	0x42420480
 8002900:	40007000 	.word	0x40007000
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8002904:	4a92      	ldr	r2, [pc, #584]	; (8002b50 <HAL_RCC_OscConfig+0x534>)
 8002906:	6813      	ldr	r3, [r2, #0]
 8002908:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800290c:	6013      	str	r3, [r2, #0]
      tickstart = HAL_GetTick();
 800290e:	f7fd ffc5 	bl	800089c <HAL_GetTick>
 8002912:	4606      	mov	r6, r0
      while (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8002914:	4b8e      	ldr	r3, [pc, #568]	; (8002b50 <HAL_RCC_OscConfig+0x534>)
 8002916:	681b      	ldr	r3, [r3, #0]
 8002918:	f413 7f80 	tst.w	r3, #256	; 0x100
 800291c:	d1bc      	bne.n	8002898 <HAL_RCC_OscConfig+0x27c>
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800291e:	f7fd ffbd 	bl	800089c <HAL_GetTick>
 8002922:	1b80      	subs	r0, r0, r6
 8002924:	2864      	cmp	r0, #100	; 0x64
 8002926:	d9f5      	bls.n	8002914 <HAL_RCC_OscConfig+0x2f8>
          return HAL_TIMEOUT;
 8002928:	2003      	movs	r0, #3
 800292a:	e10b      	b.n	8002b44 <HAL_RCC_OscConfig+0x528>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800292c:	4a89      	ldr	r2, [pc, #548]	; (8002b54 <HAL_RCC_OscConfig+0x538>)
 800292e:	6a13      	ldr	r3, [r2, #32]
 8002930:	f043 0301 	orr.w	r3, r3, #1
 8002934:	6213      	str	r3, [r2, #32]
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 8002936:	68e3      	ldr	r3, [r4, #12]
 8002938:	b333      	cbz	r3, 8002988 <HAL_RCC_OscConfig+0x36c>
      tickstart = HAL_GetTick();
 800293a:	f7fd ffaf 	bl	800089c <HAL_GetTick>
 800293e:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8002940:	4b84      	ldr	r3, [pc, #528]	; (8002b54 <HAL_RCC_OscConfig+0x538>)
 8002942:	6a1b      	ldr	r3, [r3, #32]
 8002944:	f013 0f02 	tst.w	r3, #2
 8002948:	d12f      	bne.n	80029aa <HAL_RCC_OscConfig+0x38e>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800294a:	f7fd ffa7 	bl	800089c <HAL_GetTick>
 800294e:	1b80      	subs	r0, r0, r6
 8002950:	f241 3388 	movw	r3, #5000	; 0x1388
 8002954:	4298      	cmp	r0, r3
 8002956:	d9f3      	bls.n	8002940 <HAL_RCC_OscConfig+0x324>
          return HAL_TIMEOUT;
 8002958:	2003      	movs	r0, #3
 800295a:	e0f3      	b.n	8002b44 <HAL_RCC_OscConfig+0x528>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800295c:	2b05      	cmp	r3, #5
 800295e:	d009      	beq.n	8002974 <HAL_RCC_OscConfig+0x358>
 8002960:	4b7c      	ldr	r3, [pc, #496]	; (8002b54 <HAL_RCC_OscConfig+0x538>)
 8002962:	6a1a      	ldr	r2, [r3, #32]
 8002964:	f022 0201 	bic.w	r2, r2, #1
 8002968:	621a      	str	r2, [r3, #32]
 800296a:	6a1a      	ldr	r2, [r3, #32]
 800296c:	f022 0204 	bic.w	r2, r2, #4
 8002970:	621a      	str	r2, [r3, #32]
 8002972:	e7e0      	b.n	8002936 <HAL_RCC_OscConfig+0x31a>
 8002974:	4b77      	ldr	r3, [pc, #476]	; (8002b54 <HAL_RCC_OscConfig+0x538>)
 8002976:	6a1a      	ldr	r2, [r3, #32]
 8002978:	f042 0204 	orr.w	r2, r2, #4
 800297c:	621a      	str	r2, [r3, #32]
 800297e:	6a1a      	ldr	r2, [r3, #32]
 8002980:	f042 0201 	orr.w	r2, r2, #1
 8002984:	621a      	str	r2, [r3, #32]
 8002986:	e7d6      	b.n	8002936 <HAL_RCC_OscConfig+0x31a>
      tickstart = HAL_GetTick();
 8002988:	f7fd ff88 	bl	800089c <HAL_GetTick>
 800298c:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800298e:	4b71      	ldr	r3, [pc, #452]	; (8002b54 <HAL_RCC_OscConfig+0x538>)
 8002990:	6a1b      	ldr	r3, [r3, #32]
 8002992:	f013 0f02 	tst.w	r3, #2
 8002996:	d008      	beq.n	80029aa <HAL_RCC_OscConfig+0x38e>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8002998:	f7fd ff80 	bl	800089c <HAL_GetTick>
 800299c:	1b80      	subs	r0, r0, r6
 800299e:	f241 3388 	movw	r3, #5000	; 0x1388
 80029a2:	4298      	cmp	r0, r3
 80029a4:	d9f3      	bls.n	800298e <HAL_RCC_OscConfig+0x372>
          return HAL_TIMEOUT;
 80029a6:	2003      	movs	r0, #3
 80029a8:	e0cc      	b.n	8002b44 <HAL_RCC_OscConfig+0x528>
    if (pwrclkchanged == SET)
 80029aa:	2d00      	cmp	r5, #0
 80029ac:	d153      	bne.n	8002a56 <HAL_RCC_OscConfig+0x43a>
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
 80029ae:	69e3      	ldr	r3, [r4, #28]
 80029b0:	2b02      	cmp	r3, #2
 80029b2:	d856      	bhi.n	8002a62 <HAL_RCC_OscConfig+0x446>
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 80029b4:	69e3      	ldr	r3, [r4, #28]
 80029b6:	2b00      	cmp	r3, #0
 80029b8:	f000 80c3 	beq.w	8002b42 <HAL_RCC_OscConfig+0x526>
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80029bc:	4a65      	ldr	r2, [pc, #404]	; (8002b54 <HAL_RCC_OscConfig+0x538>)
 80029be:	6852      	ldr	r2, [r2, #4]
 80029c0:	f002 020c 	and.w	r2, r2, #12
 80029c4:	2a08      	cmp	r2, #8
 80029c6:	f000 80a6 	beq.w	8002b16 <HAL_RCC_OscConfig+0x4fa>
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80029ca:	2b02      	cmp	r3, #2
 80029cc:	f040 808f 	bne.w	8002aee <HAL_RCC_OscConfig+0x4d2>
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
 80029d0:	6a23      	ldr	r3, [r4, #32]
 80029d2:	b113      	cbz	r3, 80029da <HAL_RCC_OscConfig+0x3be>
 80029d4:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80029d8:	d149      	bne.n	8002a6e <HAL_RCC_OscConfig+0x452>
        assert_param(IS_RCC_PLL_MUL(RCC_OscInitStruct->PLL.PLLMUL));
 80029da:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80029dc:	b34b      	cbz	r3, 8002a32 <HAL_RCC_OscConfig+0x416>
 80029de:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 80029e2:	d026      	beq.n	8002a32 <HAL_RCC_OscConfig+0x416>
 80029e4:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
 80029e8:	d023      	beq.n	8002a32 <HAL_RCC_OscConfig+0x416>
 80029ea:	f5b3 2f40 	cmp.w	r3, #786432	; 0xc0000
 80029ee:	d020      	beq.n	8002a32 <HAL_RCC_OscConfig+0x416>
 80029f0:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 80029f4:	d01d      	beq.n	8002a32 <HAL_RCC_OscConfig+0x416>
 80029f6:	f5b3 1fa0 	cmp.w	r3, #1310720	; 0x140000
 80029fa:	d01a      	beq.n	8002a32 <HAL_RCC_OscConfig+0x416>
 80029fc:	f5b3 1fc0 	cmp.w	r3, #1572864	; 0x180000
 8002a00:	d017      	beq.n	8002a32 <HAL_RCC_OscConfig+0x416>
 8002a02:	f5b3 1fe0 	cmp.w	r3, #1835008	; 0x1c0000
 8002a06:	d014      	beq.n	8002a32 <HAL_RCC_OscConfig+0x416>
 8002a08:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 8002a0c:	d011      	beq.n	8002a32 <HAL_RCC_OscConfig+0x416>
 8002a0e:	f5b3 1f10 	cmp.w	r3, #2359296	; 0x240000
 8002a12:	d00e      	beq.n	8002a32 <HAL_RCC_OscConfig+0x416>
 8002a14:	f5b3 1f20 	cmp.w	r3, #2621440	; 0x280000
 8002a18:	d00b      	beq.n	8002a32 <HAL_RCC_OscConfig+0x416>
 8002a1a:	f5b3 1f30 	cmp.w	r3, #2883584	; 0x2c0000
 8002a1e:	d008      	beq.n	8002a32 <HAL_RCC_OscConfig+0x416>
 8002a20:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
 8002a24:	d005      	beq.n	8002a32 <HAL_RCC_OscConfig+0x416>
 8002a26:	f5b3 1f50 	cmp.w	r3, #3407872	; 0x340000
 8002a2a:	d002      	beq.n	8002a32 <HAL_RCC_OscConfig+0x416>
 8002a2c:	f5b3 1f60 	cmp.w	r3, #3670016	; 0x380000
 8002a30:	d123      	bne.n	8002a7a <HAL_RCC_OscConfig+0x45e>
        __HAL_RCC_PLL_DISABLE();
 8002a32:	4b49      	ldr	r3, [pc, #292]	; (8002b58 <HAL_RCC_OscConfig+0x53c>)
 8002a34:	2200      	movs	r2, #0
 8002a36:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8002a38:	f7fd ff30 	bl	800089c <HAL_GetTick>
 8002a3c:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8002a3e:	4b45      	ldr	r3, [pc, #276]	; (8002b54 <HAL_RCC_OscConfig+0x538>)
 8002a40:	681b      	ldr	r3, [r3, #0]
 8002a42:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8002a46:	d01e      	beq.n	8002a86 <HAL_RCC_OscConfig+0x46a>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8002a48:	f7fd ff28 	bl	800089c <HAL_GetTick>
 8002a4c:	1b40      	subs	r0, r0, r5
 8002a4e:	2802      	cmp	r0, #2
 8002a50:	d9f5      	bls.n	8002a3e <HAL_RCC_OscConfig+0x422>
            return HAL_TIMEOUT;
 8002a52:	2003      	movs	r0, #3
 8002a54:	e076      	b.n	8002b44 <HAL_RCC_OscConfig+0x528>
      __HAL_RCC_PWR_CLK_DISABLE();
 8002a56:	4a3f      	ldr	r2, [pc, #252]	; (8002b54 <HAL_RCC_OscConfig+0x538>)
 8002a58:	69d3      	ldr	r3, [r2, #28]
 8002a5a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8002a5e:	61d3      	str	r3, [r2, #28]
 8002a60:	e7a5      	b.n	80029ae <HAL_RCC_OscConfig+0x392>
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
 8002a62:	f240 21af 	movw	r1, #687	; 0x2af
 8002a66:	483d      	ldr	r0, [pc, #244]	; (8002b5c <HAL_RCC_OscConfig+0x540>)
 8002a68:	f002 fe36 	bl	80056d8 <assert_failed>
 8002a6c:	e7a2      	b.n	80029b4 <HAL_RCC_OscConfig+0x398>
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
 8002a6e:	f44f 712e 	mov.w	r1, #696	; 0x2b8
 8002a72:	483a      	ldr	r0, [pc, #232]	; (8002b5c <HAL_RCC_OscConfig+0x540>)
 8002a74:	f002 fe30 	bl	80056d8 <assert_failed>
 8002a78:	e7af      	b.n	80029da <HAL_RCC_OscConfig+0x3be>
        assert_param(IS_RCC_PLL_MUL(RCC_OscInitStruct->PLL.PLLMUL));
 8002a7a:	f240 21b9 	movw	r1, #697	; 0x2b9
 8002a7e:	4837      	ldr	r0, [pc, #220]	; (8002b5c <HAL_RCC_OscConfig+0x540>)
 8002a80:	f002 fe2a 	bl	80056d8 <assert_failed>
 8002a84:	e7d5      	b.n	8002a32 <HAL_RCC_OscConfig+0x416>
        if (RCC_OscInitStruct->PLL.PLLSource == RCC_PLLSOURCE_HSE)
 8002a86:	6a23      	ldr	r3, [r4, #32]
 8002a88:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8002a8c:	d01a      	beq.n	8002ac4 <HAL_RCC_OscConfig+0x4a8>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8002a8e:	4931      	ldr	r1, [pc, #196]	; (8002b54 <HAL_RCC_OscConfig+0x538>)
 8002a90:	684b      	ldr	r3, [r1, #4]
 8002a92:	f423 1374 	bic.w	r3, r3, #3997696	; 0x3d0000
 8002a96:	6a22      	ldr	r2, [r4, #32]
 8002a98:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8002a9a:	4302      	orrs	r2, r0
 8002a9c:	4313      	orrs	r3, r2
 8002a9e:	604b      	str	r3, [r1, #4]
        __HAL_RCC_PLL_ENABLE();
 8002aa0:	4b2d      	ldr	r3, [pc, #180]	; (8002b58 <HAL_RCC_OscConfig+0x53c>)
 8002aa2:	2201      	movs	r2, #1
 8002aa4:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8002aa6:	f7fd fef9 	bl	800089c <HAL_GetTick>
 8002aaa:	4604      	mov	r4, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 8002aac:	4b29      	ldr	r3, [pc, #164]	; (8002b54 <HAL_RCC_OscConfig+0x538>)
 8002aae:	681b      	ldr	r3, [r3, #0]
 8002ab0:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8002ab4:	d119      	bne.n	8002aea <HAL_RCC_OscConfig+0x4ce>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8002ab6:	f7fd fef1 	bl	800089c <HAL_GetTick>
 8002aba:	1b00      	subs	r0, r0, r4
 8002abc:	2802      	cmp	r0, #2
 8002abe:	d9f5      	bls.n	8002aac <HAL_RCC_OscConfig+0x490>
            return HAL_TIMEOUT;
 8002ac0:	2003      	movs	r0, #3
 8002ac2:	e03f      	b.n	8002b44 <HAL_RCC_OscConfig+0x528>
          assert_param(IS_RCC_HSE_PREDIV(RCC_OscInitStruct->HSEPredivValue));
 8002ac4:	68a3      	ldr	r3, [r4, #8]
 8002ac6:	b113      	cbz	r3, 8002ace <HAL_RCC_OscConfig+0x4b2>
 8002ac8:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8002acc:	d107      	bne.n	8002ade <HAL_RCC_OscConfig+0x4c2>
          __HAL_RCC_HSE_PREDIV_CONFIG(RCC_OscInitStruct->HSEPredivValue);
 8002ace:	4a21      	ldr	r2, [pc, #132]	; (8002b54 <HAL_RCC_OscConfig+0x538>)
 8002ad0:	6853      	ldr	r3, [r2, #4]
 8002ad2:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8002ad6:	68a1      	ldr	r1, [r4, #8]
 8002ad8:	430b      	orrs	r3, r1
 8002ada:	6053      	str	r3, [r2, #4]
 8002adc:	e7d7      	b.n	8002a8e <HAL_RCC_OscConfig+0x472>
          assert_param(IS_RCC_HSE_PREDIV(RCC_OscInitStruct->HSEPredivValue));
 8002ade:	f240 21cf 	movw	r1, #719	; 0x2cf
 8002ae2:	481e      	ldr	r0, [pc, #120]	; (8002b5c <HAL_RCC_OscConfig+0x540>)
 8002ae4:	f002 fdf8 	bl	80056d8 <assert_failed>
 8002ae8:	e7f1      	b.n	8002ace <HAL_RCC_OscConfig+0x4b2>
  return HAL_OK;
 8002aea:	2000      	movs	r0, #0
 8002aec:	e02a      	b.n	8002b44 <HAL_RCC_OscConfig+0x528>
        __HAL_RCC_PLL_DISABLE();
 8002aee:	4b1a      	ldr	r3, [pc, #104]	; (8002b58 <HAL_RCC_OscConfig+0x53c>)
 8002af0:	2200      	movs	r2, #0
 8002af2:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8002af4:	f7fd fed2 	bl	800089c <HAL_GetTick>
 8002af8:	4604      	mov	r4, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8002afa:	4b16      	ldr	r3, [pc, #88]	; (8002b54 <HAL_RCC_OscConfig+0x538>)
 8002afc:	681b      	ldr	r3, [r3, #0]
 8002afe:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8002b02:	d006      	beq.n	8002b12 <HAL_RCC_OscConfig+0x4f6>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8002b04:	f7fd feca 	bl	800089c <HAL_GetTick>
 8002b08:	1b00      	subs	r0, r0, r4
 8002b0a:	2802      	cmp	r0, #2
 8002b0c:	d9f5      	bls.n	8002afa <HAL_RCC_OscConfig+0x4de>
            return HAL_TIMEOUT;
 8002b0e:	2003      	movs	r0, #3
 8002b10:	e018      	b.n	8002b44 <HAL_RCC_OscConfig+0x528>
  return HAL_OK;
 8002b12:	2000      	movs	r0, #0
 8002b14:	e016      	b.n	8002b44 <HAL_RCC_OscConfig+0x528>
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 8002b16:	2b01      	cmp	r3, #1
 8002b18:	d016      	beq.n	8002b48 <HAL_RCC_OscConfig+0x52c>
        pll_config = RCC->CFGR;
 8002b1a:	4b0e      	ldr	r3, [pc, #56]	; (8002b54 <HAL_RCC_OscConfig+0x538>)
 8002b1c:	685b      	ldr	r3, [r3, #4]
        if ((READ_BIT(pll_config, RCC_CFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8002b1e:	f403 3180 	and.w	r1, r3, #65536	; 0x10000
 8002b22:	6a22      	ldr	r2, [r4, #32]
 8002b24:	4291      	cmp	r1, r2
 8002b26:	d001      	beq.n	8002b2c <HAL_RCC_OscConfig+0x510>
          return HAL_ERROR;
 8002b28:	2001      	movs	r0, #1
 8002b2a:	e00b      	b.n	8002b44 <HAL_RCC_OscConfig+0x528>
            (READ_BIT(pll_config, RCC_CFGR_PLLMULL) != RCC_OscInitStruct->PLL.PLLMUL))
 8002b2c:	f403 1370 	and.w	r3, r3, #3932160	; 0x3c0000
 8002b30:	6a62      	ldr	r2, [r4, #36]	; 0x24
        if ((READ_BIT(pll_config, RCC_CFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8002b32:	4293      	cmp	r3, r2
 8002b34:	d00a      	beq.n	8002b4c <HAL_RCC_OscConfig+0x530>
          return HAL_ERROR;
 8002b36:	2001      	movs	r0, #1
 8002b38:	e004      	b.n	8002b44 <HAL_RCC_OscConfig+0x528>
    return HAL_ERROR;
 8002b3a:	2001      	movs	r0, #1
}
 8002b3c:	4770      	bx	lr
        return HAL_ERROR;
 8002b3e:	2001      	movs	r0, #1
 8002b40:	e000      	b.n	8002b44 <HAL_RCC_OscConfig+0x528>
  return HAL_OK;
 8002b42:	2000      	movs	r0, #0
}
 8002b44:	b002      	add	sp, #8
 8002b46:	bd70      	pop	{r4, r5, r6, pc}
        return HAL_ERROR;
 8002b48:	2001      	movs	r0, #1
 8002b4a:	e7fb      	b.n	8002b44 <HAL_RCC_OscConfig+0x528>
  return HAL_OK;
 8002b4c:	2000      	movs	r0, #0
 8002b4e:	e7f9      	b.n	8002b44 <HAL_RCC_OscConfig+0x528>
 8002b50:	40007000 	.word	0x40007000
 8002b54:	40021000 	.word	0x40021000
 8002b58:	42420060 	.word	0x42420060
 8002b5c:	08005e14 	.word	0x08005e14

08002b60 <HAL_RCC_GetSysClockFreq>:
{
 8002b60:	b410      	push	{r4}
 8002b62:	b087      	sub	sp, #28
  const uint8_t aPLLMULFactorTable[16] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 16};
 8002b64:	4c16      	ldr	r4, [pc, #88]	; (8002bc0 <HAL_RCC_GetSysClockFreq+0x60>)
 8002b66:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 8002b6a:	f10d 0c18 	add.w	ip, sp, #24
 8002b6e:	e90c 000f 	stmdb	ip, {r0, r1, r2, r3}
  const uint8_t aPredivFactorTable[2] = {1, 2};
 8002b72:	8a23      	ldrh	r3, [r4, #16]
 8002b74:	f8ad 3004 	strh.w	r3, [sp, #4]
  tmpreg = RCC->CFGR;
 8002b78:	4b12      	ldr	r3, [pc, #72]	; (8002bc4 <HAL_RCC_GetSysClockFreq+0x64>)
 8002b7a:	685b      	ldr	r3, [r3, #4]
  switch (tmpreg & RCC_CFGR_SWS)
 8002b7c:	f003 020c 	and.w	r2, r3, #12
 8002b80:	2a08      	cmp	r2, #8
 8002b82:	d11a      	bne.n	8002bba <HAL_RCC_GetSysClockFreq+0x5a>
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMULL) >> RCC_CFGR_PLLMULL_Pos];
 8002b84:	f3c3 4283 	ubfx	r2, r3, #18, #4
 8002b88:	4462      	add	r2, ip
 8002b8a:	f812 2c10 	ldrb.w	r2, [r2, #-16]
      if ((tmpreg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
 8002b8e:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 8002b92:	d105      	bne.n	8002ba0 <HAL_RCC_GetSysClockFreq+0x40>
        pllclk = (uint32_t)((HSI_VALUE >> 1) * pllmul);
 8002b94:	480c      	ldr	r0, [pc, #48]	; (8002bc8 <HAL_RCC_GetSysClockFreq+0x68>)
 8002b96:	fb00 f002 	mul.w	r0, r0, r2
}
 8002b9a:	b007      	add	sp, #28
 8002b9c:	bc10      	pop	{r4}
 8002b9e:	4770      	bx	lr
        prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> RCC_CFGR_PLLXTPRE_Pos];
 8002ba0:	4b08      	ldr	r3, [pc, #32]	; (8002bc4 <HAL_RCC_GetSysClockFreq+0x64>)
 8002ba2:	685b      	ldr	r3, [r3, #4]
 8002ba4:	f3c3 4340 	ubfx	r3, r3, #17, #1
 8002ba8:	4463      	add	r3, ip
 8002baa:	f813 3c14 	ldrb.w	r3, [r3, #-20]
        pllclk = (uint32_t)((HSE_VALUE  * pllmul) / prediv);
 8002bae:	4807      	ldr	r0, [pc, #28]	; (8002bcc <HAL_RCC_GetSysClockFreq+0x6c>)
 8002bb0:	fb00 f002 	mul.w	r0, r0, r2
 8002bb4:	fbb0 f0f3 	udiv	r0, r0, r3
 8002bb8:	e7ef      	b.n	8002b9a <HAL_RCC_GetSysClockFreq+0x3a>
      sysclockfreq = HSE_VALUE;
 8002bba:	4804      	ldr	r0, [pc, #16]	; (8002bcc <HAL_RCC_GetSysClockFreq+0x6c>)
  return sysclockfreq;
 8002bbc:	e7ed      	b.n	8002b9a <HAL_RCC_GetSysClockFreq+0x3a>
 8002bbe:	bf00      	nop
 8002bc0:	08005cac 	.word	0x08005cac
 8002bc4:	40021000 	.word	0x40021000
 8002bc8:	003d0900 	.word	0x003d0900
 8002bcc:	007a1200 	.word	0x007a1200

08002bd0 <HAL_RCC_ClockConfig>:
  if (RCC_ClkInitStruct == NULL)
 8002bd0:	2800      	cmp	r0, #0
 8002bd2:	f000 80ff 	beq.w	8002dd4 <HAL_RCC_ClockConfig+0x204>
{
 8002bd6:	b570      	push	{r4, r5, r6, lr}
 8002bd8:	4604      	mov	r4, r0
 8002bda:	460d      	mov	r5, r1
  assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
 8002bdc:	6803      	ldr	r3, [r0, #0]
 8002bde:	f013 0f0f 	tst.w	r3, #15
 8002be2:	d014      	beq.n	8002c0e <HAL_RCC_ClockConfig+0x3e>
  assert_param(IS_FLASH_LATENCY(FLatency));
 8002be4:	2d02      	cmp	r5, #2
 8002be6:	d818      	bhi.n	8002c1a <HAL_RCC_ClockConfig+0x4a>
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8002be8:	4b7c      	ldr	r3, [pc, #496]	; (8002ddc <HAL_RCC_ClockConfig+0x20c>)
 8002bea:	681b      	ldr	r3, [r3, #0]
 8002bec:	f003 0307 	and.w	r3, r3, #7
 8002bf0:	42ab      	cmp	r3, r5
 8002bf2:	d218      	bcs.n	8002c26 <HAL_RCC_ClockConfig+0x56>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8002bf4:	4a79      	ldr	r2, [pc, #484]	; (8002ddc <HAL_RCC_ClockConfig+0x20c>)
 8002bf6:	6813      	ldr	r3, [r2, #0]
 8002bf8:	f023 0307 	bic.w	r3, r3, #7
 8002bfc:	432b      	orrs	r3, r5
 8002bfe:	6013      	str	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8002c00:	6813      	ldr	r3, [r2, #0]
 8002c02:	f003 0307 	and.w	r3, r3, #7
 8002c06:	42ab      	cmp	r3, r5
 8002c08:	d00d      	beq.n	8002c26 <HAL_RCC_ClockConfig+0x56>
    return HAL_ERROR;
 8002c0a:	2001      	movs	r0, #1
}
 8002c0c:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
 8002c0e:	f44f 714e 	mov.w	r1, #824	; 0x338
 8002c12:	4873      	ldr	r0, [pc, #460]	; (8002de0 <HAL_RCC_ClockConfig+0x210>)
 8002c14:	f002 fd60 	bl	80056d8 <assert_failed>
 8002c18:	e7e4      	b.n	8002be4 <HAL_RCC_ClockConfig+0x14>
  assert_param(IS_FLASH_LATENCY(FLatency));
 8002c1a:	f240 3139 	movw	r1, #825	; 0x339
 8002c1e:	4870      	ldr	r0, [pc, #448]	; (8002de0 <HAL_RCC_ClockConfig+0x210>)
 8002c20:	f002 fd5a 	bl	80056d8 <assert_failed>
 8002c24:	e7e0      	b.n	8002be8 <HAL_RCC_ClockConfig+0x18>
if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8002c26:	6823      	ldr	r3, [r4, #0]
 8002c28:	f013 0f02 	tst.w	r3, #2
 8002c2c:	d029      	beq.n	8002c82 <HAL_RCC_ClockConfig+0xb2>
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8002c2e:	f013 0f04 	tst.w	r3, #4
 8002c32:	d004      	beq.n	8002c3e <HAL_RCC_ClockConfig+0x6e>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 8002c34:	4a6b      	ldr	r2, [pc, #428]	; (8002de4 <HAL_RCC_ClockConfig+0x214>)
 8002c36:	6853      	ldr	r3, [r2, #4]
 8002c38:	f443 63e0 	orr.w	r3, r3, #1792	; 0x700
 8002c3c:	6053      	str	r3, [r2, #4]
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8002c3e:	6823      	ldr	r3, [r4, #0]
 8002c40:	f013 0f08 	tst.w	r3, #8
 8002c44:	d004      	beq.n	8002c50 <HAL_RCC_ClockConfig+0x80>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 8002c46:	4a67      	ldr	r2, [pc, #412]	; (8002de4 <HAL_RCC_ClockConfig+0x214>)
 8002c48:	6853      	ldr	r3, [r2, #4]
 8002c4a:	f443 5360 	orr.w	r3, r3, #14336	; 0x3800
 8002c4e:	6053      	str	r3, [r2, #4]
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
 8002c50:	68a3      	ldr	r3, [r4, #8]
 8002c52:	b17b      	cbz	r3, 8002c74 <HAL_RCC_ClockConfig+0xa4>
 8002c54:	2b80      	cmp	r3, #128	; 0x80
 8002c56:	d00d      	beq.n	8002c74 <HAL_RCC_ClockConfig+0xa4>
 8002c58:	2b90      	cmp	r3, #144	; 0x90
 8002c5a:	d00b      	beq.n	8002c74 <HAL_RCC_ClockConfig+0xa4>
 8002c5c:	2ba0      	cmp	r3, #160	; 0xa0
 8002c5e:	d009      	beq.n	8002c74 <HAL_RCC_ClockConfig+0xa4>
 8002c60:	2bb0      	cmp	r3, #176	; 0xb0
 8002c62:	d007      	beq.n	8002c74 <HAL_RCC_ClockConfig+0xa4>
 8002c64:	2bc0      	cmp	r3, #192	; 0xc0
 8002c66:	d005      	beq.n	8002c74 <HAL_RCC_ClockConfig+0xa4>
 8002c68:	2bd0      	cmp	r3, #208	; 0xd0
 8002c6a:	d003      	beq.n	8002c74 <HAL_RCC_ClockConfig+0xa4>
 8002c6c:	2be0      	cmp	r3, #224	; 0xe0
 8002c6e:	d001      	beq.n	8002c74 <HAL_RCC_ClockConfig+0xa4>
 8002c70:	2bf0      	cmp	r3, #240	; 0xf0
 8002c72:	d132      	bne.n	8002cda <HAL_RCC_ClockConfig+0x10a>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8002c74:	4a5b      	ldr	r2, [pc, #364]	; (8002de4 <HAL_RCC_ClockConfig+0x214>)
 8002c76:	6853      	ldr	r3, [r2, #4]
 8002c78:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8002c7c:	68a1      	ldr	r1, [r4, #8]
 8002c7e:	430b      	orrs	r3, r1
 8002c80:	6053      	str	r3, [r2, #4]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8002c82:	6823      	ldr	r3, [r4, #0]
 8002c84:	f013 0f01 	tst.w	r3, #1
 8002c88:	d041      	beq.n	8002d0e <HAL_RCC_ClockConfig+0x13e>
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
 8002c8a:	6863      	ldr	r3, [r4, #4]
 8002c8c:	2b02      	cmp	r3, #2
 8002c8e:	d82a      	bhi.n	8002ce6 <HAL_RCC_ClockConfig+0x116>
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8002c90:	6863      	ldr	r3, [r4, #4]
 8002c92:	2b01      	cmp	r3, #1
 8002c94:	d02d      	beq.n	8002cf2 <HAL_RCC_ClockConfig+0x122>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8002c96:	2b02      	cmp	r3, #2
 8002c98:	d032      	beq.n	8002d00 <HAL_RCC_ClockConfig+0x130>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8002c9a:	4a52      	ldr	r2, [pc, #328]	; (8002de4 <HAL_RCC_ClockConfig+0x214>)
 8002c9c:	6812      	ldr	r2, [r2, #0]
 8002c9e:	f012 0f02 	tst.w	r2, #2
 8002ca2:	f000 8099 	beq.w	8002dd8 <HAL_RCC_ClockConfig+0x208>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8002ca6:	494f      	ldr	r1, [pc, #316]	; (8002de4 <HAL_RCC_ClockConfig+0x214>)
 8002ca8:	684a      	ldr	r2, [r1, #4]
 8002caa:	f022 0203 	bic.w	r2, r2, #3
 8002cae:	4313      	orrs	r3, r2
 8002cb0:	604b      	str	r3, [r1, #4]
    tickstart = HAL_GetTick();
 8002cb2:	f7fd fdf3 	bl	800089c <HAL_GetTick>
 8002cb6:	4606      	mov	r6, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8002cb8:	4b4a      	ldr	r3, [pc, #296]	; (8002de4 <HAL_RCC_ClockConfig+0x214>)
 8002cba:	685b      	ldr	r3, [r3, #4]
 8002cbc:	f003 030c 	and.w	r3, r3, #12
 8002cc0:	6862      	ldr	r2, [r4, #4]
 8002cc2:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 8002cc6:	d022      	beq.n	8002d0e <HAL_RCC_ClockConfig+0x13e>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8002cc8:	f7fd fde8 	bl	800089c <HAL_GetTick>
 8002ccc:	1b80      	subs	r0, r0, r6
 8002cce:	f241 3388 	movw	r3, #5000	; 0x1388
 8002cd2:	4298      	cmp	r0, r3
 8002cd4:	d9f0      	bls.n	8002cb8 <HAL_RCC_ClockConfig+0xe8>
        return HAL_TIMEOUT;
 8002cd6:	2003      	movs	r0, #3
 8002cd8:	e798      	b.n	8002c0c <HAL_RCC_ClockConfig+0x3c>
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
 8002cda:	f240 315f 	movw	r1, #863	; 0x35f
 8002cde:	4840      	ldr	r0, [pc, #256]	; (8002de0 <HAL_RCC_ClockConfig+0x210>)
 8002ce0:	f002 fcfa 	bl	80056d8 <assert_failed>
 8002ce4:	e7c6      	b.n	8002c74 <HAL_RCC_ClockConfig+0xa4>
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
 8002ce6:	f240 3166 	movw	r1, #870	; 0x366
 8002cea:	483d      	ldr	r0, [pc, #244]	; (8002de0 <HAL_RCC_ClockConfig+0x210>)
 8002cec:	f002 fcf4 	bl	80056d8 <assert_failed>
 8002cf0:	e7ce      	b.n	8002c90 <HAL_RCC_ClockConfig+0xc0>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8002cf2:	4a3c      	ldr	r2, [pc, #240]	; (8002de4 <HAL_RCC_ClockConfig+0x214>)
 8002cf4:	6812      	ldr	r2, [r2, #0]
 8002cf6:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 8002cfa:	d1d4      	bne.n	8002ca6 <HAL_RCC_ClockConfig+0xd6>
        return HAL_ERROR;
 8002cfc:	2001      	movs	r0, #1
 8002cfe:	e785      	b.n	8002c0c <HAL_RCC_ClockConfig+0x3c>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8002d00:	4a38      	ldr	r2, [pc, #224]	; (8002de4 <HAL_RCC_ClockConfig+0x214>)
 8002d02:	6812      	ldr	r2, [r2, #0]
 8002d04:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
 8002d08:	d1cd      	bne.n	8002ca6 <HAL_RCC_ClockConfig+0xd6>
        return HAL_ERROR;
 8002d0a:	2001      	movs	r0, #1
 8002d0c:	e77e      	b.n	8002c0c <HAL_RCC_ClockConfig+0x3c>
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8002d0e:	4b33      	ldr	r3, [pc, #204]	; (8002ddc <HAL_RCC_ClockConfig+0x20c>)
 8002d10:	681b      	ldr	r3, [r3, #0]
 8002d12:	f003 0307 	and.w	r3, r3, #7
 8002d16:	42ab      	cmp	r3, r5
 8002d18:	d90c      	bls.n	8002d34 <HAL_RCC_ClockConfig+0x164>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8002d1a:	4a30      	ldr	r2, [pc, #192]	; (8002ddc <HAL_RCC_ClockConfig+0x20c>)
 8002d1c:	6813      	ldr	r3, [r2, #0]
 8002d1e:	f023 0307 	bic.w	r3, r3, #7
 8002d22:	432b      	orrs	r3, r5
 8002d24:	6013      	str	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8002d26:	6813      	ldr	r3, [r2, #0]
 8002d28:	f003 0307 	and.w	r3, r3, #7
 8002d2c:	42ab      	cmp	r3, r5
 8002d2e:	d001      	beq.n	8002d34 <HAL_RCC_ClockConfig+0x164>
    return HAL_ERROR;
 8002d30:	2001      	movs	r0, #1
 8002d32:	e76b      	b.n	8002c0c <HAL_RCC_ClockConfig+0x3c>
if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8002d34:	6823      	ldr	r3, [r4, #0]
 8002d36:	f013 0f04 	tst.w	r3, #4
 8002d3a:	d014      	beq.n	8002d66 <HAL_RCC_ClockConfig+0x196>
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
 8002d3c:	68e3      	ldr	r3, [r4, #12]
 8002d3e:	b15b      	cbz	r3, 8002d58 <HAL_RCC_ClockConfig+0x188>
 8002d40:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8002d44:	d008      	beq.n	8002d58 <HAL_RCC_ClockConfig+0x188>
 8002d46:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8002d4a:	d005      	beq.n	8002d58 <HAL_RCC_ClockConfig+0x188>
 8002d4c:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 8002d50:	d002      	beq.n	8002d58 <HAL_RCC_ClockConfig+0x188>
 8002d52:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 8002d56:	d131      	bne.n	8002dbc <HAL_RCC_ClockConfig+0x1ec>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8002d58:	4a22      	ldr	r2, [pc, #136]	; (8002de4 <HAL_RCC_ClockConfig+0x214>)
 8002d5a:	6853      	ldr	r3, [r2, #4]
 8002d5c:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8002d60:	68e1      	ldr	r1, [r4, #12]
 8002d62:	430b      	orrs	r3, r1
 8002d64:	6053      	str	r3, [r2, #4]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8002d66:	6823      	ldr	r3, [r4, #0]
 8002d68:	f013 0f08 	tst.w	r3, #8
 8002d6c:	d015      	beq.n	8002d9a <HAL_RCC_ClockConfig+0x1ca>
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
 8002d6e:	6923      	ldr	r3, [r4, #16]
 8002d70:	b15b      	cbz	r3, 8002d8a <HAL_RCC_ClockConfig+0x1ba>
 8002d72:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8002d76:	d008      	beq.n	8002d8a <HAL_RCC_ClockConfig+0x1ba>
 8002d78:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8002d7c:	d005      	beq.n	8002d8a <HAL_RCC_ClockConfig+0x1ba>
 8002d7e:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 8002d82:	d002      	beq.n	8002d8a <HAL_RCC_ClockConfig+0x1ba>
 8002d84:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 8002d88:	d11e      	bne.n	8002dc8 <HAL_RCC_ClockConfig+0x1f8>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 8002d8a:	4a16      	ldr	r2, [pc, #88]	; (8002de4 <HAL_RCC_ClockConfig+0x214>)
 8002d8c:	6853      	ldr	r3, [r2, #4]
 8002d8e:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 8002d92:	6921      	ldr	r1, [r4, #16]
 8002d94:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8002d98:	6053      	str	r3, [r2, #4]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 8002d9a:	f7ff fee1 	bl	8002b60 <HAL_RCC_GetSysClockFreq>
 8002d9e:	4b11      	ldr	r3, [pc, #68]	; (8002de4 <HAL_RCC_ClockConfig+0x214>)
 8002da0:	685b      	ldr	r3, [r3, #4]
 8002da2:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8002da6:	4a10      	ldr	r2, [pc, #64]	; (8002de8 <HAL_RCC_ClockConfig+0x218>)
 8002da8:	5cd3      	ldrb	r3, [r2, r3]
 8002daa:	40d8      	lsrs	r0, r3
 8002dac:	4b0f      	ldr	r3, [pc, #60]	; (8002dec <HAL_RCC_ClockConfig+0x21c>)
 8002dae:	6018      	str	r0, [r3, #0]
  HAL_InitTick(uwTickPrio);
 8002db0:	4b0f      	ldr	r3, [pc, #60]	; (8002df0 <HAL_RCC_ClockConfig+0x220>)
 8002db2:	6818      	ldr	r0, [r3, #0]
 8002db4:	f7fd fd30 	bl	8000818 <HAL_InitTick>
  return HAL_OK;
 8002db8:	2000      	movs	r0, #0
 8002dba:	e727      	b.n	8002c0c <HAL_RCC_ClockConfig+0x3c>
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
 8002dbc:	f44f 7169 	mov.w	r1, #932	; 0x3a4
 8002dc0:	4807      	ldr	r0, [pc, #28]	; (8002de0 <HAL_RCC_ClockConfig+0x210>)
 8002dc2:	f002 fc89 	bl	80056d8 <assert_failed>
 8002dc6:	e7c7      	b.n	8002d58 <HAL_RCC_ClockConfig+0x188>
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
 8002dc8:	f240 31ab 	movw	r1, #939	; 0x3ab
 8002dcc:	4804      	ldr	r0, [pc, #16]	; (8002de0 <HAL_RCC_ClockConfig+0x210>)
 8002dce:	f002 fc83 	bl	80056d8 <assert_failed>
 8002dd2:	e7da      	b.n	8002d8a <HAL_RCC_ClockConfig+0x1ba>
    return HAL_ERROR;
 8002dd4:	2001      	movs	r0, #1
}
 8002dd6:	4770      	bx	lr
        return HAL_ERROR;
 8002dd8:	2001      	movs	r0, #1
 8002dda:	e717      	b.n	8002c0c <HAL_RCC_ClockConfig+0x3c>
 8002ddc:	40022000 	.word	0x40022000
 8002de0:	08005e14 	.word	0x08005e14
 8002de4:	40021000 	.word	0x40021000
 8002de8:	08005d14 	.word	0x08005d14
 8002dec:	2000000c 	.word	0x2000000c
 8002df0:	20000004 	.word	0x20000004

08002df4 <HAL_RCC_GetHCLKFreq>:
}
 8002df4:	4b01      	ldr	r3, [pc, #4]	; (8002dfc <HAL_RCC_GetHCLKFreq+0x8>)
 8002df6:	6818      	ldr	r0, [r3, #0]
 8002df8:	4770      	bx	lr
 8002dfa:	bf00      	nop
 8002dfc:	2000000c 	.word	0x2000000c

08002e00 <HAL_RCC_GetPCLK1Freq>:
{
 8002e00:	b508      	push	{r3, lr}
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 8002e02:	f7ff fff7 	bl	8002df4 <HAL_RCC_GetHCLKFreq>
 8002e06:	4b04      	ldr	r3, [pc, #16]	; (8002e18 <HAL_RCC_GetPCLK1Freq+0x18>)
 8002e08:	685b      	ldr	r3, [r3, #4]
 8002e0a:	f3c3 2302 	ubfx	r3, r3, #8, #3
 8002e0e:	4a03      	ldr	r2, [pc, #12]	; (8002e1c <HAL_RCC_GetPCLK1Freq+0x1c>)
 8002e10:	5cd3      	ldrb	r3, [r2, r3]
}
 8002e12:	40d8      	lsrs	r0, r3
 8002e14:	bd08      	pop	{r3, pc}
 8002e16:	bf00      	nop
 8002e18:	40021000 	.word	0x40021000
 8002e1c:	08005d24 	.word	0x08005d24

08002e20 <HAL_RCC_GetPCLK2Freq>:
{
 8002e20:	b508      	push	{r3, lr}
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 8002e22:	f7ff ffe7 	bl	8002df4 <HAL_RCC_GetHCLKFreq>
 8002e26:	4b04      	ldr	r3, [pc, #16]	; (8002e38 <HAL_RCC_GetPCLK2Freq+0x18>)
 8002e28:	685b      	ldr	r3, [r3, #4]
 8002e2a:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 8002e2e:	4a03      	ldr	r2, [pc, #12]	; (8002e3c <HAL_RCC_GetPCLK2Freq+0x1c>)
 8002e30:	5cd3      	ldrb	r3, [r2, r3]
}
 8002e32:	40d8      	lsrs	r0, r3
 8002e34:	bd08      	pop	{r3, pc}
 8002e36:	bf00      	nop
 8002e38:	40021000 	.word	0x40021000
 8002e3c:	08005d24 	.word	0x08005d24

08002e40 <TIM_OC1_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8002e40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002e44:	4604      	mov	r4, r0
 8002e46:	460d      	mov	r5, r1
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8002e48:	6a03      	ldr	r3, [r0, #32]
 8002e4a:	f023 0301 	bic.w	r3, r3, #1
 8002e4e:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8002e50:	6a06      	ldr	r6, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8002e52:	6847      	ldr	r7, [r0, #4]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8002e54:	6983      	ldr	r3, [r0, #24]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 8002e56:	f023 0873 	bic.w	r8, r3, #115	; 0x73
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8002e5a:	680b      	ldr	r3, [r1, #0]
 8002e5c:	ea43 0808 	orr.w	r8, r3, r8

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
 8002e60:	f026 0302 	bic.w	r3, r6, #2
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 8002e64:	688e      	ldr	r6, [r1, #8]
 8002e66:	431e      	orrs	r6, r3

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 8002e68:	4b20      	ldr	r3, [pc, #128]	; (8002eec <TIM_OC1_SetConfig+0xac>)
 8002e6a:	4298      	cmp	r0, r3
 8002e6c:	d003      	beq.n	8002e76 <TIM_OC1_SetConfig+0x36>
 8002e6e:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8002e72:	4298      	cmp	r0, r3
 8002e74:	d109      	bne.n	8002e8a <TIM_OC1_SetConfig+0x4a>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
 8002e76:	68eb      	ldr	r3, [r5, #12]
 8002e78:	b10b      	cbz	r3, 8002e7e <TIM_OC1_SetConfig+0x3e>
 8002e7a:	2b08      	cmp	r3, #8
 8002e7c:	d124      	bne.n	8002ec8 <TIM_OC1_SetConfig+0x88>

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
 8002e7e:	f026 0608 	bic.w	r6, r6, #8
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
 8002e82:	68eb      	ldr	r3, [r5, #12]
 8002e84:	431e      	orrs	r6, r3
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
 8002e86:	f026 0604 	bic.w	r6, r6, #4
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8002e8a:	4b18      	ldr	r3, [pc, #96]	; (8002eec <TIM_OC1_SetConfig+0xac>)
 8002e8c:	429c      	cmp	r4, r3
 8002e8e:	d003      	beq.n	8002e98 <TIM_OC1_SetConfig+0x58>
 8002e90:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8002e94:	429c      	cmp	r4, r3
 8002e96:	d10f      	bne.n	8002eb8 <TIM_OC1_SetConfig+0x78>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
 8002e98:	69ab      	ldr	r3, [r5, #24]
 8002e9a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8002e9e:	d000      	beq.n	8002ea2 <TIM_OC1_SetConfig+0x62>
 8002ea0:	b9c3      	cbnz	r3, 8002ed4 <TIM_OC1_SetConfig+0x94>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
 8002ea2:	696b      	ldr	r3, [r5, #20]
 8002ea4:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8002ea8:	d000      	beq.n	8002eac <TIM_OC1_SetConfig+0x6c>
 8002eaa:	b9cb      	cbnz	r3, 8002ee0 <TIM_OC1_SetConfig+0xa0>

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS1;
    tmpcr2 &= ~TIM_CR2_OIS1N;
 8002eac:	f427 7740 	bic.w	r7, r7, #768	; 0x300
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
 8002eb0:	696b      	ldr	r3, [r5, #20]
 8002eb2:	433b      	orrs	r3, r7
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 8002eb4:	69af      	ldr	r7, [r5, #24]
 8002eb6:	431f      	orrs	r7, r3
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8002eb8:	6067      	str	r7, [r4, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 8002eba:	f8c4 8018 	str.w	r8, [r4, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 8002ebe:	686b      	ldr	r3, [r5, #4]
 8002ec0:	6363      	str	r3, [r4, #52]	; 0x34

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8002ec2:	6226      	str	r6, [r4, #32]
}
 8002ec4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
 8002ec8:	f641 2103 	movw	r1, #6659	; 0x1a03
 8002ecc:	4808      	ldr	r0, [pc, #32]	; (8002ef0 <TIM_OC1_SetConfig+0xb0>)
 8002ece:	f002 fc03 	bl	80056d8 <assert_failed>
 8002ed2:	e7d4      	b.n	8002e7e <TIM_OC1_SetConfig+0x3e>
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
 8002ed4:	f641 2110 	movw	r1, #6672	; 0x1a10
 8002ed8:	4805      	ldr	r0, [pc, #20]	; (8002ef0 <TIM_OC1_SetConfig+0xb0>)
 8002eda:	f002 fbfd 	bl	80056d8 <assert_failed>
 8002ede:	e7e0      	b.n	8002ea2 <TIM_OC1_SetConfig+0x62>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
 8002ee0:	f641 2111 	movw	r1, #6673	; 0x1a11
 8002ee4:	4802      	ldr	r0, [pc, #8]	; (8002ef0 <TIM_OC1_SetConfig+0xb0>)
 8002ee6:	f002 fbf7 	bl	80056d8 <assert_failed>
 8002eea:	e7df      	b.n	8002eac <TIM_OC1_SetConfig+0x6c>
 8002eec:	40012c00 	.word	0x40012c00
 8002ef0:	08005e4c 	.word	0x08005e4c

08002ef4 <TIM_OC3_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8002ef4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002ef8:	4604      	mov	r4, r0
 8002efa:	460e      	mov	r6, r1
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8002efc:	6a03      	ldr	r3, [r0, #32]
 8002efe:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8002f02:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8002f04:	6a05      	ldr	r5, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8002f06:	6847      	ldr	r7, [r0, #4]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8002f08:	69c3      	ldr	r3, [r0, #28]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 8002f0a:	f023 0873 	bic.w	r8, r3, #115	; 0x73
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8002f0e:	680b      	ldr	r3, [r1, #0]
 8002f10:	ea43 0808 	orr.w	r8, r3, r8

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
 8002f14:	f425 7500 	bic.w	r5, r5, #512	; 0x200
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);
 8002f18:	688b      	ldr	r3, [r1, #8]
 8002f1a:	ea45 2503 	orr.w	r5, r5, r3, lsl #8

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 8002f1e:	4b22      	ldr	r3, [pc, #136]	; (8002fa8 <TIM_OC3_SetConfig+0xb4>)
 8002f20:	4298      	cmp	r0, r3
 8002f22:	d003      	beq.n	8002f2c <TIM_OC3_SetConfig+0x38>
 8002f24:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8002f28:	4298      	cmp	r0, r3
 8002f2a:	d10a      	bne.n	8002f42 <TIM_OC3_SetConfig+0x4e>
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
 8002f2c:	68f3      	ldr	r3, [r6, #12]
 8002f2e:	b10b      	cbz	r3, 8002f34 <TIM_OC3_SetConfig+0x40>
 8002f30:	2b08      	cmp	r3, #8
 8002f32:	d127      	bne.n	8002f84 <TIM_OC3_SetConfig+0x90>

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC3NP;
 8002f34:	f425 6500 	bic.w	r5, r5, #2048	; 0x800
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 8002f38:	68f3      	ldr	r3, [r6, #12]
 8002f3a:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
 8002f3e:	f425 6580 	bic.w	r5, r5, #1024	; 0x400
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8002f42:	4b19      	ldr	r3, [pc, #100]	; (8002fa8 <TIM_OC3_SetConfig+0xb4>)
 8002f44:	429c      	cmp	r4, r3
 8002f46:	d003      	beq.n	8002f50 <TIM_OC3_SetConfig+0x5c>
 8002f48:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8002f4c:	429c      	cmp	r4, r3
 8002f4e:	d111      	bne.n	8002f74 <TIM_OC3_SetConfig+0x80>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
 8002f50:	69b3      	ldr	r3, [r6, #24]
 8002f52:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8002f56:	d000      	beq.n	8002f5a <TIM_OC3_SetConfig+0x66>
 8002f58:	b9d3      	cbnz	r3, 8002f90 <TIM_OC3_SetConfig+0x9c>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
 8002f5a:	6973      	ldr	r3, [r6, #20]
 8002f5c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8002f60:	d000      	beq.n	8002f64 <TIM_OC3_SetConfig+0x70>
 8002f62:	b9db      	cbnz	r3, 8002f9c <TIM_OC3_SetConfig+0xa8>

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
    tmpcr2 &= ~TIM_CR2_OIS3N;
 8002f64:	f427 5740 	bic.w	r7, r7, #12288	; 0x3000
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
 8002f68:	6973      	ldr	r3, [r6, #20]
 8002f6a:	ea47 1703 	orr.w	r7, r7, r3, lsl #4
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 8002f6e:	69b3      	ldr	r3, [r6, #24]
 8002f70:	ea47 1703 	orr.w	r7, r7, r3, lsl #4
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8002f74:	6067      	str	r7, [r4, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 8002f76:	f8c4 801c 	str.w	r8, [r4, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 8002f7a:	6873      	ldr	r3, [r6, #4]
 8002f7c:	63e3      	str	r3, [r4, #60]	; 0x3c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8002f7e:	6225      	str	r5, [r4, #32]
}
 8002f80:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
 8002f84:	f641 2199 	movw	r1, #6809	; 0x1a99
 8002f88:	4808      	ldr	r0, [pc, #32]	; (8002fac <TIM_OC3_SetConfig+0xb8>)
 8002f8a:	f002 fba5 	bl	80056d8 <assert_failed>
 8002f8e:	e7d1      	b.n	8002f34 <TIM_OC3_SetConfig+0x40>
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
 8002f90:	f641 21a6 	movw	r1, #6822	; 0x1aa6
 8002f94:	4805      	ldr	r0, [pc, #20]	; (8002fac <TIM_OC3_SetConfig+0xb8>)
 8002f96:	f002 fb9f 	bl	80056d8 <assert_failed>
 8002f9a:	e7de      	b.n	8002f5a <TIM_OC3_SetConfig+0x66>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
 8002f9c:	f641 21a7 	movw	r1, #6823	; 0x1aa7
 8002fa0:	4802      	ldr	r0, [pc, #8]	; (8002fac <TIM_OC3_SetConfig+0xb8>)
 8002fa2:	f002 fb99 	bl	80056d8 <assert_failed>
 8002fa6:	e7dd      	b.n	8002f64 <TIM_OC3_SetConfig+0x70>
 8002fa8:	40012c00 	.word	0x40012c00
 8002fac:	08005e4c 	.word	0x08005e4c

08002fb0 <TIM_OC4_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8002fb0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002fb4:	4604      	mov	r4, r0
 8002fb6:	460f      	mov	r7, r1
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8002fb8:	6a03      	ldr	r3, [r0, #32]
 8002fba:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8002fbe:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8002fc0:	6a05      	ldr	r5, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8002fc2:	f8d0 8004 	ldr.w	r8, [r0, #4]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8002fc6:	69c6      	ldr	r6, [r0, #28]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 8002fc8:	f426 46e6 	bic.w	r6, r6, #29440	; 0x7300

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8002fcc:	680b      	ldr	r3, [r1, #0]
 8002fce:	ea46 2603 	orr.w	r6, r6, r3, lsl #8

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
 8002fd2:	f425 5500 	bic.w	r5, r5, #8192	; 0x2000
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12U);
 8002fd6:	688b      	ldr	r3, [r1, #8]
 8002fd8:	ea45 3503 	orr.w	r5, r5, r3, lsl #12

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8002fdc:	4b0f      	ldr	r3, [pc, #60]	; (800301c <TIM_OC4_SetConfig+0x6c>)
 8002fde:	4298      	cmp	r0, r3
 8002fe0:	d003      	beq.n	8002fea <TIM_OC4_SetConfig+0x3a>
 8002fe2:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8002fe6:	4298      	cmp	r0, r3
 8002fe8:	d109      	bne.n	8002ffe <TIM_OC4_SetConfig+0x4e>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
 8002fea:	697b      	ldr	r3, [r7, #20]
 8002fec:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8002ff0:	d000      	beq.n	8002ff4 <TIM_OC4_SetConfig+0x44>
 8002ff2:	b963      	cbnz	r3, 800300e <TIM_OC4_SetConfig+0x5e>

    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS4;
 8002ff4:	f428 4880 	bic.w	r8, r8, #16384	; 0x4000

    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 8002ff8:	697b      	ldr	r3, [r7, #20]
 8002ffa:	ea48 1883 	orr.w	r8, r8, r3, lsl #6
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8002ffe:	f8c4 8004 	str.w	r8, [r4, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 8003002:	61e6      	str	r6, [r4, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 8003004:	687b      	ldr	r3, [r7, #4]
 8003006:	6423      	str	r3, [r4, #64]	; 0x40

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8003008:	6225      	str	r5, [r4, #32]
}
 800300a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
 800300e:	f641 21e5 	movw	r1, #6885	; 0x1ae5
 8003012:	4803      	ldr	r0, [pc, #12]	; (8003020 <TIM_OC4_SetConfig+0x70>)
 8003014:	f002 fb60 	bl	80056d8 <assert_failed>
 8003018:	e7ec      	b.n	8002ff4 <TIM_OC4_SetConfig+0x44>
 800301a:	bf00      	nop
 800301c:	40012c00 	.word	0x40012c00
 8003020:	08005e4c 	.word	0x08005e4c

08003024 <TIM_Base_SetConfig>:
  tmpcr1 = TIMx->CR1;
 8003024:	6803      	ldr	r3, [r0, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8003026:	4a24      	ldr	r2, [pc, #144]	; (80030b8 <TIM_Base_SetConfig+0x94>)
 8003028:	4290      	cmp	r0, r2
 800302a:	d012      	beq.n	8003052 <TIM_Base_SetConfig+0x2e>
 800302c:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8003030:	4290      	cmp	r0, r2
 8003032:	d00e      	beq.n	8003052 <TIM_Base_SetConfig+0x2e>
 8003034:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8003038:	d00b      	beq.n	8003052 <TIM_Base_SetConfig+0x2e>
 800303a:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 800303e:	4290      	cmp	r0, r2
 8003040:	d007      	beq.n	8003052 <TIM_Base_SetConfig+0x2e>
 8003042:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8003046:	4290      	cmp	r0, r2
 8003048:	d003      	beq.n	8003052 <TIM_Base_SetConfig+0x2e>
 800304a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800304e:	4290      	cmp	r0, r2
 8003050:	d103      	bne.n	800305a <TIM_Base_SetConfig+0x36>
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8003052:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8003056:	684a      	ldr	r2, [r1, #4]
 8003058:	4313      	orrs	r3, r2
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800305a:	4a17      	ldr	r2, [pc, #92]	; (80030b8 <TIM_Base_SetConfig+0x94>)
 800305c:	4290      	cmp	r0, r2
 800305e:	d012      	beq.n	8003086 <TIM_Base_SetConfig+0x62>
 8003060:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8003064:	4290      	cmp	r0, r2
 8003066:	d00e      	beq.n	8003086 <TIM_Base_SetConfig+0x62>
 8003068:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 800306c:	d00b      	beq.n	8003086 <TIM_Base_SetConfig+0x62>
 800306e:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 8003072:	4290      	cmp	r0, r2
 8003074:	d007      	beq.n	8003086 <TIM_Base_SetConfig+0x62>
 8003076:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800307a:	4290      	cmp	r0, r2
 800307c:	d003      	beq.n	8003086 <TIM_Base_SetConfig+0x62>
 800307e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8003082:	4290      	cmp	r0, r2
 8003084:	d103      	bne.n	800308e <TIM_Base_SetConfig+0x6a>
    tmpcr1 &= ~TIM_CR1_CKD;
 8003086:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800308a:	68ca      	ldr	r2, [r1, #12]
 800308c:	4313      	orrs	r3, r2
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800308e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8003092:	694a      	ldr	r2, [r1, #20]
 8003094:	4313      	orrs	r3, r2
  TIMx->CR1 = tmpcr1;
 8003096:	6003      	str	r3, [r0, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8003098:	688b      	ldr	r3, [r1, #8]
 800309a:	62c3      	str	r3, [r0, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 800309c:	680b      	ldr	r3, [r1, #0]
 800309e:	6283      	str	r3, [r0, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 80030a0:	4b05      	ldr	r3, [pc, #20]	; (80030b8 <TIM_Base_SetConfig+0x94>)
 80030a2:	4298      	cmp	r0, r3
 80030a4:	d003      	beq.n	80030ae <TIM_Base_SetConfig+0x8a>
 80030a6:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 80030aa:	4298      	cmp	r0, r3
 80030ac:	d101      	bne.n	80030b2 <TIM_Base_SetConfig+0x8e>
    TIMx->RCR = Structure->RepetitionCounter;
 80030ae:	690b      	ldr	r3, [r1, #16]
 80030b0:	6303      	str	r3, [r0, #48]	; 0x30
  TIMx->EGR = TIM_EGR_UG;
 80030b2:	2301      	movs	r3, #1
 80030b4:	6143      	str	r3, [r0, #20]
}
 80030b6:	4770      	bx	lr
 80030b8:	40012c00 	.word	0x40012c00

080030bc <HAL_TIM_PWM_Init>:
  if (htim == NULL)
 80030bc:	2800      	cmp	r0, #0
 80030be:	d074      	beq.n	80031aa <HAL_TIM_PWM_Init+0xee>
{
 80030c0:	b510      	push	{r4, lr}
 80030c2:	4604      	mov	r4, r0
  assert_param(IS_TIM_INSTANCE(htim->Instance));
 80030c4:	6803      	ldr	r3, [r0, #0]
 80030c6:	4a3a      	ldr	r2, [pc, #232]	; (80031b0 <HAL_TIM_PWM_Init+0xf4>)
 80030c8:	4293      	cmp	r3, r2
 80030ca:	d01f      	beq.n	800310c <HAL_TIM_PWM_Init+0x50>
 80030cc:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 80030d0:	4293      	cmp	r3, r2
 80030d2:	d01b      	beq.n	800310c <HAL_TIM_PWM_Init+0x50>
 80030d4:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80030d8:	d018      	beq.n	800310c <HAL_TIM_PWM_Init+0x50>
 80030da:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 80030de:	4293      	cmp	r3, r2
 80030e0:	d014      	beq.n	800310c <HAL_TIM_PWM_Init+0x50>
 80030e2:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80030e6:	4293      	cmp	r3, r2
 80030e8:	d010      	beq.n	800310c <HAL_TIM_PWM_Init+0x50>
 80030ea:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80030ee:	4293      	cmp	r3, r2
 80030f0:	d00c      	beq.n	800310c <HAL_TIM_PWM_Init+0x50>
 80030f2:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80030f6:	4293      	cmp	r3, r2
 80030f8:	d008      	beq.n	800310c <HAL_TIM_PWM_Init+0x50>
 80030fa:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80030fe:	4293      	cmp	r3, r2
 8003100:	d004      	beq.n	800310c <HAL_TIM_PWM_Init+0x50>
 8003102:	f240 510e 	movw	r1, #1294	; 0x50e
 8003106:	482b      	ldr	r0, [pc, #172]	; (80031b4 <HAL_TIM_PWM_Init+0xf8>)
 8003108:	f002 fae6 	bl	80056d8 <assert_failed>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
 800310c:	68a3      	ldr	r3, [r4, #8]
 800310e:	b13b      	cbz	r3, 8003120 <HAL_TIM_PWM_Init+0x64>
 8003110:	2b10      	cmp	r3, #16
 8003112:	d005      	beq.n	8003120 <HAL_TIM_PWM_Init+0x64>
 8003114:	2b20      	cmp	r3, #32
 8003116:	d003      	beq.n	8003120 <HAL_TIM_PWM_Init+0x64>
 8003118:	2b40      	cmp	r3, #64	; 0x40
 800311a:	d001      	beq.n	8003120 <HAL_TIM_PWM_Init+0x64>
 800311c:	2b60      	cmp	r3, #96	; 0x60
 800311e:	d12c      	bne.n	800317a <HAL_TIM_PWM_Init+0xbe>
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
 8003120:	6923      	ldr	r3, [r4, #16]
 8003122:	b12b      	cbz	r3, 8003130 <HAL_TIM_PWM_Init+0x74>
 8003124:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8003128:	d002      	beq.n	8003130 <HAL_TIM_PWM_Init+0x74>
 800312a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800312e:	d12a      	bne.n	8003186 <HAL_TIM_PWM_Init+0xca>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
 8003130:	69a3      	ldr	r3, [r4, #24]
 8003132:	b10b      	cbz	r3, 8003138 <HAL_TIM_PWM_Init+0x7c>
 8003134:	2b80      	cmp	r3, #128	; 0x80
 8003136:	d12c      	bne.n	8003192 <HAL_TIM_PWM_Init+0xd6>
  if (htim->State == HAL_TIM_STATE_RESET)
 8003138:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
 800313c:	b37b      	cbz	r3, 800319e <HAL_TIM_PWM_Init+0xe2>
  htim->State = HAL_TIM_STATE_BUSY;
 800313e:	2302      	movs	r3, #2
 8003140:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8003144:	1d21      	adds	r1, r4, #4
 8003146:	6820      	ldr	r0, [r4, #0]
 8003148:	f7ff ff6c 	bl	8003024 <TIM_Base_SetConfig>
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 800314c:	2301      	movs	r3, #1
 800314e:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8003152:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
 8003156:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
 800315a:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 800315e:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8003162:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8003166:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 800316a:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 800316e:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
  htim->State = HAL_TIM_STATE_READY;
 8003172:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  return HAL_OK;
 8003176:	2000      	movs	r0, #0
}
 8003178:	bd10      	pop	{r4, pc}
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
 800317a:	f240 510f 	movw	r1, #1295	; 0x50f
 800317e:	480d      	ldr	r0, [pc, #52]	; (80031b4 <HAL_TIM_PWM_Init+0xf8>)
 8003180:	f002 faaa 	bl	80056d8 <assert_failed>
 8003184:	e7cc      	b.n	8003120 <HAL_TIM_PWM_Init+0x64>
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
 8003186:	f44f 61a2 	mov.w	r1, #1296	; 0x510
 800318a:	480a      	ldr	r0, [pc, #40]	; (80031b4 <HAL_TIM_PWM_Init+0xf8>)
 800318c:	f002 faa4 	bl	80056d8 <assert_failed>
 8003190:	e7ce      	b.n	8003130 <HAL_TIM_PWM_Init+0x74>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
 8003192:	f240 5111 	movw	r1, #1297	; 0x511
 8003196:	4807      	ldr	r0, [pc, #28]	; (80031b4 <HAL_TIM_PWM_Init+0xf8>)
 8003198:	f002 fa9e 	bl	80056d8 <assert_failed>
 800319c:	e7cc      	b.n	8003138 <HAL_TIM_PWM_Init+0x7c>
    htim->Lock = HAL_UNLOCKED;
 800319e:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
    HAL_TIM_PWM_MspInit(htim);
 80031a2:	4620      	mov	r0, r4
 80031a4:	f002 fb06 	bl	80057b4 <HAL_TIM_PWM_MspInit>
 80031a8:	e7c9      	b.n	800313e <HAL_TIM_PWM_Init+0x82>
    return HAL_ERROR;
 80031aa:	2001      	movs	r0, #1
}
 80031ac:	4770      	bx	lr
 80031ae:	bf00      	nop
 80031b0:	40012c00 	.word	0x40012c00
 80031b4:	08005e4c 	.word	0x08005e4c

080031b8 <TIM_OC2_SetConfig>:
{
 80031b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80031bc:	4604      	mov	r4, r0
 80031be:	460e      	mov	r6, r1
  TIMx->CCER &= ~TIM_CCER_CC2E;
 80031c0:	6a03      	ldr	r3, [r0, #32]
 80031c2:	f023 0310 	bic.w	r3, r3, #16
 80031c6:	6203      	str	r3, [r0, #32]
  tmpccer = TIMx->CCER;
 80031c8:	6a05      	ldr	r5, [r0, #32]
  tmpcr2 =  TIMx->CR2;
 80031ca:	f8d0 8004 	ldr.w	r8, [r0, #4]
  tmpccmrx = TIMx->CCMR1;
 80031ce:	6987      	ldr	r7, [r0, #24]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 80031d0:	f427 47e6 	bic.w	r7, r7, #29440	; 0x7300
  tmpccmrx |= (OC_Config->OCMode << 8U);
 80031d4:	680b      	ldr	r3, [r1, #0]
 80031d6:	ea47 2703 	orr.w	r7, r7, r3, lsl #8
  tmpccer &= ~TIM_CCER_CC2P;
 80031da:	f025 0520 	bic.w	r5, r5, #32
  tmpccer |= (OC_Config->OCPolarity << 4U);
 80031de:	688b      	ldr	r3, [r1, #8]
 80031e0:	ea45 1503 	orr.w	r5, r5, r3, lsl #4
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 80031e4:	4b22      	ldr	r3, [pc, #136]	; (8003270 <TIM_OC2_SetConfig+0xb8>)
 80031e6:	4298      	cmp	r0, r3
 80031e8:	d003      	beq.n	80031f2 <TIM_OC2_SetConfig+0x3a>
 80031ea:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 80031ee:	4298      	cmp	r0, r3
 80031f0:	d10a      	bne.n	8003208 <TIM_OC2_SetConfig+0x50>
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
 80031f2:	68f3      	ldr	r3, [r6, #12]
 80031f4:	b10b      	cbz	r3, 80031fa <TIM_OC2_SetConfig+0x42>
 80031f6:	2b08      	cmp	r3, #8
 80031f8:	d127      	bne.n	800324a <TIM_OC2_SetConfig+0x92>
    tmpccer &= ~TIM_CCER_CC2NP;
 80031fa:	f025 0580 	bic.w	r5, r5, #128	; 0x80
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 80031fe:	68f3      	ldr	r3, [r6, #12]
 8003200:	ea45 1503 	orr.w	r5, r5, r3, lsl #4
    tmpccer &= ~TIM_CCER_CC2NE;
 8003204:	f025 0540 	bic.w	r5, r5, #64	; 0x40
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8003208:	4b19      	ldr	r3, [pc, #100]	; (8003270 <TIM_OC2_SetConfig+0xb8>)
 800320a:	429c      	cmp	r4, r3
 800320c:	d003      	beq.n	8003216 <TIM_OC2_SetConfig+0x5e>
 800320e:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8003212:	429c      	cmp	r4, r3
 8003214:	d111      	bne.n	800323a <TIM_OC2_SetConfig+0x82>
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
 8003216:	69b3      	ldr	r3, [r6, #24]
 8003218:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800321c:	d000      	beq.n	8003220 <TIM_OC2_SetConfig+0x68>
 800321e:	b9d3      	cbnz	r3, 8003256 <TIM_OC2_SetConfig+0x9e>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
 8003220:	6973      	ldr	r3, [r6, #20]
 8003222:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8003226:	d000      	beq.n	800322a <TIM_OC2_SetConfig+0x72>
 8003228:	b9db      	cbnz	r3, 8003262 <TIM_OC2_SetConfig+0xaa>
    tmpcr2 &= ~TIM_CR2_OIS2N;
 800322a:	f428 6840 	bic.w	r8, r8, #3072	; 0xc00
    tmpcr2 |= (OC_Config->OCIdleState << 2U);
 800322e:	6973      	ldr	r3, [r6, #20]
 8003230:	ea48 0883 	orr.w	r8, r8, r3, lsl #2
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8003234:	69b3      	ldr	r3, [r6, #24]
 8003236:	ea48 0883 	orr.w	r8, r8, r3, lsl #2
  TIMx->CR2 = tmpcr2;
 800323a:	f8c4 8004 	str.w	r8, [r4, #4]
  TIMx->CCMR1 = tmpccmrx;
 800323e:	61a7      	str	r7, [r4, #24]
  TIMx->CCR2 = OC_Config->Pulse;
 8003240:	6873      	ldr	r3, [r6, #4]
 8003242:	63a3      	str	r3, [r4, #56]	; 0x38
  TIMx->CCER = tmpccer;
 8003244:	6225      	str	r5, [r4, #32]
}
 8003246:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
 800324a:	f641 214e 	movw	r1, #6734	; 0x1a4e
 800324e:	4809      	ldr	r0, [pc, #36]	; (8003274 <TIM_OC2_SetConfig+0xbc>)
 8003250:	f002 fa42 	bl	80056d8 <assert_failed>
 8003254:	e7d1      	b.n	80031fa <TIM_OC2_SetConfig+0x42>
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
 8003256:	f641 215c 	movw	r1, #6748	; 0x1a5c
 800325a:	4806      	ldr	r0, [pc, #24]	; (8003274 <TIM_OC2_SetConfig+0xbc>)
 800325c:	f002 fa3c 	bl	80056d8 <assert_failed>
 8003260:	e7de      	b.n	8003220 <TIM_OC2_SetConfig+0x68>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
 8003262:	f641 215d 	movw	r1, #6749	; 0x1a5d
 8003266:	4803      	ldr	r0, [pc, #12]	; (8003274 <TIM_OC2_SetConfig+0xbc>)
 8003268:	f002 fa36 	bl	80056d8 <assert_failed>
 800326c:	e7dd      	b.n	800322a <TIM_OC2_SetConfig+0x72>
 800326e:	bf00      	nop
 8003270:	40012c00 	.word	0x40012c00
 8003274:	08005e4c 	.word	0x08005e4c

08003278 <HAL_TIM_PWM_ConfigChannel>:
{
 8003278:	b570      	push	{r4, r5, r6, lr}
 800327a:	4604      	mov	r4, r0
 800327c:	460d      	mov	r5, r1
  assert_param(IS_TIM_CHANNELS(Channel));
 800327e:	4616      	mov	r6, r2
 8003280:	b13a      	cbz	r2, 8003292 <HAL_TIM_PWM_ConfigChannel+0x1a>
 8003282:	2a04      	cmp	r2, #4
 8003284:	d005      	beq.n	8003292 <HAL_TIM_PWM_ConfigChannel+0x1a>
 8003286:	2a08      	cmp	r2, #8
 8003288:	d003      	beq.n	8003292 <HAL_TIM_PWM_ConfigChannel+0x1a>
 800328a:	2a0c      	cmp	r2, #12
 800328c:	d001      	beq.n	8003292 <HAL_TIM_PWM_ConfigChannel+0x1a>
 800328e:	2a3c      	cmp	r2, #60	; 0x3c
 8003290:	d11f      	bne.n	80032d2 <HAL_TIM_PWM_ConfigChannel+0x5a>
  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
 8003292:	682b      	ldr	r3, [r5, #0]
 8003294:	2b60      	cmp	r3, #96	; 0x60
 8003296:	d001      	beq.n	800329c <HAL_TIM_PWM_ConfigChannel+0x24>
 8003298:	2b70      	cmp	r3, #112	; 0x70
 800329a:	d120      	bne.n	80032de <HAL_TIM_PWM_ConfigChannel+0x66>
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
 800329c:	68ab      	ldr	r3, [r5, #8]
 800329e:	b10b      	cbz	r3, 80032a4 <HAL_TIM_PWM_ConfigChannel+0x2c>
 80032a0:	2b02      	cmp	r3, #2
 80032a2:	d122      	bne.n	80032ea <HAL_TIM_PWM_ConfigChannel+0x72>
  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
 80032a4:	692b      	ldr	r3, [r5, #16]
 80032a6:	b10b      	cbz	r3, 80032ac <HAL_TIM_PWM_ConfigChannel+0x34>
 80032a8:	2b04      	cmp	r3, #4
 80032aa:	d124      	bne.n	80032f6 <HAL_TIM_PWM_ConfigChannel+0x7e>
  __HAL_LOCK(htim);
 80032ac:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
 80032b0:	2b01      	cmp	r3, #1
 80032b2:	f000 80eb 	beq.w	800348c <HAL_TIM_PWM_ConfigChannel+0x214>
 80032b6:	2301      	movs	r3, #1
 80032b8:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
  switch (Channel)
 80032bc:	2e0c      	cmp	r6, #12
 80032be:	d84f      	bhi.n	8003360 <HAL_TIM_PWM_ConfigChannel+0xe8>
 80032c0:	e8df f006 	tbb	[pc, r6]
 80032c4:	4e4e4e1f 	.word	0x4e4e4e1f
 80032c8:	4e4e4e52 	.word	0x4e4e4e52
 80032cc:	4e4e4e83 	.word	0x4e4e4e83
 80032d0:	b3          	.byte	0xb3
 80032d1:	00          	.byte	0x00
  assert_param(IS_TIM_CHANNELS(Channel));
 80032d2:	f241 0112 	movw	r1, #4114	; 0x1012
 80032d6:	486e      	ldr	r0, [pc, #440]	; (8003490 <HAL_TIM_PWM_ConfigChannel+0x218>)
 80032d8:	f002 f9fe 	bl	80056d8 <assert_failed>
 80032dc:	e7d9      	b.n	8003292 <HAL_TIM_PWM_ConfigChannel+0x1a>
  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
 80032de:	f241 0113 	movw	r1, #4115	; 0x1013
 80032e2:	486b      	ldr	r0, [pc, #428]	; (8003490 <HAL_TIM_PWM_ConfigChannel+0x218>)
 80032e4:	f002 f9f8 	bl	80056d8 <assert_failed>
 80032e8:	e7d8      	b.n	800329c <HAL_TIM_PWM_ConfigChannel+0x24>
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
 80032ea:	f241 0114 	movw	r1, #4116	; 0x1014
 80032ee:	4868      	ldr	r0, [pc, #416]	; (8003490 <HAL_TIM_PWM_ConfigChannel+0x218>)
 80032f0:	f002 f9f2 	bl	80056d8 <assert_failed>
 80032f4:	e7d6      	b.n	80032a4 <HAL_TIM_PWM_ConfigChannel+0x2c>
  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
 80032f6:	f241 0115 	movw	r1, #4117	; 0x1015
 80032fa:	4865      	ldr	r0, [pc, #404]	; (8003490 <HAL_TIM_PWM_ConfigChannel+0x218>)
 80032fc:	f002 f9ec 	bl	80056d8 <assert_failed>
 8003300:	e7d4      	b.n	80032ac <HAL_TIM_PWM_ConfigChannel+0x34>
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
 8003302:	6823      	ldr	r3, [r4, #0]
 8003304:	4a63      	ldr	r2, [pc, #396]	; (8003494 <HAL_TIM_PWM_ConfigChannel+0x21c>)
 8003306:	4293      	cmp	r3, r2
 8003308:	d017      	beq.n	800333a <HAL_TIM_PWM_ConfigChannel+0xc2>
 800330a:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 800330e:	4293      	cmp	r3, r2
 8003310:	d013      	beq.n	800333a <HAL_TIM_PWM_ConfigChannel+0xc2>
 8003312:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8003316:	d010      	beq.n	800333a <HAL_TIM_PWM_ConfigChannel+0xc2>
 8003318:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 800331c:	4293      	cmp	r3, r2
 800331e:	d00c      	beq.n	800333a <HAL_TIM_PWM_ConfigChannel+0xc2>
 8003320:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8003324:	4293      	cmp	r3, r2
 8003326:	d008      	beq.n	800333a <HAL_TIM_PWM_ConfigChannel+0xc2>
 8003328:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800332c:	4293      	cmp	r3, r2
 800332e:	d004      	beq.n	800333a <HAL_TIM_PWM_ConfigChannel+0xc2>
 8003330:	f241 011f 	movw	r1, #4127	; 0x101f
 8003334:	4856      	ldr	r0, [pc, #344]	; (8003490 <HAL_TIM_PWM_ConfigChannel+0x218>)
 8003336:	f002 f9cf 	bl	80056d8 <assert_failed>
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 800333a:	4629      	mov	r1, r5
 800333c:	6820      	ldr	r0, [r4, #0]
 800333e:	f7ff fd7f 	bl	8002e40 <TIM_OC1_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 8003342:	6822      	ldr	r2, [r4, #0]
 8003344:	6993      	ldr	r3, [r2, #24]
 8003346:	f043 0308 	orr.w	r3, r3, #8
 800334a:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 800334c:	6822      	ldr	r2, [r4, #0]
 800334e:	6993      	ldr	r3, [r2, #24]
 8003350:	f023 0304 	bic.w	r3, r3, #4
 8003354:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 8003356:	6822      	ldr	r2, [r4, #0]
 8003358:	6993      	ldr	r3, [r2, #24]
 800335a:	6929      	ldr	r1, [r5, #16]
 800335c:	430b      	orrs	r3, r1
 800335e:	6193      	str	r3, [r2, #24]
  __HAL_UNLOCK(htim);
 8003360:	2000      	movs	r0, #0
 8003362:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c
}
 8003366:	bd70      	pop	{r4, r5, r6, pc}
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
 8003368:	6823      	ldr	r3, [r4, #0]
 800336a:	4a4a      	ldr	r2, [pc, #296]	; (8003494 <HAL_TIM_PWM_ConfigChannel+0x21c>)
 800336c:	4293      	cmp	r3, r2
 800336e:	d017      	beq.n	80033a0 <HAL_TIM_PWM_ConfigChannel+0x128>
 8003370:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8003374:	4293      	cmp	r3, r2
 8003376:	d013      	beq.n	80033a0 <HAL_TIM_PWM_ConfigChannel+0x128>
 8003378:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800337c:	d010      	beq.n	80033a0 <HAL_TIM_PWM_ConfigChannel+0x128>
 800337e:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 8003382:	4293      	cmp	r3, r2
 8003384:	d00c      	beq.n	80033a0 <HAL_TIM_PWM_ConfigChannel+0x128>
 8003386:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800338a:	4293      	cmp	r3, r2
 800338c:	d008      	beq.n	80033a0 <HAL_TIM_PWM_ConfigChannel+0x128>
 800338e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8003392:	4293      	cmp	r3, r2
 8003394:	d004      	beq.n	80033a0 <HAL_TIM_PWM_ConfigChannel+0x128>
 8003396:	f241 0130 	movw	r1, #4144	; 0x1030
 800339a:	483d      	ldr	r0, [pc, #244]	; (8003490 <HAL_TIM_PWM_ConfigChannel+0x218>)
 800339c:	f002 f99c 	bl	80056d8 <assert_failed>
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 80033a0:	4629      	mov	r1, r5
 80033a2:	6820      	ldr	r0, [r4, #0]
 80033a4:	f7ff ff08 	bl	80031b8 <TIM_OC2_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 80033a8:	6822      	ldr	r2, [r4, #0]
 80033aa:	6993      	ldr	r3, [r2, #24]
 80033ac:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 80033b0:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
 80033b2:	6822      	ldr	r2, [r4, #0]
 80033b4:	6993      	ldr	r3, [r2, #24]
 80033b6:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80033ba:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 80033bc:	6822      	ldr	r2, [r4, #0]
 80033be:	6993      	ldr	r3, [r2, #24]
 80033c0:	6929      	ldr	r1, [r5, #16]
 80033c2:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 80033c6:	6193      	str	r3, [r2, #24]
      break;
 80033c8:	e7ca      	b.n	8003360 <HAL_TIM_PWM_ConfigChannel+0xe8>
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
 80033ca:	6823      	ldr	r3, [r4, #0]
 80033cc:	4a31      	ldr	r2, [pc, #196]	; (8003494 <HAL_TIM_PWM_ConfigChannel+0x21c>)
 80033ce:	4293      	cmp	r3, r2
 80033d0:	d017      	beq.n	8003402 <HAL_TIM_PWM_ConfigChannel+0x18a>
 80033d2:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 80033d6:	4293      	cmp	r3, r2
 80033d8:	d013      	beq.n	8003402 <HAL_TIM_PWM_ConfigChannel+0x18a>
 80033da:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80033de:	d010      	beq.n	8003402 <HAL_TIM_PWM_ConfigChannel+0x18a>
 80033e0:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 80033e4:	4293      	cmp	r3, r2
 80033e6:	d00c      	beq.n	8003402 <HAL_TIM_PWM_ConfigChannel+0x18a>
 80033e8:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80033ec:	4293      	cmp	r3, r2
 80033ee:	d008      	beq.n	8003402 <HAL_TIM_PWM_ConfigChannel+0x18a>
 80033f0:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80033f4:	4293      	cmp	r3, r2
 80033f6:	d004      	beq.n	8003402 <HAL_TIM_PWM_ConfigChannel+0x18a>
 80033f8:	f241 0141 	movw	r1, #4161	; 0x1041
 80033fc:	4824      	ldr	r0, [pc, #144]	; (8003490 <HAL_TIM_PWM_ConfigChannel+0x218>)
 80033fe:	f002 f96b 	bl	80056d8 <assert_failed>
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 8003402:	4629      	mov	r1, r5
 8003404:	6820      	ldr	r0, [r4, #0]
 8003406:	f7ff fd75 	bl	8002ef4 <TIM_OC3_SetConfig>
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 800340a:	6822      	ldr	r2, [r4, #0]
 800340c:	69d3      	ldr	r3, [r2, #28]
 800340e:	f043 0308 	orr.w	r3, r3, #8
 8003412:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 8003414:	6822      	ldr	r2, [r4, #0]
 8003416:	69d3      	ldr	r3, [r2, #28]
 8003418:	f023 0304 	bic.w	r3, r3, #4
 800341c:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 800341e:	6822      	ldr	r2, [r4, #0]
 8003420:	69d3      	ldr	r3, [r2, #28]
 8003422:	6929      	ldr	r1, [r5, #16]
 8003424:	430b      	orrs	r3, r1
 8003426:	61d3      	str	r3, [r2, #28]
      break;
 8003428:	e79a      	b.n	8003360 <HAL_TIM_PWM_ConfigChannel+0xe8>
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
 800342a:	6823      	ldr	r3, [r4, #0]
 800342c:	4a19      	ldr	r2, [pc, #100]	; (8003494 <HAL_TIM_PWM_ConfigChannel+0x21c>)
 800342e:	4293      	cmp	r3, r2
 8003430:	d017      	beq.n	8003462 <HAL_TIM_PWM_ConfigChannel+0x1ea>
 8003432:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8003436:	4293      	cmp	r3, r2
 8003438:	d013      	beq.n	8003462 <HAL_TIM_PWM_ConfigChannel+0x1ea>
 800343a:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800343e:	d010      	beq.n	8003462 <HAL_TIM_PWM_ConfigChannel+0x1ea>
 8003440:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 8003444:	4293      	cmp	r3, r2
 8003446:	d00c      	beq.n	8003462 <HAL_TIM_PWM_ConfigChannel+0x1ea>
 8003448:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800344c:	4293      	cmp	r3, r2
 800344e:	d008      	beq.n	8003462 <HAL_TIM_PWM_ConfigChannel+0x1ea>
 8003450:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8003454:	4293      	cmp	r3, r2
 8003456:	d004      	beq.n	8003462 <HAL_TIM_PWM_ConfigChannel+0x1ea>
 8003458:	f241 0152 	movw	r1, #4178	; 0x1052
 800345c:	480c      	ldr	r0, [pc, #48]	; (8003490 <HAL_TIM_PWM_ConfigChannel+0x218>)
 800345e:	f002 f93b 	bl	80056d8 <assert_failed>
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 8003462:	4629      	mov	r1, r5
 8003464:	6820      	ldr	r0, [r4, #0]
 8003466:	f7ff fda3 	bl	8002fb0 <TIM_OC4_SetConfig>
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 800346a:	6822      	ldr	r2, [r4, #0]
 800346c:	69d3      	ldr	r3, [r2, #28]
 800346e:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8003472:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
 8003474:	6822      	ldr	r2, [r4, #0]
 8003476:	69d3      	ldr	r3, [r2, #28]
 8003478:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800347c:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 800347e:	6822      	ldr	r2, [r4, #0]
 8003480:	69d3      	ldr	r3, [r2, #28]
 8003482:	6929      	ldr	r1, [r5, #16]
 8003484:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8003488:	61d3      	str	r3, [r2, #28]
      break;
 800348a:	e769      	b.n	8003360 <HAL_TIM_PWM_ConfigChannel+0xe8>
  __HAL_LOCK(htim);
 800348c:	2002      	movs	r0, #2
 800348e:	e76a      	b.n	8003366 <HAL_TIM_PWM_ConfigChannel+0xee>
 8003490:	08005e4c 	.word	0x08005e4c
 8003494:	40012c00 	.word	0x40012c00

08003498 <TIM_CCxChannelCmd>:
  * @param  ChannelState specifies the TIM Channel CCxE bit new state.
  *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_DISABLE.
  * @retval None
  */
void TIM_CCxChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelState)
{
 8003498:	b570      	push	{r4, r5, r6, lr}
 800349a:	4604      	mov	r4, r0
 800349c:	460d      	mov	r5, r1
 800349e:	4616      	mov	r6, r2
  uint32_t tmp;

  /* Check the parameters */
  assert_param(IS_TIM_CC1_INSTANCE(TIMx));
 80034a0:	4b1b      	ldr	r3, [pc, #108]	; (8003510 <TIM_CCxChannelCmd+0x78>)
 80034a2:	4298      	cmp	r0, r3
 80034a4:	d017      	beq.n	80034d6 <TIM_CCxChannelCmd+0x3e>
 80034a6:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 80034aa:	4298      	cmp	r0, r3
 80034ac:	d013      	beq.n	80034d6 <TIM_CCxChannelCmd+0x3e>
 80034ae:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 80034b2:	d010      	beq.n	80034d6 <TIM_CCxChannelCmd+0x3e>
 80034b4:	f5a3 3398 	sub.w	r3, r3, #77824	; 0x13000
 80034b8:	4298      	cmp	r0, r3
 80034ba:	d00c      	beq.n	80034d6 <TIM_CCxChannelCmd+0x3e>
 80034bc:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80034c0:	4298      	cmp	r0, r3
 80034c2:	d008      	beq.n	80034d6 <TIM_CCxChannelCmd+0x3e>
 80034c4:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80034c8:	4298      	cmp	r0, r3
 80034ca:	d004      	beq.n	80034d6 <TIM_CCxChannelCmd+0x3e>
 80034cc:	f641 41cb 	movw	r1, #7371	; 0x1ccb
 80034d0:	4810      	ldr	r0, [pc, #64]	; (8003514 <TIM_CCxChannelCmd+0x7c>)
 80034d2:	f002 f901 	bl	80056d8 <assert_failed>
  assert_param(IS_TIM_CHANNELS(Channel));
 80034d6:	b165      	cbz	r5, 80034f2 <TIM_CCxChannelCmd+0x5a>
 80034d8:	2d04      	cmp	r5, #4
 80034da:	d00a      	beq.n	80034f2 <TIM_CCxChannelCmd+0x5a>
 80034dc:	2d08      	cmp	r5, #8
 80034de:	d008      	beq.n	80034f2 <TIM_CCxChannelCmd+0x5a>
 80034e0:	2d0c      	cmp	r5, #12
 80034e2:	d006      	beq.n	80034f2 <TIM_CCxChannelCmd+0x5a>
 80034e4:	2d3c      	cmp	r5, #60	; 0x3c
 80034e6:	d004      	beq.n	80034f2 <TIM_CCxChannelCmd+0x5a>
 80034e8:	f641 41cc 	movw	r1, #7372	; 0x1ccc
 80034ec:	4809      	ldr	r0, [pc, #36]	; (8003514 <TIM_CCxChannelCmd+0x7c>)
 80034ee:	f002 f8f3 	bl	80056d8 <assert_failed>

  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
 80034f2:	f005 051f 	and.w	r5, r5, #31
 80034f6:	2301      	movs	r3, #1
 80034f8:	fa03 f205 	lsl.w	r2, r3, r5

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;
 80034fc:	6a23      	ldr	r3, [r4, #32]
 80034fe:	ea23 0302 	bic.w	r3, r3, r2
 8003502:	6223      	str	r3, [r4, #32]

  /* Set or reset the CCxE Bit */
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
 8003504:	6a23      	ldr	r3, [r4, #32]
 8003506:	fa06 f505 	lsl.w	r5, r6, r5
 800350a:	431d      	orrs	r5, r3
 800350c:	6225      	str	r5, [r4, #32]
}
 800350e:	bd70      	pop	{r4, r5, r6, pc}
 8003510:	40012c00 	.word	0x40012c00
 8003514:	08005e4c 	.word	0x08005e4c

08003518 <HAL_TIM_PWM_Start>:
{
 8003518:	b538      	push	{r3, r4, r5, lr}
 800351a:	4605      	mov	r5, r0
 800351c:	460c      	mov	r4, r1
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
 800351e:	6803      	ldr	r3, [r0, #0]
 8003520:	4a4d      	ldr	r2, [pc, #308]	; (8003658 <HAL_TIM_PWM_Start+0x140>)
 8003522:	4293      	cmp	r3, r2
 8003524:	d012      	beq.n	800354c <HAL_TIM_PWM_Start+0x34>
 8003526:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 800352a:	4293      	cmp	r3, r2
 800352c:	d00e      	beq.n	800354c <HAL_TIM_PWM_Start+0x34>
 800352e:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8003532:	d00b      	beq.n	800354c <HAL_TIM_PWM_Start+0x34>
 8003534:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 8003538:	4293      	cmp	r3, r2
 800353a:	d007      	beq.n	800354c <HAL_TIM_PWM_Start+0x34>
 800353c:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8003540:	4293      	cmp	r3, r2
 8003542:	d003      	beq.n	800354c <HAL_TIM_PWM_Start+0x34>
 8003544:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8003548:	4293      	cmp	r3, r2
 800354a:	d106      	bne.n	800355a <HAL_TIM_PWM_Start+0x42>
 800354c:	b154      	cbz	r4, 8003564 <HAL_TIM_PWM_Start+0x4c>
 800354e:	2c04      	cmp	r4, #4
 8003550:	d008      	beq.n	8003564 <HAL_TIM_PWM_Start+0x4c>
 8003552:	2c08      	cmp	r4, #8
 8003554:	d006      	beq.n	8003564 <HAL_TIM_PWM_Start+0x4c>
 8003556:	2c0c      	cmp	r4, #12
 8003558:	d004      	beq.n	8003564 <HAL_TIM_PWM_Start+0x4c>
 800355a:	f240 5194 	movw	r1, #1428	; 0x594
 800355e:	483f      	ldr	r0, [pc, #252]	; (800365c <HAL_TIM_PWM_Start+0x144>)
 8003560:	f002 f8ba 	bl	80056d8 <assert_failed>
  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
 8003564:	2c00      	cmp	r4, #0
 8003566:	d13b      	bne.n	80035e0 <HAL_TIM_PWM_Start+0xc8>
 8003568:	f895 303e 	ldrb.w	r3, [r5, #62]	; 0x3e
 800356c:	b2db      	uxtb	r3, r3
 800356e:	f113 33ff 	adds.w	r3, r3, #4294967295
 8003572:	bf18      	it	ne
 8003574:	2301      	movne	r3, #1
 8003576:	2b00      	cmp	r3, #0
 8003578:	d169      	bne.n	800364e <HAL_TIM_PWM_Start+0x136>
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 800357a:	2c00      	cmp	r4, #0
 800357c:	d14c      	bne.n	8003618 <HAL_TIM_PWM_Start+0x100>
 800357e:	2302      	movs	r3, #2
 8003580:	f885 303e 	strb.w	r3, [r5, #62]	; 0x3e
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 8003584:	2201      	movs	r2, #1
 8003586:	4621      	mov	r1, r4
 8003588:	6828      	ldr	r0, [r5, #0]
 800358a:	f7ff ff85 	bl	8003498 <TIM_CCxChannelCmd>
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 800358e:	682b      	ldr	r3, [r5, #0]
 8003590:	4a31      	ldr	r2, [pc, #196]	; (8003658 <HAL_TIM_PWM_Start+0x140>)
 8003592:	4293      	cmp	r3, r2
 8003594:	d003      	beq.n	800359e <HAL_TIM_PWM_Start+0x86>
 8003596:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 800359a:	4293      	cmp	r3, r2
 800359c:	d103      	bne.n	80035a6 <HAL_TIM_PWM_Start+0x8e>
    __HAL_TIM_MOE_ENABLE(htim);
 800359e:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80035a0:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80035a4:	645a      	str	r2, [r3, #68]	; 0x44
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 80035a6:	682b      	ldr	r3, [r5, #0]
 80035a8:	4a2b      	ldr	r2, [pc, #172]	; (8003658 <HAL_TIM_PWM_Start+0x140>)
 80035aa:	4293      	cmp	r3, r2
 80035ac:	d044      	beq.n	8003638 <HAL_TIM_PWM_Start+0x120>
 80035ae:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 80035b2:	4293      	cmp	r3, r2
 80035b4:	d040      	beq.n	8003638 <HAL_TIM_PWM_Start+0x120>
 80035b6:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80035ba:	d03d      	beq.n	8003638 <HAL_TIM_PWM_Start+0x120>
 80035bc:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 80035c0:	4293      	cmp	r3, r2
 80035c2:	d039      	beq.n	8003638 <HAL_TIM_PWM_Start+0x120>
 80035c4:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80035c8:	4293      	cmp	r3, r2
 80035ca:	d035      	beq.n	8003638 <HAL_TIM_PWM_Start+0x120>
 80035cc:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80035d0:	4293      	cmp	r3, r2
 80035d2:	d031      	beq.n	8003638 <HAL_TIM_PWM_Start+0x120>
    __HAL_TIM_ENABLE(htim);
 80035d4:	681a      	ldr	r2, [r3, #0]
 80035d6:	f042 0201 	orr.w	r2, r2, #1
 80035da:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 80035dc:	2000      	movs	r0, #0
 80035de:	e037      	b.n	8003650 <HAL_TIM_PWM_Start+0x138>
  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
 80035e0:	2c04      	cmp	r4, #4
 80035e2:	d009      	beq.n	80035f8 <HAL_TIM_PWM_Start+0xe0>
 80035e4:	2c08      	cmp	r4, #8
 80035e6:	d00f      	beq.n	8003608 <HAL_TIM_PWM_Start+0xf0>
 80035e8:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
 80035ec:	b2db      	uxtb	r3, r3
 80035ee:	f113 33ff 	adds.w	r3, r3, #4294967295
 80035f2:	bf18      	it	ne
 80035f4:	2301      	movne	r3, #1
 80035f6:	e7be      	b.n	8003576 <HAL_TIM_PWM_Start+0x5e>
 80035f8:	f895 303f 	ldrb.w	r3, [r5, #63]	; 0x3f
 80035fc:	b2db      	uxtb	r3, r3
 80035fe:	f113 33ff 	adds.w	r3, r3, #4294967295
 8003602:	bf18      	it	ne
 8003604:	2301      	movne	r3, #1
 8003606:	e7b6      	b.n	8003576 <HAL_TIM_PWM_Start+0x5e>
 8003608:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
 800360c:	b2db      	uxtb	r3, r3
 800360e:	f113 33ff 	adds.w	r3, r3, #4294967295
 8003612:	bf18      	it	ne
 8003614:	2301      	movne	r3, #1
 8003616:	e7ae      	b.n	8003576 <HAL_TIM_PWM_Start+0x5e>
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8003618:	2c04      	cmp	r4, #4
 800361a:	d005      	beq.n	8003628 <HAL_TIM_PWM_Start+0x110>
 800361c:	2c08      	cmp	r4, #8
 800361e:	d007      	beq.n	8003630 <HAL_TIM_PWM_Start+0x118>
 8003620:	2302      	movs	r3, #2
 8003622:	f885 3041 	strb.w	r3, [r5, #65]	; 0x41
 8003626:	e7ad      	b.n	8003584 <HAL_TIM_PWM_Start+0x6c>
 8003628:	2302      	movs	r3, #2
 800362a:	f885 303f 	strb.w	r3, [r5, #63]	; 0x3f
 800362e:	e7a9      	b.n	8003584 <HAL_TIM_PWM_Start+0x6c>
 8003630:	2302      	movs	r3, #2
 8003632:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
 8003636:	e7a5      	b.n	8003584 <HAL_TIM_PWM_Start+0x6c>
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8003638:	689a      	ldr	r2, [r3, #8]
 800363a:	f002 0207 	and.w	r2, r2, #7
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800363e:	2a06      	cmp	r2, #6
 8003640:	d007      	beq.n	8003652 <HAL_TIM_PWM_Start+0x13a>
      __HAL_TIM_ENABLE(htim);
 8003642:	681a      	ldr	r2, [r3, #0]
 8003644:	f042 0201 	orr.w	r2, r2, #1
 8003648:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 800364a:	2000      	movs	r0, #0
 800364c:	e000      	b.n	8003650 <HAL_TIM_PWM_Start+0x138>
    return HAL_ERROR;
 800364e:	2001      	movs	r0, #1
}
 8003650:	bd38      	pop	{r3, r4, r5, pc}
  return HAL_OK;
 8003652:	2000      	movs	r0, #0
 8003654:	e7fc      	b.n	8003650 <HAL_TIM_PWM_Start+0x138>
 8003656:	bf00      	nop
 8003658:	40012c00 	.word	0x40012c00
 800365c:	08005e4c 	.word	0x08005e4c

08003660 <HAL_TIMEx_MasterConfigSynchronization>:
  *         mode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,
                                                        TIM_MasterConfigTypeDef *sMasterConfig)
{
 8003660:	b538      	push	{r3, r4, r5, lr}
 8003662:	4604      	mov	r4, r0
 8003664:	460d      	mov	r5, r1
  uint32_t tmpcr2;
  uint32_t tmpsmcr;

  /* Check the parameters */
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
 8003666:	6803      	ldr	r3, [r0, #0]
 8003668:	4a3d      	ldr	r2, [pc, #244]	; (8003760 <HAL_TIMEx_MasterConfigSynchronization+0x100>)
 800366a:	4293      	cmp	r3, r2
 800366c:	d01f      	beq.n	80036ae <HAL_TIMEx_MasterConfigSynchronization+0x4e>
 800366e:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8003672:	4293      	cmp	r3, r2
 8003674:	d01b      	beq.n	80036ae <HAL_TIMEx_MasterConfigSynchronization+0x4e>
 8003676:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800367a:	d018      	beq.n	80036ae <HAL_TIMEx_MasterConfigSynchronization+0x4e>
 800367c:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 8003680:	4293      	cmp	r3, r2
 8003682:	d014      	beq.n	80036ae <HAL_TIMEx_MasterConfigSynchronization+0x4e>
 8003684:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8003688:	4293      	cmp	r3, r2
 800368a:	d010      	beq.n	80036ae <HAL_TIMEx_MasterConfigSynchronization+0x4e>
 800368c:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8003690:	4293      	cmp	r3, r2
 8003692:	d00c      	beq.n	80036ae <HAL_TIMEx_MasterConfigSynchronization+0x4e>
 8003694:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8003698:	4293      	cmp	r3, r2
 800369a:	d008      	beq.n	80036ae <HAL_TIMEx_MasterConfigSynchronization+0x4e>
 800369c:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80036a0:	4293      	cmp	r3, r2
 80036a2:	d004      	beq.n	80036ae <HAL_TIMEx_MasterConfigSynchronization+0x4e>
 80036a4:	f240 715f 	movw	r1, #1887	; 0x75f
 80036a8:	482e      	ldr	r0, [pc, #184]	; (8003764 <HAL_TIMEx_MasterConfigSynchronization+0x104>)
 80036aa:	f002 f815 	bl	80056d8 <assert_failed>
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
 80036ae:	682b      	ldr	r3, [r5, #0]
 80036b0:	b16b      	cbz	r3, 80036ce <HAL_TIMEx_MasterConfigSynchronization+0x6e>
 80036b2:	2b10      	cmp	r3, #16
 80036b4:	d00b      	beq.n	80036ce <HAL_TIMEx_MasterConfigSynchronization+0x6e>
 80036b6:	2b20      	cmp	r3, #32
 80036b8:	d009      	beq.n	80036ce <HAL_TIMEx_MasterConfigSynchronization+0x6e>
 80036ba:	2b30      	cmp	r3, #48	; 0x30
 80036bc:	d007      	beq.n	80036ce <HAL_TIMEx_MasterConfigSynchronization+0x6e>
 80036be:	2b40      	cmp	r3, #64	; 0x40
 80036c0:	d005      	beq.n	80036ce <HAL_TIMEx_MasterConfigSynchronization+0x6e>
 80036c2:	2b50      	cmp	r3, #80	; 0x50
 80036c4:	d003      	beq.n	80036ce <HAL_TIMEx_MasterConfigSynchronization+0x6e>
 80036c6:	2b60      	cmp	r3, #96	; 0x60
 80036c8:	d001      	beq.n	80036ce <HAL_TIMEx_MasterConfigSynchronization+0x6e>
 80036ca:	2b70      	cmp	r3, #112	; 0x70
 80036cc:	d139      	bne.n	8003742 <HAL_TIMEx_MasterConfigSynchronization+0xe2>
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
 80036ce:	686b      	ldr	r3, [r5, #4]
 80036d0:	2b80      	cmp	r3, #128	; 0x80
 80036d2:	d001      	beq.n	80036d8 <HAL_TIMEx_MasterConfigSynchronization+0x78>
 80036d4:	2b00      	cmp	r3, #0
 80036d6:	d13a      	bne.n	800374e <HAL_TIMEx_MasterConfigSynchronization+0xee>

  /* Check input state */
  __HAL_LOCK(htim);
 80036d8:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
 80036dc:	2b01      	cmp	r3, #1
 80036de:	d03c      	beq.n	800375a <HAL_TIMEx_MasterConfigSynchronization+0xfa>
 80036e0:	2301      	movs	r3, #1
 80036e2:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;
 80036e6:	2302      	movs	r3, #2
 80036e8:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 80036ec:	6823      	ldr	r3, [r4, #0]
 80036ee:	6859      	ldr	r1, [r3, #4]

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;
 80036f0:	6898      	ldr	r0, [r3, #8]

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
 80036f2:	f021 0170 	bic.w	r1, r1, #112	; 0x70
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 80036f6:	682a      	ldr	r2, [r5, #0]
 80036f8:	430a      	orrs	r2, r1

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;
 80036fa:	605a      	str	r2, [r3, #4]

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 80036fc:	6823      	ldr	r3, [r4, #0]
 80036fe:	4a18      	ldr	r2, [pc, #96]	; (8003760 <HAL_TIMEx_MasterConfigSynchronization+0x100>)
 8003700:	4293      	cmp	r3, r2
 8003702:	d012      	beq.n	800372a <HAL_TIMEx_MasterConfigSynchronization+0xca>
 8003704:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8003708:	4293      	cmp	r3, r2
 800370a:	d00e      	beq.n	800372a <HAL_TIMEx_MasterConfigSynchronization+0xca>
 800370c:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8003710:	d00b      	beq.n	800372a <HAL_TIMEx_MasterConfigSynchronization+0xca>
 8003712:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 8003716:	4293      	cmp	r3, r2
 8003718:	d007      	beq.n	800372a <HAL_TIMEx_MasterConfigSynchronization+0xca>
 800371a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800371e:	4293      	cmp	r3, r2
 8003720:	d003      	beq.n	800372a <HAL_TIMEx_MasterConfigSynchronization+0xca>
 8003722:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8003726:	4293      	cmp	r3, r2
 8003728:	d104      	bne.n	8003734 <HAL_TIMEx_MasterConfigSynchronization+0xd4>
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
 800372a:	f020 0080 	bic.w	r0, r0, #128	; 0x80
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 800372e:	686a      	ldr	r2, [r5, #4]
 8003730:	4310      	orrs	r0, r2

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
 8003732:	6098      	str	r0, [r3, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
 8003734:	2301      	movs	r3, #1
 8003736:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d

  __HAL_UNLOCK(htim);
 800373a:	2000      	movs	r0, #0
 800373c:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c

  return HAL_OK;
}
 8003740:	bd38      	pop	{r3, r4, r5, pc}
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
 8003742:	f44f 61ec 	mov.w	r1, #1888	; 0x760
 8003746:	4807      	ldr	r0, [pc, #28]	; (8003764 <HAL_TIMEx_MasterConfigSynchronization+0x104>)
 8003748:	f001 ffc6 	bl	80056d8 <assert_failed>
 800374c:	e7bf      	b.n	80036ce <HAL_TIMEx_MasterConfigSynchronization+0x6e>
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
 800374e:	f240 7161 	movw	r1, #1889	; 0x761
 8003752:	4804      	ldr	r0, [pc, #16]	; (8003764 <HAL_TIMEx_MasterConfigSynchronization+0x104>)
 8003754:	f001 ffc0 	bl	80056d8 <assert_failed>
 8003758:	e7be      	b.n	80036d8 <HAL_TIMEx_MasterConfigSynchronization+0x78>
  __HAL_LOCK(htim);
 800375a:	2002      	movs	r0, #2
 800375c:	e7f0      	b.n	8003740 <HAL_TIMEx_MasterConfigSynchronization+0xe0>
 800375e:	bf00      	nop
 8003760:	40012c00 	.word	0x40012c00
 8003764:	08005e84 	.word	0x08005e84

08003768 <HAL_TIMEx_ConfigBreakDeadTime>:
  *         interrupt can be enabled by calling the @ref __HAL_TIM_ENABLE_IT macro.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim,
                                                TIM_BreakDeadTimeConfigTypeDef *sBreakDeadTimeConfig)
{
 8003768:	b538      	push	{r3, r4, r5, lr}
 800376a:	4604      	mov	r4, r0
 800376c:	460d      	mov	r5, r1
  /* Keep this variable initialized to 0 as it is used to configure BDTR register */
  uint32_t tmpbdtr = 0U;

  /* Check the parameters */
  assert_param(IS_TIM_BREAK_INSTANCE(htim->Instance));
 800376e:	6803      	ldr	r3, [r0, #0]
 8003770:	4a44      	ldr	r2, [pc, #272]	; (8003884 <HAL_TIMEx_ConfigBreakDeadTime+0x11c>)
 8003772:	4293      	cmp	r3, r2
 8003774:	d008      	beq.n	8003788 <HAL_TIMEx_ConfigBreakDeadTime+0x20>
 8003776:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 800377a:	4293      	cmp	r3, r2
 800377c:	d004      	beq.n	8003788 <HAL_TIMEx_ConfigBreakDeadTime+0x20>
 800377e:	f240 719c 	movw	r1, #1948	; 0x79c
 8003782:	4841      	ldr	r0, [pc, #260]	; (8003888 <HAL_TIMEx_ConfigBreakDeadTime+0x120>)
 8003784:	f001 ffa8 	bl	80056d8 <assert_failed>
  assert_param(IS_TIM_OSSR_STATE(sBreakDeadTimeConfig->OffStateRunMode));
 8003788:	682b      	ldr	r3, [r5, #0]
 800378a:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 800378e:	d001      	beq.n	8003794 <HAL_TIMEx_ConfigBreakDeadTime+0x2c>
 8003790:	2b00      	cmp	r3, #0
 8003792:	d14a      	bne.n	800382a <HAL_TIMEx_ConfigBreakDeadTime+0xc2>
  assert_param(IS_TIM_OSSI_STATE(sBreakDeadTimeConfig->OffStateIDLEMode));
 8003794:	686b      	ldr	r3, [r5, #4]
 8003796:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800379a:	d001      	beq.n	80037a0 <HAL_TIMEx_ConfigBreakDeadTime+0x38>
 800379c:	2b00      	cmp	r3, #0
 800379e:	d14a      	bne.n	8003836 <HAL_TIMEx_ConfigBreakDeadTime+0xce>
  assert_param(IS_TIM_LOCK_LEVEL(sBreakDeadTimeConfig->LockLevel));
 80037a0:	68ab      	ldr	r3, [r5, #8]
 80037a2:	b143      	cbz	r3, 80037b6 <HAL_TIMEx_ConfigBreakDeadTime+0x4e>
 80037a4:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 80037a8:	d005      	beq.n	80037b6 <HAL_TIMEx_ConfigBreakDeadTime+0x4e>
 80037aa:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80037ae:	d002      	beq.n	80037b6 <HAL_TIMEx_ConfigBreakDeadTime+0x4e>
 80037b0:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 80037b4:	d145      	bne.n	8003842 <HAL_TIMEx_ConfigBreakDeadTime+0xda>
  assert_param(IS_TIM_DEADTIME(sBreakDeadTimeConfig->DeadTime));
 80037b6:	68eb      	ldr	r3, [r5, #12]
 80037b8:	2bff      	cmp	r3, #255	; 0xff
 80037ba:	d848      	bhi.n	800384e <HAL_TIMEx_ConfigBreakDeadTime+0xe6>
  assert_param(IS_TIM_BREAK_STATE(sBreakDeadTimeConfig->BreakState));
 80037bc:	692b      	ldr	r3, [r5, #16]
 80037be:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80037c2:	d001      	beq.n	80037c8 <HAL_TIMEx_ConfigBreakDeadTime+0x60>
 80037c4:	2b00      	cmp	r3, #0
 80037c6:	d148      	bne.n	800385a <HAL_TIMEx_ConfigBreakDeadTime+0xf2>
  assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));
 80037c8:	696b      	ldr	r3, [r5, #20]
 80037ca:	b113      	cbz	r3, 80037d2 <HAL_TIMEx_ConfigBreakDeadTime+0x6a>
 80037cc:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 80037d0:	d149      	bne.n	8003866 <HAL_TIMEx_ConfigBreakDeadTime+0xfe>
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));
 80037d2:	69eb      	ldr	r3, [r5, #28]
 80037d4:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 80037d8:	d001      	beq.n	80037de <HAL_TIMEx_ConfigBreakDeadTime+0x76>
 80037da:	2b00      	cmp	r3, #0
 80037dc:	d149      	bne.n	8003872 <HAL_TIMEx_ConfigBreakDeadTime+0x10a>

  /* Check input state */
  __HAL_LOCK(htim);
 80037de:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
 80037e2:	2b01      	cmp	r3, #1
 80037e4:	d04b      	beq.n	800387e <HAL_TIMEx_ConfigBreakDeadTime+0x116>
 80037e6:	2301      	movs	r3, #1
 80037e8:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c

  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */

  /* Set the BDTR bits */
  MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig->DeadTime);
 80037ec:	68eb      	ldr	r3, [r5, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
 80037ee:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80037f2:	68aa      	ldr	r2, [r5, #8]
 80037f4:	4313      	orrs	r3, r2
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
 80037f6:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80037fa:	686a      	ldr	r2, [r5, #4]
 80037fc:	4313      	orrs	r3, r2
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
 80037fe:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8003802:	682a      	ldr	r2, [r5, #0]
 8003804:	4313      	orrs	r3, r2
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
 8003806:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800380a:	692a      	ldr	r2, [r5, #16]
 800380c:	4313      	orrs	r3, r2
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
 800380e:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8003812:	696a      	ldr	r2, [r5, #20]
 8003814:	4313      	orrs	r3, r2
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 8003816:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800381a:	69ea      	ldr	r2, [r5, #28]
 800381c:	4313      	orrs	r3, r2


  /* Set TIMx_BDTR */
  htim->Instance->BDTR = tmpbdtr;
 800381e:	6822      	ldr	r2, [r4, #0]
 8003820:	6453      	str	r3, [r2, #68]	; 0x44

  __HAL_UNLOCK(htim);
 8003822:	2000      	movs	r0, #0
 8003824:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c

  return HAL_OK;
}
 8003828:	bd38      	pop	{r3, r4, r5, pc}
  assert_param(IS_TIM_OSSR_STATE(sBreakDeadTimeConfig->OffStateRunMode));
 800382a:	f240 719d 	movw	r1, #1949	; 0x79d
 800382e:	4816      	ldr	r0, [pc, #88]	; (8003888 <HAL_TIMEx_ConfigBreakDeadTime+0x120>)
 8003830:	f001 ff52 	bl	80056d8 <assert_failed>
 8003834:	e7ae      	b.n	8003794 <HAL_TIMEx_ConfigBreakDeadTime+0x2c>
  assert_param(IS_TIM_OSSI_STATE(sBreakDeadTimeConfig->OffStateIDLEMode));
 8003836:	f240 719e 	movw	r1, #1950	; 0x79e
 800383a:	4813      	ldr	r0, [pc, #76]	; (8003888 <HAL_TIMEx_ConfigBreakDeadTime+0x120>)
 800383c:	f001 ff4c 	bl	80056d8 <assert_failed>
 8003840:	e7ae      	b.n	80037a0 <HAL_TIMEx_ConfigBreakDeadTime+0x38>
  assert_param(IS_TIM_LOCK_LEVEL(sBreakDeadTimeConfig->LockLevel));
 8003842:	f240 719f 	movw	r1, #1951	; 0x79f
 8003846:	4810      	ldr	r0, [pc, #64]	; (8003888 <HAL_TIMEx_ConfigBreakDeadTime+0x120>)
 8003848:	f001 ff46 	bl	80056d8 <assert_failed>
 800384c:	e7b3      	b.n	80037b6 <HAL_TIMEx_ConfigBreakDeadTime+0x4e>
  assert_param(IS_TIM_DEADTIME(sBreakDeadTimeConfig->DeadTime));
 800384e:	f44f 61f4 	mov.w	r1, #1952	; 0x7a0
 8003852:	480d      	ldr	r0, [pc, #52]	; (8003888 <HAL_TIMEx_ConfigBreakDeadTime+0x120>)
 8003854:	f001 ff40 	bl	80056d8 <assert_failed>
 8003858:	e7b0      	b.n	80037bc <HAL_TIMEx_ConfigBreakDeadTime+0x54>
  assert_param(IS_TIM_BREAK_STATE(sBreakDeadTimeConfig->BreakState));
 800385a:	f240 71a1 	movw	r1, #1953	; 0x7a1
 800385e:	480a      	ldr	r0, [pc, #40]	; (8003888 <HAL_TIMEx_ConfigBreakDeadTime+0x120>)
 8003860:	f001 ff3a 	bl	80056d8 <assert_failed>
 8003864:	e7b0      	b.n	80037c8 <HAL_TIMEx_ConfigBreakDeadTime+0x60>
  assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));
 8003866:	f240 71a2 	movw	r1, #1954	; 0x7a2
 800386a:	4807      	ldr	r0, [pc, #28]	; (8003888 <HAL_TIMEx_ConfigBreakDeadTime+0x120>)
 800386c:	f001 ff34 	bl	80056d8 <assert_failed>
 8003870:	e7af      	b.n	80037d2 <HAL_TIMEx_ConfigBreakDeadTime+0x6a>
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));
 8003872:	f240 71a3 	movw	r1, #1955	; 0x7a3
 8003876:	4804      	ldr	r0, [pc, #16]	; (8003888 <HAL_TIMEx_ConfigBreakDeadTime+0x120>)
 8003878:	f001 ff2e 	bl	80056d8 <assert_failed>
 800387c:	e7af      	b.n	80037de <HAL_TIMEx_ConfigBreakDeadTime+0x76>
  __HAL_LOCK(htim);
 800387e:	2002      	movs	r0, #2
 8003880:	e7d2      	b.n	8003828 <HAL_TIMEx_ConfigBreakDeadTime+0xc0>
 8003882:	bf00      	nop
 8003884:	40012c00 	.word	0x40012c00
 8003888:	08005e84 	.word	0x08005e84

0800388c <UART_EndTxTransfer>:
  * @retval None
  */
static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
{
  /* Disable TXEIE and TCIE interrupts */
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
 800388c:	6802      	ldr	r2, [r0, #0]
 800388e:	68d3      	ldr	r3, [r2, #12]
 8003890:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8003894:	60d3      	str	r3, [r2, #12]

  /* At end of Tx process, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 8003896:	2320      	movs	r3, #32
 8003898:	f880 3039 	strb.w	r3, [r0, #57]	; 0x39
}
 800389c:	4770      	bx	lr

0800389e <UART_EndRxTransfer>:
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 800389e:	6802      	ldr	r2, [r0, #0]
 80038a0:	68d3      	ldr	r3, [r2, #12]
 80038a2:	f423 7390 	bic.w	r3, r3, #288	; 0x120
 80038a6:	60d3      	str	r3, [r2, #12]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80038a8:	6802      	ldr	r2, [r0, #0]
 80038aa:	6953      	ldr	r3, [r2, #20]
 80038ac:	f023 0301 	bic.w	r3, r3, #1
 80038b0:	6153      	str	r3, [r2, #20]

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 80038b2:	2320      	movs	r3, #32
 80038b4:	f880 303a 	strb.w	r3, [r0, #58]	; 0x3a
}
 80038b8:	4770      	bx	lr

080038ba <UART_Transmit_IT>:
static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
{
  uint16_t *tmp;

  /* Check that a Tx process is ongoing */
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
 80038ba:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 80038be:	b2db      	uxtb	r3, r3
 80038c0:	2b21      	cmp	r3, #33	; 0x21
 80038c2:	d127      	bne.n	8003914 <UART_Transmit_IT+0x5a>
  {
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 80038c4:	6883      	ldr	r3, [r0, #8]
 80038c6:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80038ca:	d016      	beq.n	80038fa <UART_Transmit_IT+0x40>
      huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
      huart->pTxBuffPtr += 2U;
    }
    else
    {
      huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
 80038cc:	6a03      	ldr	r3, [r0, #32]
 80038ce:	1c5a      	adds	r2, r3, #1
 80038d0:	6202      	str	r2, [r0, #32]
 80038d2:	781a      	ldrb	r2, [r3, #0]
 80038d4:	6803      	ldr	r3, [r0, #0]
 80038d6:	605a      	str	r2, [r3, #4]
    }

    if (--huart->TxXferCount == 0U)
 80038d8:	8cc3      	ldrh	r3, [r0, #38]	; 0x26
 80038da:	3b01      	subs	r3, #1
 80038dc:	b29b      	uxth	r3, r3
 80038de:	84c3      	strh	r3, [r0, #38]	; 0x26
 80038e0:	b9d3      	cbnz	r3, 8003918 <UART_Transmit_IT+0x5e>
    {
      /* Disable the UART Transmit Complete Interrupt */
      __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
 80038e2:	6802      	ldr	r2, [r0, #0]
 80038e4:	68d3      	ldr	r3, [r2, #12]
 80038e6:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80038ea:	60d3      	str	r3, [r2, #12]

      /* Enable the UART Transmit Complete Interrupt */
      __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
 80038ec:	6802      	ldr	r2, [r0, #0]
 80038ee:	68d3      	ldr	r3, [r2, #12]
 80038f0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80038f4:	60d3      	str	r3, [r2, #12]
    }
    return HAL_OK;
 80038f6:	2000      	movs	r0, #0
 80038f8:	4770      	bx	lr
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 80038fa:	6903      	ldr	r3, [r0, #16]
 80038fc:	2b00      	cmp	r3, #0
 80038fe:	d1e5      	bne.n	80038cc <UART_Transmit_IT+0x12>
      tmp = (uint16_t *) huart->pTxBuffPtr;
 8003900:	6a03      	ldr	r3, [r0, #32]
      huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
 8003902:	881b      	ldrh	r3, [r3, #0]
 8003904:	6802      	ldr	r2, [r0, #0]
 8003906:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800390a:	6053      	str	r3, [r2, #4]
      huart->pTxBuffPtr += 2U;
 800390c:	6a03      	ldr	r3, [r0, #32]
 800390e:	3302      	adds	r3, #2
 8003910:	6203      	str	r3, [r0, #32]
 8003912:	e7e1      	b.n	80038d8 <UART_Transmit_IT+0x1e>
  }
  else
  {
    return HAL_BUSY;
 8003914:	2002      	movs	r0, #2
 8003916:	4770      	bx	lr
    return HAL_OK;
 8003918:	2000      	movs	r0, #0
  }
}
 800391a:	4770      	bx	lr

0800391c <UART_SetConfig>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_SetConfig(UART_HandleTypeDef *huart)
{
 800391c:	b538      	push	{r3, r4, r5, lr}
 800391e:	4604      	mov	r4, r0
  uint32_t tmpreg;
  uint32_t pclk;

  /* Check the parameters */
  assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
 8003920:	6842      	ldr	r2, [r0, #4]
 8003922:	4b37      	ldr	r3, [pc, #220]	; (8003a00 <UART_SetConfig+0xe4>)
 8003924:	429a      	cmp	r2, r3
 8003926:	d856      	bhi.n	80039d6 <UART_SetConfig+0xba>
  assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
 8003928:	68e3      	ldr	r3, [r4, #12]
 800392a:	b113      	cbz	r3, 8003932 <UART_SetConfig+0x16>
 800392c:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8003930:	d157      	bne.n	80039e2 <UART_SetConfig+0xc6>
  assert_param(IS_UART_PARITY(huart->Init.Parity));
 8003932:	6923      	ldr	r3, [r4, #16]
 8003934:	b12b      	cbz	r3, 8003942 <UART_SetConfig+0x26>
 8003936:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800393a:	d002      	beq.n	8003942 <UART_SetConfig+0x26>
 800393c:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 8003940:	d155      	bne.n	80039ee <UART_SetConfig+0xd2>
  assert_param(IS_UART_MODE(huart->Init.Mode));
 8003942:	6963      	ldr	r3, [r4, #20]
 8003944:	f64f 72f3 	movw	r2, #65523	; 0xfff3
 8003948:	4213      	tst	r3, r2
 800394a:	d100      	bne.n	800394e <UART_SetConfig+0x32>
 800394c:	b923      	cbnz	r3, 8003958 <UART_SetConfig+0x3c>
 800394e:	f640 31f9 	movw	r1, #3065	; 0xbf9
 8003952:	482c      	ldr	r0, [pc, #176]	; (8003a04 <UART_SetConfig+0xe8>)
 8003954:	f001 fec0 	bl	80056d8 <assert_failed>

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits
     according to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8003958:	6822      	ldr	r2, [r4, #0]
 800395a:	6913      	ldr	r3, [r2, #16]
 800395c:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 8003960:	68e1      	ldr	r1, [r4, #12]
 8003962:	430b      	orrs	r3, r1
 8003964:	6113      	str	r3, [r2, #16]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
  MODIFY_REG(huart->Instance->CR1,
             (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),
             tmpreg);
#else
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode;
 8003966:	68a3      	ldr	r3, [r4, #8]
 8003968:	6922      	ldr	r2, [r4, #16]
 800396a:	4313      	orrs	r3, r2
 800396c:	6962      	ldr	r2, [r4, #20]
 800396e:	431a      	orrs	r2, r3
  MODIFY_REG(huart->Instance->CR1,
 8003970:	6821      	ldr	r1, [r4, #0]
 8003972:	68cb      	ldr	r3, [r1, #12]
 8003974:	f423 53b0 	bic.w	r3, r3, #5632	; 0x1600
 8003978:	f023 030c 	bic.w	r3, r3, #12
 800397c:	4313      	orrs	r3, r2
 800397e:	60cb      	str	r3, [r1, #12]
             tmpreg);
#endif /* USART_CR1_OVER8 */

  /*-------------------------- USART CR3 Configuration -----------------------*/
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
 8003980:	6822      	ldr	r2, [r4, #0]
 8003982:	6953      	ldr	r3, [r2, #20]
 8003984:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8003988:	69a1      	ldr	r1, [r4, #24]
 800398a:	430b      	orrs	r3, r1
 800398c:	6153      	str	r3, [r2, #20]


  if(huart->Instance == USART1)
 800398e:	6822      	ldr	r2, [r4, #0]
 8003990:	4b1d      	ldr	r3, [pc, #116]	; (8003a08 <UART_SetConfig+0xec>)
 8003992:	429a      	cmp	r2, r3
 8003994:	d031      	beq.n	80039fa <UART_SetConfig+0xde>
  {
    pclk = HAL_RCC_GetPCLK2Freq();
  }
  else
  {
    pclk = HAL_RCC_GetPCLK1Freq();
 8003996:	f7ff fa33 	bl	8002e00 <HAL_RCC_GetPCLK1Freq>
  else
  {
    huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
  }
#else
  huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
 800399a:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800399e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80039a2:	6863      	ldr	r3, [r4, #4]
 80039a4:	009b      	lsls	r3, r3, #2
 80039a6:	fbb0 f0f3 	udiv	r0, r0, r3
 80039aa:	4d18      	ldr	r5, [pc, #96]	; (8003a0c <UART_SetConfig+0xf0>)
 80039ac:	fba5 3200 	umull	r3, r2, r5, r0
 80039b0:	0951      	lsrs	r1, r2, #5
 80039b2:	2264      	movs	r2, #100	; 0x64
 80039b4:	fb02 0211 	mls	r2, r2, r1, r0
 80039b8:	0113      	lsls	r3, r2, #4
 80039ba:	3332      	adds	r3, #50	; 0x32
 80039bc:	fba5 2303 	umull	r2, r3, r5, r3
 80039c0:	095b      	lsrs	r3, r3, #5
 80039c2:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 80039c6:	eb02 1201 	add.w	r2, r2, r1, lsl #4
 80039ca:	f003 030f 	and.w	r3, r3, #15
 80039ce:	6821      	ldr	r1, [r4, #0]
 80039d0:	4413      	add	r3, r2
 80039d2:	608b      	str	r3, [r1, #8]
#endif /* USART_CR1_OVER8 */
}
 80039d4:	bd38      	pop	{r3, r4, r5, pc}
  assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
 80039d6:	f640 31f6 	movw	r1, #3062	; 0xbf6
 80039da:	480a      	ldr	r0, [pc, #40]	; (8003a04 <UART_SetConfig+0xe8>)
 80039dc:	f001 fe7c 	bl	80056d8 <assert_failed>
 80039e0:	e7a2      	b.n	8003928 <UART_SetConfig+0xc>
  assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
 80039e2:	f640 31f7 	movw	r1, #3063	; 0xbf7
 80039e6:	4807      	ldr	r0, [pc, #28]	; (8003a04 <UART_SetConfig+0xe8>)
 80039e8:	f001 fe76 	bl	80056d8 <assert_failed>
 80039ec:	e7a1      	b.n	8003932 <UART_SetConfig+0x16>
  assert_param(IS_UART_PARITY(huart->Init.Parity));
 80039ee:	f640 31f8 	movw	r1, #3064	; 0xbf8
 80039f2:	4804      	ldr	r0, [pc, #16]	; (8003a04 <UART_SetConfig+0xe8>)
 80039f4:	f001 fe70 	bl	80056d8 <assert_failed>
 80039f8:	e7a3      	b.n	8003942 <UART_SetConfig+0x26>
    pclk = HAL_RCC_GetPCLK2Freq();
 80039fa:	f7ff fa11 	bl	8002e20 <HAL_RCC_GetPCLK2Freq>
 80039fe:	e7cc      	b.n	800399a <UART_SetConfig+0x7e>
 8003a00:	0044aa20 	.word	0x0044aa20
 8003a04:	08005ec0 	.word	0x08005ec0
 8003a08:	40013800 	.word	0x40013800
 8003a0c:	51eb851f 	.word	0x51eb851f

08003a10 <HAL_UART_Init>:
  if (huart == NULL)
 8003a10:	2800      	cmp	r0, #0
 8003a12:	d074      	beq.n	8003afe <HAL_UART_Init+0xee>
{
 8003a14:	b510      	push	{r4, lr}
 8003a16:	4604      	mov	r4, r0
  if (huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
 8003a18:	6983      	ldr	r3, [r0, #24]
 8003a1a:	b30b      	cbz	r3, 8003a60 <HAL_UART_Init+0x50>
    assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
 8003a1c:	6803      	ldr	r3, [r0, #0]
 8003a1e:	4a39      	ldr	r2, [pc, #228]	; (8003b04 <HAL_UART_Init+0xf4>)
 8003a20:	4293      	cmp	r3, r2
 8003a22:	d00c      	beq.n	8003a3e <HAL_UART_Init+0x2e>
 8003a24:	f5a2 4274 	sub.w	r2, r2, #62464	; 0xf400
 8003a28:	4293      	cmp	r3, r2
 8003a2a:	d008      	beq.n	8003a3e <HAL_UART_Init+0x2e>
 8003a2c:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8003a30:	4293      	cmp	r3, r2
 8003a32:	d004      	beq.n	8003a3e <HAL_UART_Init+0x2e>
 8003a34:	f44f 71a3 	mov.w	r1, #326	; 0x146
 8003a38:	4833      	ldr	r0, [pc, #204]	; (8003b08 <HAL_UART_Init+0xf8>)
 8003a3a:	f001 fe4d 	bl	80056d8 <assert_failed>
    assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
 8003a3e:	69a3      	ldr	r3, [r4, #24]
 8003a40:	b33b      	cbz	r3, 8003a92 <HAL_UART_Init+0x82>
 8003a42:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8003a46:	d024      	beq.n	8003a92 <HAL_UART_Init+0x82>
 8003a48:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8003a4c:	d021      	beq.n	8003a92 <HAL_UART_Init+0x82>
 8003a4e:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8003a52:	d01e      	beq.n	8003a92 <HAL_UART_Init+0x82>
 8003a54:	f240 1147 	movw	r1, #327	; 0x147
 8003a58:	482b      	ldr	r0, [pc, #172]	; (8003b08 <HAL_UART_Init+0xf8>)
 8003a5a:	f001 fe3d 	bl	80056d8 <assert_failed>
 8003a5e:	e018      	b.n	8003a92 <HAL_UART_Init+0x82>
    assert_param(IS_UART_INSTANCE(huart->Instance));
 8003a60:	6803      	ldr	r3, [r0, #0]
 8003a62:	4a28      	ldr	r2, [pc, #160]	; (8003b04 <HAL_UART_Init+0xf4>)
 8003a64:	4293      	cmp	r3, r2
 8003a66:	d014      	beq.n	8003a92 <HAL_UART_Init+0x82>
 8003a68:	f5a2 4274 	sub.w	r2, r2, #62464	; 0xf400
 8003a6c:	4293      	cmp	r3, r2
 8003a6e:	d010      	beq.n	8003a92 <HAL_UART_Init+0x82>
 8003a70:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8003a74:	4293      	cmp	r3, r2
 8003a76:	d00c      	beq.n	8003a92 <HAL_UART_Init+0x82>
 8003a78:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8003a7c:	4293      	cmp	r3, r2
 8003a7e:	d008      	beq.n	8003a92 <HAL_UART_Init+0x82>
 8003a80:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8003a84:	4293      	cmp	r3, r2
 8003a86:	d004      	beq.n	8003a92 <HAL_UART_Init+0x82>
 8003a88:	f240 114b 	movw	r1, #331	; 0x14b
 8003a8c:	481e      	ldr	r0, [pc, #120]	; (8003b08 <HAL_UART_Init+0xf8>)
 8003a8e:	f001 fe23 	bl	80056d8 <assert_failed>
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
 8003a92:	68a3      	ldr	r3, [r4, #8]
 8003a94:	b113      	cbz	r3, 8003a9c <HAL_UART_Init+0x8c>
 8003a96:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8003a9a:	d124      	bne.n	8003ae6 <HAL_UART_Init+0xd6>
  if (huart->gState == HAL_UART_STATE_RESET)
 8003a9c:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
 8003aa0:	b33b      	cbz	r3, 8003af2 <HAL_UART_Init+0xe2>
  huart->gState = HAL_UART_STATE_BUSY;
 8003aa2:	2324      	movs	r3, #36	; 0x24
 8003aa4:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  __HAL_UART_DISABLE(huart);
 8003aa8:	6822      	ldr	r2, [r4, #0]
 8003aaa:	68d3      	ldr	r3, [r2, #12]
 8003aac:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8003ab0:	60d3      	str	r3, [r2, #12]
  UART_SetConfig(huart);
 8003ab2:	4620      	mov	r0, r4
 8003ab4:	f7ff ff32 	bl	800391c <UART_SetConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8003ab8:	6822      	ldr	r2, [r4, #0]
 8003aba:	6913      	ldr	r3, [r2, #16]
 8003abc:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 8003ac0:	6113      	str	r3, [r2, #16]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8003ac2:	6822      	ldr	r2, [r4, #0]
 8003ac4:	6953      	ldr	r3, [r2, #20]
 8003ac6:	f023 032a 	bic.w	r3, r3, #42	; 0x2a
 8003aca:	6153      	str	r3, [r2, #20]
  __HAL_UART_ENABLE(huart);
 8003acc:	6822      	ldr	r2, [r4, #0]
 8003ace:	68d3      	ldr	r3, [r2, #12]
 8003ad0:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8003ad4:	60d3      	str	r3, [r2, #12]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003ad6:	2000      	movs	r0, #0
 8003ad8:	63e0      	str	r0, [r4, #60]	; 0x3c
  huart->gState = HAL_UART_STATE_READY;
 8003ada:	2320      	movs	r3, #32
 8003adc:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  huart->RxState = HAL_UART_STATE_READY;
 8003ae0:	f884 303a 	strb.w	r3, [r4, #58]	; 0x3a
}
 8003ae4:	bd10      	pop	{r4, pc}
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
 8003ae6:	f240 114d 	movw	r1, #333	; 0x14d
 8003aea:	4807      	ldr	r0, [pc, #28]	; (8003b08 <HAL_UART_Init+0xf8>)
 8003aec:	f001 fdf4 	bl	80056d8 <assert_failed>
 8003af0:	e7d4      	b.n	8003a9c <HAL_UART_Init+0x8c>
    huart->Lock = HAL_UNLOCKED;
 8003af2:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
    HAL_UART_MspInit(huart);
 8003af6:	4620      	mov	r0, r4
 8003af8:	f001 ffa0 	bl	8005a3c <HAL_UART_MspInit>
 8003afc:	e7d1      	b.n	8003aa2 <HAL_UART_Init+0x92>
    return HAL_ERROR;
 8003afe:	2001      	movs	r0, #1
}
 8003b00:	4770      	bx	lr
 8003b02:	bf00      	nop
 8003b04:	40013800 	.word	0x40013800
 8003b08:	08005ec0 	.word	0x08005ec0

08003b0c <HAL_UART_Transmit_DMA>:
{
 8003b0c:	b538      	push	{r3, r4, r5, lr}
  if (huart->gState == HAL_UART_STATE_READY)
 8003b0e:	f890 4039 	ldrb.w	r4, [r0, #57]	; 0x39
 8003b12:	b2e4      	uxtb	r4, r4
 8003b14:	2c20      	cmp	r4, #32
 8003b16:	d131      	bne.n	8003b7c <HAL_UART_Transmit_DMA+0x70>
    if ((pData == NULL) || (Size == 0U))
 8003b18:	2900      	cmp	r1, #0
 8003b1a:	d031      	beq.n	8003b80 <HAL_UART_Transmit_DMA+0x74>
 8003b1c:	2a00      	cmp	r2, #0
 8003b1e:	d031      	beq.n	8003b84 <HAL_UART_Transmit_DMA+0x78>
    __HAL_LOCK(huart);
 8003b20:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
 8003b24:	2b01      	cmp	r3, #1
 8003b26:	d02f      	beq.n	8003b88 <HAL_UART_Transmit_DMA+0x7c>
 8003b28:	4613      	mov	r3, r2
 8003b2a:	4604      	mov	r4, r0
 8003b2c:	2201      	movs	r2, #1
 8003b2e:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
    huart->pTxBuffPtr = pData;
 8003b32:	6201      	str	r1, [r0, #32]
    huart->TxXferSize = Size;
 8003b34:	8483      	strh	r3, [r0, #36]	; 0x24
    huart->TxXferCount = Size;
 8003b36:	84c3      	strh	r3, [r0, #38]	; 0x26
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003b38:	2500      	movs	r5, #0
 8003b3a:	63c5      	str	r5, [r0, #60]	; 0x3c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8003b3c:	2221      	movs	r2, #33	; 0x21
 8003b3e:	f880 2039 	strb.w	r2, [r0, #57]	; 0x39
    huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
 8003b42:	6b02      	ldr	r2, [r0, #48]	; 0x30
 8003b44:	4811      	ldr	r0, [pc, #68]	; (8003b8c <HAL_UART_Transmit_DMA+0x80>)
 8003b46:	6290      	str	r0, [r2, #40]	; 0x28
    huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
 8003b48:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8003b4a:	4811      	ldr	r0, [pc, #68]	; (8003b90 <HAL_UART_Transmit_DMA+0x84>)
 8003b4c:	62d0      	str	r0, [r2, #44]	; 0x2c
    huart->hdmatx->XferErrorCallback = UART_DMAError;
 8003b4e:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8003b50:	4810      	ldr	r0, [pc, #64]	; (8003b94 <HAL_UART_Transmit_DMA+0x88>)
 8003b52:	6310      	str	r0, [r2, #48]	; 0x30
    huart->hdmatx->XferAbortCallback = NULL;
 8003b54:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8003b56:	6355      	str	r5, [r2, #52]	; 0x34
    HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t *)tmp, (uint32_t)&huart->Instance->DR, Size);
 8003b58:	6822      	ldr	r2, [r4, #0]
 8003b5a:	3204      	adds	r2, #4
 8003b5c:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8003b5e:	f7fd f819 	bl	8000b94 <HAL_DMA_Start_IT>
    __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);
 8003b62:	6823      	ldr	r3, [r4, #0]
 8003b64:	f06f 0240 	mvn.w	r2, #64	; 0x40
 8003b68:	601a      	str	r2, [r3, #0]
    __HAL_UNLOCK(huart);
 8003b6a:	f884 5038 	strb.w	r5, [r4, #56]	; 0x38
    SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 8003b6e:	6822      	ldr	r2, [r4, #0]
 8003b70:	6953      	ldr	r3, [r2, #20]
 8003b72:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003b76:	6153      	str	r3, [r2, #20]
    return HAL_OK;
 8003b78:	4628      	mov	r0, r5
 8003b7a:	e000      	b.n	8003b7e <HAL_UART_Transmit_DMA+0x72>
    return HAL_BUSY;
 8003b7c:	2002      	movs	r0, #2
}
 8003b7e:	bd38      	pop	{r3, r4, r5, pc}
      return HAL_ERROR;
 8003b80:	2001      	movs	r0, #1
 8003b82:	e7fc      	b.n	8003b7e <HAL_UART_Transmit_DMA+0x72>
 8003b84:	2001      	movs	r0, #1
 8003b86:	e7fa      	b.n	8003b7e <HAL_UART_Transmit_DMA+0x72>
    __HAL_LOCK(huart);
 8003b88:	2002      	movs	r0, #2
 8003b8a:	e7f8      	b.n	8003b7e <HAL_UART_Transmit_DMA+0x72>
 8003b8c:	08003c43 	.word	0x08003c43
 8003b90:	08003c8f 	.word	0x08003c8f
 8003b94:	08003d79 	.word	0x08003d79

08003b98 <HAL_UART_Receive_DMA>:
{
 8003b98:	b530      	push	{r4, r5, lr}
 8003b9a:	b083      	sub	sp, #12
  if (huart->RxState == HAL_UART_STATE_READY)
 8003b9c:	f890 403a 	ldrb.w	r4, [r0, #58]	; 0x3a
 8003ba0:	b2e4      	uxtb	r4, r4
 8003ba2:	2c20      	cmp	r4, #32
 8003ba4:	d13d      	bne.n	8003c22 <HAL_UART_Receive_DMA+0x8a>
    if ((pData == NULL) || (Size == 0U))
 8003ba6:	2900      	cmp	r1, #0
 8003ba8:	d03e      	beq.n	8003c28 <HAL_UART_Receive_DMA+0x90>
 8003baa:	2a00      	cmp	r2, #0
 8003bac:	d03e      	beq.n	8003c2c <HAL_UART_Receive_DMA+0x94>
    __HAL_LOCK(huart);
 8003bae:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
 8003bb2:	2b01      	cmp	r3, #1
 8003bb4:	d03c      	beq.n	8003c30 <HAL_UART_Receive_DMA+0x98>
 8003bb6:	4613      	mov	r3, r2
 8003bb8:	460a      	mov	r2, r1
 8003bba:	4604      	mov	r4, r0
 8003bbc:	2101      	movs	r1, #1
 8003bbe:	f880 1038 	strb.w	r1, [r0, #56]	; 0x38
    huart->pRxBuffPtr = pData;
 8003bc2:	6282      	str	r2, [r0, #40]	; 0x28
    huart->RxXferSize = Size;
 8003bc4:	8583      	strh	r3, [r0, #44]	; 0x2c
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003bc6:	2500      	movs	r5, #0
 8003bc8:	63c5      	str	r5, [r0, #60]	; 0x3c
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 8003bca:	2122      	movs	r1, #34	; 0x22
 8003bcc:	f880 103a 	strb.w	r1, [r0, #58]	; 0x3a
    huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
 8003bd0:	6b41      	ldr	r1, [r0, #52]	; 0x34
 8003bd2:	4818      	ldr	r0, [pc, #96]	; (8003c34 <HAL_UART_Receive_DMA+0x9c>)
 8003bd4:	6288      	str	r0, [r1, #40]	; 0x28
    huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
 8003bd6:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8003bd8:	4817      	ldr	r0, [pc, #92]	; (8003c38 <HAL_UART_Receive_DMA+0xa0>)
 8003bda:	62c8      	str	r0, [r1, #44]	; 0x2c
    huart->hdmarx->XferErrorCallback = UART_DMAError;
 8003bdc:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8003bde:	4817      	ldr	r0, [pc, #92]	; (8003c3c <HAL_UART_Receive_DMA+0xa4>)
 8003be0:	6308      	str	r0, [r1, #48]	; 0x30
    huart->hdmarx->XferAbortCallback = NULL;
 8003be2:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8003be4:	634d      	str	r5, [r1, #52]	; 0x34
    HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t *)tmp, Size);
 8003be6:	6821      	ldr	r1, [r4, #0]
 8003be8:	3104      	adds	r1, #4
 8003bea:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8003bec:	f7fc ffd2 	bl	8000b94 <HAL_DMA_Start_IT>
    __HAL_UART_CLEAR_OREFLAG(huart);
 8003bf0:	9501      	str	r5, [sp, #4]
 8003bf2:	6823      	ldr	r3, [r4, #0]
 8003bf4:	681a      	ldr	r2, [r3, #0]
 8003bf6:	9201      	str	r2, [sp, #4]
 8003bf8:	685a      	ldr	r2, [r3, #4]
 8003bfa:	9201      	str	r2, [sp, #4]
 8003bfc:	9a01      	ldr	r2, [sp, #4]
    __HAL_UNLOCK(huart);
 8003bfe:	f884 5038 	strb.w	r5, [r4, #56]	; 0x38
    SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8003c02:	68da      	ldr	r2, [r3, #12]
 8003c04:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8003c08:	60da      	str	r2, [r3, #12]
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8003c0a:	6822      	ldr	r2, [r4, #0]
 8003c0c:	6953      	ldr	r3, [r2, #20]
 8003c0e:	f043 0301 	orr.w	r3, r3, #1
 8003c12:	6153      	str	r3, [r2, #20]
    SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8003c14:	6822      	ldr	r2, [r4, #0]
 8003c16:	6953      	ldr	r3, [r2, #20]
 8003c18:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8003c1c:	6153      	str	r3, [r2, #20]
    return HAL_OK;
 8003c1e:	4628      	mov	r0, r5
 8003c20:	e000      	b.n	8003c24 <HAL_UART_Receive_DMA+0x8c>
    return HAL_BUSY;
 8003c22:	2002      	movs	r0, #2
}
 8003c24:	b003      	add	sp, #12
 8003c26:	bd30      	pop	{r4, r5, pc}
      return HAL_ERROR;
 8003c28:	2001      	movs	r0, #1
 8003c2a:	e7fb      	b.n	8003c24 <HAL_UART_Receive_DMA+0x8c>
 8003c2c:	2001      	movs	r0, #1
 8003c2e:	e7f9      	b.n	8003c24 <HAL_UART_Receive_DMA+0x8c>
    __HAL_LOCK(huart);
 8003c30:	2002      	movs	r0, #2
 8003c32:	e7f7      	b.n	8003c24 <HAL_UART_Receive_DMA+0x8c>
 8003c34:	08003c9b 	.word	0x08003c9b
 8003c38:	08003d6d 	.word	0x08003d6d
 8003c3c:	08003d79 	.word	0x08003d79

08003c40 <HAL_UART_TxCpltCallback>:
}
 8003c40:	4770      	bx	lr

08003c42 <UART_DMATransmitCplt>:
{
 8003c42:	b508      	push	{r3, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8003c44:	6a43      	ldr	r3, [r0, #36]	; 0x24
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 8003c46:	6802      	ldr	r2, [r0, #0]
 8003c48:	6812      	ldr	r2, [r2, #0]
 8003c4a:	f012 0f20 	tst.w	r2, #32
 8003c4e:	d10c      	bne.n	8003c6a <UART_DMATransmitCplt+0x28>
    huart->TxXferCount = 0x00U;
 8003c50:	2200      	movs	r2, #0
 8003c52:	84da      	strh	r2, [r3, #38]	; 0x26
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 8003c54:	6819      	ldr	r1, [r3, #0]
 8003c56:	694a      	ldr	r2, [r1, #20]
 8003c58:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8003c5c:	614a      	str	r2, [r1, #20]
    SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8003c5e:	681a      	ldr	r2, [r3, #0]
 8003c60:	68d3      	ldr	r3, [r2, #12]
 8003c62:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8003c66:	60d3      	str	r3, [r2, #12]
}
 8003c68:	bd08      	pop	{r3, pc}
    HAL_UART_TxCpltCallback(huart);
 8003c6a:	4618      	mov	r0, r3
 8003c6c:	f7ff ffe8 	bl	8003c40 <HAL_UART_TxCpltCallback>
}
 8003c70:	e7fa      	b.n	8003c68 <UART_DMATransmitCplt+0x26>

08003c72 <UART_EndTransmit_IT>:
{
 8003c72:	b508      	push	{r3, lr}
  __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
 8003c74:	6801      	ldr	r1, [r0, #0]
 8003c76:	68cb      	ldr	r3, [r1, #12]
 8003c78:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8003c7c:	60cb      	str	r3, [r1, #12]
  huart->gState = HAL_UART_STATE_READY;
 8003c7e:	2320      	movs	r3, #32
 8003c80:	f880 3039 	strb.w	r3, [r0, #57]	; 0x39
  HAL_UART_TxCpltCallback(huart);
 8003c84:	f7ff ffdc 	bl	8003c40 <HAL_UART_TxCpltCallback>
}
 8003c88:	2000      	movs	r0, #0
 8003c8a:	bd08      	pop	{r3, pc}

08003c8c <HAL_UART_TxHalfCpltCallback>:
}
 8003c8c:	4770      	bx	lr

08003c8e <UART_DMATxHalfCplt>:
{
 8003c8e:	b508      	push	{r3, lr}
  HAL_UART_TxHalfCpltCallback(huart);
 8003c90:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8003c92:	f7ff fffb 	bl	8003c8c <HAL_UART_TxHalfCpltCallback>
}
 8003c96:	bd08      	pop	{r3, pc}

08003c98 <HAL_UART_RxCpltCallback>:
}
 8003c98:	4770      	bx	lr

08003c9a <UART_DMAReceiveCplt>:
{
 8003c9a:	b508      	push	{r3, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8003c9c:	6a43      	ldr	r3, [r0, #36]	; 0x24
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 8003c9e:	6802      	ldr	r2, [r0, #0]
 8003ca0:	6812      	ldr	r2, [r2, #0]
 8003ca2:	f012 0f20 	tst.w	r2, #32
 8003ca6:	d113      	bne.n	8003cd0 <UART_DMAReceiveCplt+0x36>
    huart->RxXferCount = 0U;
 8003ca8:	2200      	movs	r2, #0
 8003caa:	85da      	strh	r2, [r3, #46]	; 0x2e
    CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8003cac:	6819      	ldr	r1, [r3, #0]
 8003cae:	68ca      	ldr	r2, [r1, #12]
 8003cb0:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8003cb4:	60ca      	str	r2, [r1, #12]
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8003cb6:	6819      	ldr	r1, [r3, #0]
 8003cb8:	694a      	ldr	r2, [r1, #20]
 8003cba:	f022 0201 	bic.w	r2, r2, #1
 8003cbe:	614a      	str	r2, [r1, #20]
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8003cc0:	6819      	ldr	r1, [r3, #0]
 8003cc2:	694a      	ldr	r2, [r1, #20]
 8003cc4:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8003cc8:	614a      	str	r2, [r1, #20]
    huart->RxState = HAL_UART_STATE_READY;
 8003cca:	2220      	movs	r2, #32
 8003ccc:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a
  HAL_UART_RxCpltCallback(huart);
 8003cd0:	4618      	mov	r0, r3
 8003cd2:	f7ff ffe1 	bl	8003c98 <HAL_UART_RxCpltCallback>
}
 8003cd6:	bd08      	pop	{r3, pc}

08003cd8 <UART_Receive_IT>:
{
 8003cd8:	b508      	push	{r3, lr}
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8003cda:	f890 303a 	ldrb.w	r3, [r0, #58]	; 0x3a
 8003cde:	b2db      	uxtb	r3, r3
 8003ce0:	2b22      	cmp	r3, #34	; 0x22
 8003ce2:	d140      	bne.n	8003d66 <UART_Receive_IT+0x8e>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8003ce4:	6883      	ldr	r3, [r0, #8]
 8003ce6:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8003cea:	d013      	beq.n	8003d14 <UART_Receive_IT+0x3c>
      pdata8bits = (uint8_t *) huart->pRxBuffPtr;
 8003cec:	6a82      	ldr	r2, [r0, #40]	; 0x28
      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) || ((huart->Init.WordLength == UART_WORDLENGTH_8B) && (huart->Init.Parity == UART_PARITY_NONE)))
 8003cee:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8003cf2:	d002      	beq.n	8003cfa <UART_Receive_IT+0x22>
 8003cf4:	b9db      	cbnz	r3, 8003d2e <UART_Receive_IT+0x56>
 8003cf6:	6903      	ldr	r3, [r0, #16]
 8003cf8:	b9cb      	cbnz	r3, 8003d2e <UART_Receive_IT+0x56>
        *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
 8003cfa:	6803      	ldr	r3, [r0, #0]
 8003cfc:	685b      	ldr	r3, [r3, #4]
 8003cfe:	7013      	strb	r3, [r2, #0]
      huart->pRxBuffPtr += 1U;
 8003d00:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8003d02:	3301      	adds	r3, #1
 8003d04:	6283      	str	r3, [r0, #40]	; 0x28
    if (--huart->RxXferCount == 0U)
 8003d06:	8dc3      	ldrh	r3, [r0, #46]	; 0x2e
 8003d08:	3b01      	subs	r3, #1
 8003d0a:	b29b      	uxth	r3, r3
 8003d0c:	85c3      	strh	r3, [r0, #46]	; 0x2e
 8003d0e:	b1a3      	cbz	r3, 8003d3a <UART_Receive_IT+0x62>
    return HAL_OK;
 8003d10:	2000      	movs	r0, #0
 8003d12:	e029      	b.n	8003d68 <UART_Receive_IT+0x90>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8003d14:	6902      	ldr	r2, [r0, #16]
 8003d16:	2a00      	cmp	r2, #0
 8003d18:	d1e8      	bne.n	8003cec <UART_Receive_IT+0x14>
      pdata16bits = (uint16_t *) huart->pRxBuffPtr;
 8003d1a:	6a82      	ldr	r2, [r0, #40]	; 0x28
      *pdata16bits = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
 8003d1c:	6803      	ldr	r3, [r0, #0]
 8003d1e:	685b      	ldr	r3, [r3, #4]
 8003d20:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8003d24:	8013      	strh	r3, [r2, #0]
      huart->pRxBuffPtr += 2U;
 8003d26:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8003d28:	3302      	adds	r3, #2
 8003d2a:	6283      	str	r3, [r0, #40]	; 0x28
 8003d2c:	e7eb      	b.n	8003d06 <UART_Receive_IT+0x2e>
        *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
 8003d2e:	6803      	ldr	r3, [r0, #0]
 8003d30:	685b      	ldr	r3, [r3, #4]
 8003d32:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8003d36:	7013      	strb	r3, [r2, #0]
 8003d38:	e7e2      	b.n	8003d00 <UART_Receive_IT+0x28>
      __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
 8003d3a:	6802      	ldr	r2, [r0, #0]
 8003d3c:	68d3      	ldr	r3, [r2, #12]
 8003d3e:	f023 0320 	bic.w	r3, r3, #32
 8003d42:	60d3      	str	r3, [r2, #12]
      __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
 8003d44:	6802      	ldr	r2, [r0, #0]
 8003d46:	68d3      	ldr	r3, [r2, #12]
 8003d48:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8003d4c:	60d3      	str	r3, [r2, #12]
      __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
 8003d4e:	6802      	ldr	r2, [r0, #0]
 8003d50:	6953      	ldr	r3, [r2, #20]
 8003d52:	f023 0301 	bic.w	r3, r3, #1
 8003d56:	6153      	str	r3, [r2, #20]
      huart->RxState = HAL_UART_STATE_READY;
 8003d58:	2320      	movs	r3, #32
 8003d5a:	f880 303a 	strb.w	r3, [r0, #58]	; 0x3a
      HAL_UART_RxCpltCallback(huart);
 8003d5e:	f7ff ff9b 	bl	8003c98 <HAL_UART_RxCpltCallback>
      return HAL_OK;
 8003d62:	2000      	movs	r0, #0
 8003d64:	e000      	b.n	8003d68 <UART_Receive_IT+0x90>
    return HAL_BUSY;
 8003d66:	2002      	movs	r0, #2
}
 8003d68:	bd08      	pop	{r3, pc}

08003d6a <HAL_UART_RxHalfCpltCallback>:
}
 8003d6a:	4770      	bx	lr

08003d6c <UART_DMARxHalfCplt>:
{
 8003d6c:	b508      	push	{r3, lr}
  HAL_UART_RxHalfCpltCallback(huart);
 8003d6e:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8003d70:	f7ff fffb 	bl	8003d6a <HAL_UART_RxHalfCpltCallback>
}
 8003d74:	bd08      	pop	{r3, pc}

08003d76 <HAL_UART_ErrorCallback>:
}
 8003d76:	4770      	bx	lr

08003d78 <UART_DMAError>:
{
 8003d78:	b510      	push	{r4, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8003d7a:	6a44      	ldr	r4, [r0, #36]	; 0x24
  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
 8003d7c:	6823      	ldr	r3, [r4, #0]
 8003d7e:	695a      	ldr	r2, [r3, #20]
  if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
 8003d80:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
 8003d84:	b2db      	uxtb	r3, r3
 8003d86:	2b21      	cmp	r3, #33	; 0x21
 8003d88:	d010      	beq.n	8003dac <UART_DMAError+0x34>
  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
 8003d8a:	6823      	ldr	r3, [r4, #0]
 8003d8c:	695a      	ldr	r2, [r3, #20]
 8003d8e:	f002 0240 	and.w	r2, r2, #64	; 0x40
  if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
 8003d92:	f894 303a 	ldrb.w	r3, [r4, #58]	; 0x3a
 8003d96:	b2db      	uxtb	r3, r3
 8003d98:	2b22      	cmp	r3, #34	; 0x22
 8003d9a:	d011      	beq.n	8003dc0 <UART_DMAError+0x48>
  huart->ErrorCode |= HAL_UART_ERROR_DMA;
 8003d9c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8003d9e:	f043 0310 	orr.w	r3, r3, #16
 8003da2:	63e3      	str	r3, [r4, #60]	; 0x3c
  HAL_UART_ErrorCallback(huart);
 8003da4:	4620      	mov	r0, r4
 8003da6:	f7ff ffe6 	bl	8003d76 <HAL_UART_ErrorCallback>
}
 8003daa:	bd10      	pop	{r4, pc}
 8003dac:	f002 0280 	and.w	r2, r2, #128	; 0x80
  if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
 8003db0:	2a00      	cmp	r2, #0
 8003db2:	d0ea      	beq.n	8003d8a <UART_DMAError+0x12>
    huart->TxXferCount = 0x00U;
 8003db4:	2300      	movs	r3, #0
 8003db6:	84e3      	strh	r3, [r4, #38]	; 0x26
    UART_EndTxTransfer(huart);
 8003db8:	4620      	mov	r0, r4
 8003dba:	f7ff fd67 	bl	800388c <UART_EndTxTransfer>
 8003dbe:	e7e4      	b.n	8003d8a <UART_DMAError+0x12>
  if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
 8003dc0:	2a00      	cmp	r2, #0
 8003dc2:	d0eb      	beq.n	8003d9c <UART_DMAError+0x24>
    huart->RxXferCount = 0x00U;
 8003dc4:	2300      	movs	r3, #0
 8003dc6:	85e3      	strh	r3, [r4, #46]	; 0x2e
    UART_EndRxTransfer(huart);
 8003dc8:	4620      	mov	r0, r4
 8003dca:	f7ff fd68 	bl	800389e <UART_EndRxTransfer>
 8003dce:	e7e5      	b.n	8003d9c <UART_DMAError+0x24>

08003dd0 <HAL_UART_IRQHandler>:
{
 8003dd0:	b510      	push	{r4, lr}
 8003dd2:	4604      	mov	r4, r0
  uint32_t isrflags   = READ_REG(huart->Instance->SR);
 8003dd4:	6802      	ldr	r2, [r0, #0]
 8003dd6:	6813      	ldr	r3, [r2, #0]
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 8003dd8:	68d1      	ldr	r1, [r2, #12]
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 8003dda:	6952      	ldr	r2, [r2, #20]
  if (errorflags == RESET)
 8003ddc:	f013 000f 	ands.w	r0, r3, #15
 8003de0:	d105      	bne.n	8003dee <HAL_UART_IRQHandler+0x1e>
    if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 8003de2:	f013 0f20 	tst.w	r3, #32
 8003de6:	d002      	beq.n	8003dee <HAL_UART_IRQHandler+0x1e>
 8003de8:	f011 0f20 	tst.w	r1, #32
 8003dec:	d156      	bne.n	8003e9c <HAL_UART_IRQHandler+0xcc>
  if ((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET) || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
 8003dee:	2800      	cmp	r0, #0
 8003df0:	d06a      	beq.n	8003ec8 <HAL_UART_IRQHandler+0xf8>
 8003df2:	f012 0201 	ands.w	r2, r2, #1
 8003df6:	d102      	bne.n	8003dfe <HAL_UART_IRQHandler+0x2e>
 8003df8:	f411 7f90 	tst.w	r1, #288	; 0x120
 8003dfc:	d064      	beq.n	8003ec8 <HAL_UART_IRQHandler+0xf8>
    if (((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
 8003dfe:	f013 0f01 	tst.w	r3, #1
 8003e02:	d006      	beq.n	8003e12 <HAL_UART_IRQHandler+0x42>
 8003e04:	f411 7f80 	tst.w	r1, #256	; 0x100
 8003e08:	d003      	beq.n	8003e12 <HAL_UART_IRQHandler+0x42>
      huart->ErrorCode |= HAL_UART_ERROR_PE;
 8003e0a:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8003e0c:	f040 0001 	orr.w	r0, r0, #1
 8003e10:	63e0      	str	r0, [r4, #60]	; 0x3c
    if (((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 8003e12:	f013 0f04 	tst.w	r3, #4
 8003e16:	d004      	beq.n	8003e22 <HAL_UART_IRQHandler+0x52>
 8003e18:	b11a      	cbz	r2, 8003e22 <HAL_UART_IRQHandler+0x52>
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 8003e1a:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8003e1c:	f040 0002 	orr.w	r0, r0, #2
 8003e20:	63e0      	str	r0, [r4, #60]	; 0x3c
    if (((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 8003e22:	f013 0f02 	tst.w	r3, #2
 8003e26:	d004      	beq.n	8003e32 <HAL_UART_IRQHandler+0x62>
 8003e28:	b11a      	cbz	r2, 8003e32 <HAL_UART_IRQHandler+0x62>
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 8003e2a:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8003e2c:	f040 0004 	orr.w	r0, r0, #4
 8003e30:	63e0      	str	r0, [r4, #60]	; 0x3c
    if (((isrflags & USART_SR_ORE) != RESET) && (((cr1its & USART_CR1_RXNEIE) != RESET) || ((cr3its & USART_CR3_EIE) != RESET)))
 8003e32:	f013 0f08 	tst.w	r3, #8
 8003e36:	d007      	beq.n	8003e48 <HAL_UART_IRQHandler+0x78>
 8003e38:	f011 0f20 	tst.w	r1, #32
 8003e3c:	d100      	bne.n	8003e40 <HAL_UART_IRQHandler+0x70>
 8003e3e:	b11a      	cbz	r2, 8003e48 <HAL_UART_IRQHandler+0x78>
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 8003e40:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8003e42:	f042 0208 	orr.w	r2, r2, #8
 8003e46:	63e2      	str	r2, [r4, #60]	; 0x3c
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 8003e48:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8003e4a:	2a00      	cmp	r2, #0
 8003e4c:	d048      	beq.n	8003ee0 <HAL_UART_IRQHandler+0x110>
      if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 8003e4e:	f013 0f20 	tst.w	r3, #32
 8003e52:	d002      	beq.n	8003e5a <HAL_UART_IRQHandler+0x8a>
 8003e54:	f011 0f20 	tst.w	r1, #32
 8003e58:	d124      	bne.n	8003ea4 <HAL_UART_IRQHandler+0xd4>
      dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
 8003e5a:	6823      	ldr	r3, [r4, #0]
 8003e5c:	695b      	ldr	r3, [r3, #20]
 8003e5e:	f003 0340 	and.w	r3, r3, #64	; 0x40
      if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
 8003e62:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8003e64:	f012 0f08 	tst.w	r2, #8
 8003e68:	d100      	bne.n	8003e6c <HAL_UART_IRQHandler+0x9c>
 8003e6a:	b33b      	cbz	r3, 8003ebc <HAL_UART_IRQHandler+0xec>
        UART_EndRxTransfer(huart);
 8003e6c:	4620      	mov	r0, r4
 8003e6e:	f7ff fd16 	bl	800389e <UART_EndRxTransfer>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8003e72:	6823      	ldr	r3, [r4, #0]
 8003e74:	695a      	ldr	r2, [r3, #20]
 8003e76:	f012 0f40 	tst.w	r2, #64	; 0x40
 8003e7a:	d01b      	beq.n	8003eb4 <HAL_UART_IRQHandler+0xe4>
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8003e7c:	695a      	ldr	r2, [r3, #20]
 8003e7e:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8003e82:	615a      	str	r2, [r3, #20]
          if (huart->hdmarx != NULL)
 8003e84:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8003e86:	b18b      	cbz	r3, 8003eac <HAL_UART_IRQHandler+0xdc>
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 8003e88:	4a1a      	ldr	r2, [pc, #104]	; (8003ef4 <HAL_UART_IRQHandler+0x124>)
 8003e8a:	635a      	str	r2, [r3, #52]	; 0x34
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 8003e8c:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8003e8e:	f7fc fecf 	bl	8000c30 <HAL_DMA_Abort_IT>
 8003e92:	b328      	cbz	r0, 8003ee0 <HAL_UART_IRQHandler+0x110>
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 8003e94:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8003e96:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8003e98:	4798      	blx	r3
 8003e9a:	e021      	b.n	8003ee0 <HAL_UART_IRQHandler+0x110>
      UART_Receive_IT(huart);
 8003e9c:	4620      	mov	r0, r4
 8003e9e:	f7ff ff1b 	bl	8003cd8 <UART_Receive_IT>
      return;
 8003ea2:	e01d      	b.n	8003ee0 <HAL_UART_IRQHandler+0x110>
        UART_Receive_IT(huart);
 8003ea4:	4620      	mov	r0, r4
 8003ea6:	f7ff ff17 	bl	8003cd8 <UART_Receive_IT>
 8003eaa:	e7d6      	b.n	8003e5a <HAL_UART_IRQHandler+0x8a>
            HAL_UART_ErrorCallback(huart);
 8003eac:	4620      	mov	r0, r4
 8003eae:	f7ff ff62 	bl	8003d76 <HAL_UART_ErrorCallback>
 8003eb2:	e015      	b.n	8003ee0 <HAL_UART_IRQHandler+0x110>
          HAL_UART_ErrorCallback(huart);
 8003eb4:	4620      	mov	r0, r4
 8003eb6:	f7ff ff5e 	bl	8003d76 <HAL_UART_ErrorCallback>
 8003eba:	e011      	b.n	8003ee0 <HAL_UART_IRQHandler+0x110>
        HAL_UART_ErrorCallback(huart);
 8003ebc:	4620      	mov	r0, r4
 8003ebe:	f7ff ff5a 	bl	8003d76 <HAL_UART_ErrorCallback>
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003ec2:	2300      	movs	r3, #0
 8003ec4:	63e3      	str	r3, [r4, #60]	; 0x3c
 8003ec6:	e00b      	b.n	8003ee0 <HAL_UART_IRQHandler+0x110>
  if (((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
 8003ec8:	f013 0f80 	tst.w	r3, #128	; 0x80
 8003ecc:	d002      	beq.n	8003ed4 <HAL_UART_IRQHandler+0x104>
 8003ece:	f011 0f80 	tst.w	r1, #128	; 0x80
 8003ed2:	d106      	bne.n	8003ee2 <HAL_UART_IRQHandler+0x112>
  if (((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
 8003ed4:	f013 0f40 	tst.w	r3, #64	; 0x40
 8003ed8:	d002      	beq.n	8003ee0 <HAL_UART_IRQHandler+0x110>
 8003eda:	f011 0f40 	tst.w	r1, #64	; 0x40
 8003ede:	d104      	bne.n	8003eea <HAL_UART_IRQHandler+0x11a>
}
 8003ee0:	bd10      	pop	{r4, pc}
    UART_Transmit_IT(huart);
 8003ee2:	4620      	mov	r0, r4
 8003ee4:	f7ff fce9 	bl	80038ba <UART_Transmit_IT>
    return;
 8003ee8:	e7fa      	b.n	8003ee0 <HAL_UART_IRQHandler+0x110>
    UART_EndTransmit_IT(huart);
 8003eea:	4620      	mov	r0, r4
 8003eec:	f7ff fec1 	bl	8003c72 <UART_EndTransmit_IT>
    return;
 8003ef0:	e7f6      	b.n	8003ee0 <HAL_UART_IRQHandler+0x110>
 8003ef2:	bf00      	nop
 8003ef4:	08003ef9 	.word	0x08003ef9

08003ef8 <UART_DMAAbortOnError>:
{
 8003ef8:	b508      	push	{r3, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8003efa:	6a40      	ldr	r0, [r0, #36]	; 0x24
  huart->RxXferCount = 0x00U;
 8003efc:	2300      	movs	r3, #0
 8003efe:	85c3      	strh	r3, [r0, #46]	; 0x2e
  huart->TxXferCount = 0x00U;
 8003f00:	84c3      	strh	r3, [r0, #38]	; 0x26
  HAL_UART_ErrorCallback(huart);
 8003f02:	f7ff ff38 	bl	8003d76 <HAL_UART_ErrorCallback>
}
 8003f06:	bd08      	pop	{r3, pc}

08003f08 <makeFreeRtosPriority>:
/* Convert from CMSIS type osPriority to FreeRTOS priority number */
static unsigned portBASE_TYPE makeFreeRtosPriority (osPriority priority)
{
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
  
  if (priority != osPriorityError) {
 8003f08:	2884      	cmp	r0, #132	; 0x84
 8003f0a:	d001      	beq.n	8003f10 <makeFreeRtosPriority+0x8>
    fpriority += (priority - osPriorityIdle);
 8003f0c:	3003      	adds	r0, #3
 8003f0e:	4770      	bx	lr
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
 8003f10:	2000      	movs	r0, #0
  }
  
  return fpriority;
}
 8003f12:	4770      	bx	lr

08003f14 <osKernelStart>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osKernelStart shall be consistent in every CMSIS-RTOS.
*/
osStatus osKernelStart (void)
{
 8003f14:	b508      	push	{r3, lr}
  vTaskStartScheduler();
 8003f16:	f000 fa5f 	bl	80043d8 <vTaskStartScheduler>
  
  return osOK;
}
 8003f1a:	2000      	movs	r0, #0
 8003f1c:	bd08      	pop	{r3, pc}

08003f1e <osThreadCreate>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval thread ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osThreadCreate shall be consistent in every CMSIS-RTOS.
*/
osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)
{
 8003f1e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8003f22:	b087      	sub	sp, #28
 8003f24:	4604      	mov	r4, r0
 8003f26:	460f      	mov	r7, r1
  TaskHandle_t handle;
  
#if( configSUPPORT_STATIC_ALLOCATION == 1 ) &&  ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
  if((thread_def->buffer != NULL) && (thread_def->controlblock != NULL)) {
 8003f28:	6945      	ldr	r5, [r0, #20]
 8003f2a:	b1a5      	cbz	r5, 8003f56 <osThreadCreate+0x38>
 8003f2c:	6986      	ldr	r6, [r0, #24]
 8003f2e:	b196      	cbz	r6, 8003f56 <osThreadCreate+0x38>
    handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8003f30:	f8d0 8004 	ldr.w	r8, [r0, #4]
 8003f34:	f8d0 9000 	ldr.w	r9, [r0]
 8003f38:	f9b0 0008 	ldrsh.w	r0, [r0, #8]
 8003f3c:	f7ff ffe4 	bl	8003f08 <makeFreeRtosPriority>
 8003f40:	6922      	ldr	r2, [r4, #16]
 8003f42:	9602      	str	r6, [sp, #8]
 8003f44:	9501      	str	r5, [sp, #4]
 8003f46:	9000      	str	r0, [sp, #0]
 8003f48:	463b      	mov	r3, r7
 8003f4a:	4649      	mov	r1, r9
 8003f4c:	4640      	mov	r0, r8
 8003f4e:	f000 f9d7 	bl	8004300 <xTaskCreateStatic>
 8003f52:	9005      	str	r0, [sp, #20]
 8003f54:	e013      	b.n	8003f7e <osThreadCreate+0x60>
              thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
              thread_def->buffer, thread_def->controlblock);
  }
  else {
    if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8003f56:	6865      	ldr	r5, [r4, #4]
 8003f58:	6826      	ldr	r6, [r4, #0]
              thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
 8003f5a:	f8d4 8010 	ldr.w	r8, [r4, #16]
    if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8003f5e:	f9b4 0008 	ldrsh.w	r0, [r4, #8]
 8003f62:	f7ff ffd1 	bl	8003f08 <makeFreeRtosPriority>
 8003f66:	ab05      	add	r3, sp, #20
 8003f68:	9301      	str	r3, [sp, #4]
 8003f6a:	9000      	str	r0, [sp, #0]
 8003f6c:	463b      	mov	r3, r7
 8003f6e:	fa1f f288 	uxth.w	r2, r8
 8003f72:	4631      	mov	r1, r6
 8003f74:	4628      	mov	r0, r5
 8003f76:	f000 f9fc 	bl	8004372 <xTaskCreate>
 8003f7a:	2801      	cmp	r0, #1
 8003f7c:	d103      	bne.n	8003f86 <osThreadCreate+0x68>
                   &handle) != pdPASS)  {
    return NULL;
  }     
#endif
  
  return handle;
 8003f7e:	9805      	ldr	r0, [sp, #20]
}
 8003f80:	b007      	add	sp, #28
 8003f82:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      return NULL;
 8003f86:	2000      	movs	r0, #0
 8003f88:	e7fa      	b.n	8003f80 <osThreadCreate+0x62>

08003f8a <osDelay>:
* @brief   Wait for Timeout (Time Delay)
* @param   millisec      time delay value
* @retval  status code that indicates the execution status of the function.
*/
osStatus osDelay (uint32_t millisec)
{
 8003f8a:	b508      	push	{r3, lr}
#if INCLUDE_vTaskDelay
  TickType_t ticks = millisec / portTICK_PERIOD_MS;
  
  vTaskDelay(ticks ? ticks : 1);          /* Minimum delay = 1 tick */
 8003f8c:	4603      	mov	r3, r0
 8003f8e:	b900      	cbnz	r0, 8003f92 <osDelay+0x8>
 8003f90:	2301      	movs	r3, #1
 8003f92:	4618      	mov	r0, r3
 8003f94:	f000 fb5a 	bl	800464c <vTaskDelay>
#else
  (void) millisec;
  
  return osErrorResource;
#endif
}
 8003f98:	2000      	movs	r0, #0
 8003f9a:	bd08      	pop	{r3, pc}

08003f9c <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8003f9c:	f100 0308 	add.w	r3, r0, #8
 8003fa0:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8003fa2:	f04f 32ff 	mov.w	r2, #4294967295
 8003fa6:	6082      	str	r2, [r0, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8003fa8:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8003faa:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8003fac:	2300      	movs	r3, #0
 8003fae:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 8003fb0:	4770      	bx	lr

08003fb2 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 8003fb2:	2300      	movs	r3, #0
 8003fb4:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 8003fb6:	4770      	bx	lr

08003fb8 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 8003fb8:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 8003fba:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8003fbc:	689a      	ldr	r2, [r3, #8]
 8003fbe:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8003fc0:	689a      	ldr	r2, [r3, #8]
 8003fc2:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 8003fc4:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8003fc6:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 8003fc8:	6803      	ldr	r3, [r0, #0]
 8003fca:	3301      	adds	r3, #1
 8003fcc:	6003      	str	r3, [r0, #0]
}
 8003fce:	4770      	bx	lr

08003fd0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 8003fd0:	b430      	push	{r4, r5}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 8003fd2:	680d      	ldr	r5, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8003fd4:	f1b5 3fff 	cmp.w	r5, #4294967295
 8003fd8:	d002      	beq.n	8003fe0 <vListInsert+0x10>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8003fda:	f100 0208 	add.w	r2, r0, #8
 8003fde:	e002      	b.n	8003fe6 <vListInsert+0x16>
		pxIterator = pxList->xListEnd.pxPrevious;
 8003fe0:	6902      	ldr	r2, [r0, #16]
 8003fe2:	e004      	b.n	8003fee <vListInsert+0x1e>
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8003fe4:	461a      	mov	r2, r3
 8003fe6:	6853      	ldr	r3, [r2, #4]
 8003fe8:	681c      	ldr	r4, [r3, #0]
 8003fea:	42ac      	cmp	r4, r5
 8003fec:	d9fa      	bls.n	8003fe4 <vListInsert+0x14>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8003fee:	6853      	ldr	r3, [r2, #4]
 8003ff0:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8003ff2:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 8003ff4:	608a      	str	r2, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 8003ff6:	6051      	str	r1, [r2, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8003ff8:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 8003ffa:	6803      	ldr	r3, [r0, #0]
 8003ffc:	3301      	adds	r3, #1
 8003ffe:	6003      	str	r3, [r0, #0]
}
 8004000:	bc30      	pop	{r4, r5}
 8004002:	4770      	bx	lr

08004004 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 8004004:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8004006:	6842      	ldr	r2, [r0, #4]
 8004008:	6881      	ldr	r1, [r0, #8]
 800400a:	6091      	str	r1, [r2, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 800400c:	6882      	ldr	r2, [r0, #8]
 800400e:	6841      	ldr	r1, [r0, #4]
 8004010:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8004012:	685a      	ldr	r2, [r3, #4]
 8004014:	4282      	cmp	r2, r0
 8004016:	d006      	beq.n	8004026 <uxListRemove+0x22>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 8004018:	2200      	movs	r2, #0
 800401a:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 800401c:	681a      	ldr	r2, [r3, #0]
 800401e:	3a01      	subs	r2, #1
 8004020:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
 8004022:	6818      	ldr	r0, [r3, #0]
}
 8004024:	4770      	bx	lr
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8004026:	6882      	ldr	r2, [r0, #8]
 8004028:	605a      	str	r2, [r3, #4]
 800402a:	e7f5      	b.n	8004018 <uxListRemove+0x14>

0800402c <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800402c:	4b07      	ldr	r3, [pc, #28]	; (800404c <prvResetNextTaskUnblockTime+0x20>)
 800402e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004030:	681b      	ldr	r3, [r3, #0]
 8004032:	b133      	cbz	r3, 8004042 <prvResetNextTaskUnblockTime+0x16>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8004034:	4b05      	ldr	r3, [pc, #20]	; (800404c <prvResetNextTaskUnblockTime+0x20>)
 8004036:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8004038:	68d2      	ldr	r2, [r2, #12]
 800403a:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 800403c:	6852      	ldr	r2, [r2, #4]
 800403e:	62da      	str	r2, [r3, #44]	; 0x2c
	}
}
 8004040:	4770      	bx	lr
		xNextTaskUnblockTime = portMAX_DELAY;
 8004042:	4b02      	ldr	r3, [pc, #8]	; (800404c <prvResetNextTaskUnblockTime+0x20>)
 8004044:	f04f 32ff 	mov.w	r2, #4294967295
 8004048:	62da      	str	r2, [r3, #44]	; 0x2c
 800404a:	4770      	bx	lr
 800404c:	2000002c 	.word	0x2000002c

08004050 <prvInitialiseNewTask>:
{
 8004050:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8004054:	4680      	mov	r8, r0
 8004056:	4699      	mov	r9, r3
 8004058:	9d08      	ldr	r5, [sp, #32]
 800405a:	9f09      	ldr	r7, [sp, #36]	; 0x24
 800405c:	9c0a      	ldr	r4, [sp, #40]	; 0x28
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 800405e:	6b26      	ldr	r6, [r4, #48]	; 0x30
 8004060:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 8004064:	3a01      	subs	r2, #1
 8004066:	eb06 0682 	add.w	r6, r6, r2, lsl #2
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 800406a:	f026 0607 	bic.w	r6, r6, #7
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 800406e:	2300      	movs	r3, #0
 8004070:	2b0f      	cmp	r3, #15
 8004072:	d807      	bhi.n	8004084 <prvInitialiseNewTask+0x34>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8004074:	5cc8      	ldrb	r0, [r1, r3]
 8004076:	18e2      	adds	r2, r4, r3
 8004078:	f882 0034 	strb.w	r0, [r2, #52]	; 0x34
		if( pcName[ x ] == 0x00 )
 800407c:	5cca      	ldrb	r2, [r1, r3]
 800407e:	b10a      	cbz	r2, 8004084 <prvInitialiseNewTask+0x34>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8004080:	3301      	adds	r3, #1
 8004082:	e7f5      	b.n	8004070 <prvInitialiseNewTask+0x20>
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8004084:	2300      	movs	r3, #0
 8004086:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 800408a:	2d06      	cmp	r5, #6
 800408c:	d900      	bls.n	8004090 <prvInitialiseNewTask+0x40>
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 800408e:	2506      	movs	r5, #6
	pxNewTCB->uxPriority = uxPriority;
 8004090:	62e5      	str	r5, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
 8004092:	6465      	str	r5, [r4, #68]	; 0x44
		pxNewTCB->uxMutexesHeld = 0;
 8004094:	f04f 0a00 	mov.w	sl, #0
 8004098:	f8c4 a048 	str.w	sl, [r4, #72]	; 0x48
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 800409c:	1d20      	adds	r0, r4, #4
 800409e:	f7ff ff88 	bl	8003fb2 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 80040a2:	f104 0018 	add.w	r0, r4, #24
 80040a6:	f7ff ff84 	bl	8003fb2 <vListInitialiseItem>
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 80040aa:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80040ac:	f1c5 0507 	rsb	r5, r5, #7
 80040b0:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 80040b2:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->ulNotifiedValue = 0;
 80040b4:	f8c4 a04c 	str.w	sl, [r4, #76]	; 0x4c
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 80040b8:	f884 a050 	strb.w	sl, [r4, #80]	; 0x50
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 80040bc:	464a      	mov	r2, r9
 80040be:	4641      	mov	r1, r8
 80040c0:	4630      	mov	r0, r6
 80040c2:	f000 fb71 	bl	80047a8 <pxPortInitialiseStack>
 80040c6:	6020      	str	r0, [r4, #0]
	if( ( void * ) pxCreatedTask != NULL )
 80040c8:	b107      	cbz	r7, 80040cc <prvInitialiseNewTask+0x7c>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 80040ca:	603c      	str	r4, [r7, #0]
}
 80040cc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

080040d0 <prvInitialiseTaskLists>:
{
 80040d0:	b570      	push	{r4, r5, r6, lr}
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 80040d2:	2400      	movs	r4, #0
 80040d4:	e007      	b.n	80040e6 <prvInitialiseTaskLists+0x16>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 80040d6:	eb04 0284 	add.w	r2, r4, r4, lsl #2
 80040da:	0093      	lsls	r3, r2, #2
 80040dc:	4810      	ldr	r0, [pc, #64]	; (8004120 <prvInitialiseTaskLists+0x50>)
 80040de:	4418      	add	r0, r3
 80040e0:	f7ff ff5c 	bl	8003f9c <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 80040e4:	3401      	adds	r4, #1
 80040e6:	2c06      	cmp	r4, #6
 80040e8:	d9f5      	bls.n	80040d6 <prvInitialiseTaskLists+0x6>
	vListInitialise( &xDelayedTaskList1 );
 80040ea:	4c0e      	ldr	r4, [pc, #56]	; (8004124 <prvInitialiseTaskLists+0x54>)
 80040ec:	f104 06bc 	add.w	r6, r4, #188	; 0xbc
 80040f0:	4630      	mov	r0, r6
 80040f2:	f7ff ff53 	bl	8003f9c <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 80040f6:	f104 05d0 	add.w	r5, r4, #208	; 0xd0
 80040fa:	4628      	mov	r0, r5
 80040fc:	f7ff ff4e 	bl	8003f9c <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8004100:	f104 0014 	add.w	r0, r4, #20
 8004104:	f7ff ff4a 	bl	8003f9c <vListInitialise>
		vListInitialise( &xTasksWaitingTermination );
 8004108:	f104 00e4 	add.w	r0, r4, #228	; 0xe4
 800410c:	f7ff ff46 	bl	8003f9c <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
 8004110:	4620      	mov	r0, r4
 8004112:	f7ff ff43 	bl	8003f9c <vListInitialise>
	pxDelayedTaskList = &xDelayedTaskList1;
 8004116:	62a6      	str	r6, [r4, #40]	; 0x28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8004118:	f8c4 50f8 	str.w	r5, [r4, #248]	; 0xf8
}
 800411c:	bd70      	pop	{r4, r5, r6, pc}
 800411e:	bf00      	nop
 8004120:	2000005c 	.word	0x2000005c
 8004124:	2000002c 	.word	0x2000002c

08004128 <prvAddNewTaskToReadyList>:
{
 8004128:	b538      	push	{r3, r4, r5, lr}
 800412a:	4605      	mov	r5, r0
	taskENTER_CRITICAL();
 800412c:	f000 fb62 	bl	80047f4 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
 8004130:	4b26      	ldr	r3, [pc, #152]	; (80041cc <prvAddNewTaskToReadyList+0xa4>)
 8004132:	f8d3 20fc 	ldr.w	r2, [r3, #252]	; 0xfc
 8004136:	3201      	adds	r2, #1
 8004138:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
		if( pxCurrentTCB == NULL )
 800413c:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 8004140:	b173      	cbz	r3, 8004160 <prvAddNewTaskToReadyList+0x38>
			if( xSchedulerRunning == pdFALSE )
 8004142:	4b22      	ldr	r3, [pc, #136]	; (80041cc <prvAddNewTaskToReadyList+0xa4>)
 8004144:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 8004148:	b98b      	cbnz	r3, 800416e <prvAddNewTaskToReadyList+0x46>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 800414a:	4b20      	ldr	r3, [pc, #128]	; (80041cc <prvAddNewTaskToReadyList+0xa4>)
 800414c:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 8004150:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8004152:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8004154:	429a      	cmp	r2, r3
 8004156:	d80a      	bhi.n	800416e <prvAddNewTaskToReadyList+0x46>
					pxCurrentTCB = pxNewTCB;
 8004158:	4b1c      	ldr	r3, [pc, #112]	; (80041cc <prvAddNewTaskToReadyList+0xa4>)
 800415a:	f8c3 5100 	str.w	r5, [r3, #256]	; 0x100
 800415e:	e006      	b.n	800416e <prvAddNewTaskToReadyList+0x46>
			pxCurrentTCB = pxNewTCB;
 8004160:	4b1a      	ldr	r3, [pc, #104]	; (80041cc <prvAddNewTaskToReadyList+0xa4>)
 8004162:	f8c3 5100 	str.w	r5, [r3, #256]	; 0x100
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8004166:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 800416a:	2b01      	cmp	r3, #1
 800416c:	d02a      	beq.n	80041c4 <prvAddNewTaskToReadyList+0x9c>
		uxTaskNumber++;
 800416e:	4c17      	ldr	r4, [pc, #92]	; (80041cc <prvAddNewTaskToReadyList+0xa4>)
 8004170:	f8d4 3108 	ldr.w	r3, [r4, #264]	; 0x108
 8004174:	3301      	adds	r3, #1
 8004176:	f8c4 3108 	str.w	r3, [r4, #264]	; 0x108
		prvAddTaskToReadyList( pxNewTCB );
 800417a:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800417c:	2201      	movs	r2, #1
 800417e:	409a      	lsls	r2, r3
 8004180:	f8d4 110c 	ldr.w	r1, [r4, #268]	; 0x10c
 8004184:	430a      	orrs	r2, r1
 8004186:	f8c4 210c 	str.w	r2, [r4, #268]	; 0x10c
 800418a:	f104 0030 	add.w	r0, r4, #48	; 0x30
 800418e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8004192:	009a      	lsls	r2, r3, #2
 8004194:	1d29      	adds	r1, r5, #4
 8004196:	4410      	add	r0, r2
 8004198:	f7ff ff0e 	bl	8003fb8 <vListInsertEnd>
	taskEXIT_CRITICAL();
 800419c:	f000 fb4c 	bl	8004838 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
 80041a0:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
 80041a4:	b16b      	cbz	r3, 80041c2 <prvAddNewTaskToReadyList+0x9a>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 80041a6:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
 80041aa:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80041ac:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 80041ae:	429a      	cmp	r2, r3
 80041b0:	d207      	bcs.n	80041c2 <prvAddNewTaskToReadyList+0x9a>
			taskYIELD_IF_USING_PREEMPTION();
 80041b2:	4b07      	ldr	r3, [pc, #28]	; (80041d0 <prvAddNewTaskToReadyList+0xa8>)
 80041b4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80041b8:	601a      	str	r2, [r3, #0]
 80041ba:	f3bf 8f4f 	dsb	sy
 80041be:	f3bf 8f6f 	isb	sy
}
 80041c2:	bd38      	pop	{r3, r4, r5, pc}
				prvInitialiseTaskLists();
 80041c4:	f7ff ff84 	bl	80040d0 <prvInitialiseTaskLists>
 80041c8:	e7d1      	b.n	800416e <prvAddNewTaskToReadyList+0x46>
 80041ca:	bf00      	nop
 80041cc:	2000002c 	.word	0x2000002c
 80041d0:	e000ed04 	.word	0xe000ed04

080041d4 <prvDeleteTCB>:
	{
 80041d4:	b510      	push	{r4, lr}
 80041d6:	4604      	mov	r4, r0
			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
 80041d8:	f890 3051 	ldrb.w	r3, [r0, #81]	; 0x51
 80041dc:	b933      	cbnz	r3, 80041ec <prvDeleteTCB+0x18>
				vPortFree( pxTCB->pxStack );
 80041de:	6b00      	ldr	r0, [r0, #48]	; 0x30
 80041e0:	f000 fcd0 	bl	8004b84 <vPortFree>
				vPortFree( pxTCB );
 80041e4:	4620      	mov	r0, r4
 80041e6:	f000 fccd 	bl	8004b84 <vPortFree>
	}
 80041ea:	bd10      	pop	{r4, pc}
			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
 80041ec:	2b01      	cmp	r3, #1
 80041ee:	d00a      	beq.n	8004206 <prvDeleteTCB+0x32>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
 80041f0:	2b02      	cmp	r3, #2
 80041f2:	d0fa      	beq.n	80041ea <prvDeleteTCB+0x16>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 80041f4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80041f8:	f383 8811 	msr	BASEPRI, r3
 80041fc:	f3bf 8f6f 	isb	sy
 8004200:	f3bf 8f4f 	dsb	sy
 8004204:	e7fe      	b.n	8004204 <prvDeleteTCB+0x30>
				vPortFree( pxTCB );
 8004206:	f000 fcbd 	bl	8004b84 <vPortFree>
 800420a:	e7ee      	b.n	80041ea <prvDeleteTCB+0x16>

0800420c <prvCheckTasksWaitingTermination>:
{
 800420c:	b538      	push	{r3, r4, r5, lr}
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 800420e:	e017      	b.n	8004240 <prvCheckTasksWaitingTermination+0x34>
			taskENTER_CRITICAL();
 8004210:	f000 faf0 	bl	80047f4 <vPortEnterCritical>
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 8004214:	4c0d      	ldr	r4, [pc, #52]	; (800424c <prvCheckTasksWaitingTermination+0x40>)
 8004216:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
 800421a:	68dd      	ldr	r5, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800421c:	1d28      	adds	r0, r5, #4
 800421e:	f7ff fef1 	bl	8004004 <uxListRemove>
				--uxCurrentNumberOfTasks;
 8004222:	f8d4 30fc 	ldr.w	r3, [r4, #252]	; 0xfc
 8004226:	3b01      	subs	r3, #1
 8004228:	f8c4 30fc 	str.w	r3, [r4, #252]	; 0xfc
				--uxDeletedTasksWaitingCleanUp;
 800422c:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
 8004230:	3b01      	subs	r3, #1
 8004232:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
			taskEXIT_CRITICAL();
 8004236:	f000 faff 	bl	8004838 <vPortExitCritical>
			prvDeleteTCB( pxTCB );
 800423a:	4628      	mov	r0, r5
 800423c:	f7ff ffca 	bl	80041d4 <prvDeleteTCB>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8004240:	4b02      	ldr	r3, [pc, #8]	; (800424c <prvCheckTasksWaitingTermination+0x40>)
 8004242:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 8004246:	2b00      	cmp	r3, #0
 8004248:	d1e2      	bne.n	8004210 <prvCheckTasksWaitingTermination+0x4>
}
 800424a:	bd38      	pop	{r3, r4, r5, pc}
 800424c:	2000002c 	.word	0x2000002c

08004250 <prvIdleTask>:
{
 8004250:	b508      	push	{r3, lr}
		prvCheckTasksWaitingTermination();
 8004252:	f7ff ffdb 	bl	800420c <prvCheckTasksWaitingTermination>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 8004256:	4b06      	ldr	r3, [pc, #24]	; (8004270 <prvIdleTask+0x20>)
 8004258:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800425a:	2b01      	cmp	r3, #1
 800425c:	d9f9      	bls.n	8004252 <prvIdleTask+0x2>
				taskYIELD();
 800425e:	4b05      	ldr	r3, [pc, #20]	; (8004274 <prvIdleTask+0x24>)
 8004260:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004264:	601a      	str	r2, [r3, #0]
 8004266:	f3bf 8f4f 	dsb	sy
 800426a:	f3bf 8f6f 	isb	sy
 800426e:	e7f0      	b.n	8004252 <prvIdleTask+0x2>
 8004270:	2000002c 	.word	0x2000002c
 8004274:	e000ed04 	.word	0xe000ed04

08004278 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 8004278:	b570      	push	{r4, r5, r6, lr}
 800427a:	4604      	mov	r4, r0
 800427c:	460e      	mov	r6, r1
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 800427e:	4b1f      	ldr	r3, [pc, #124]	; (80042fc <prvAddCurrentTaskToDelayedList+0x84>)
 8004280:	f8d3 5114 	ldr.w	r5, [r3, #276]	; 0x114
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8004284:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
 8004288:	3004      	adds	r0, #4
 800428a:	f7ff febb 	bl	8004004 <uxListRemove>
 800428e:	b960      	cbnz	r0, 80042aa <prvAddCurrentTaskToDelayedList+0x32>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 8004290:	4b1a      	ldr	r3, [pc, #104]	; (80042fc <prvAddCurrentTaskToDelayedList+0x84>)
 8004292:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
 8004296:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 8004298:	2201      	movs	r2, #1
 800429a:	fa02 f101 	lsl.w	r1, r2, r1
 800429e:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
 80042a2:	ea22 0201 	bic.w	r2, r2, r1
 80042a6:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 80042aa:	f1b4 3fff 	cmp.w	r4, #4294967295
 80042ae:	d012      	beq.n	80042d6 <prvAddCurrentTaskToDelayedList+0x5e>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
 80042b0:	442c      	add	r4, r5

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 80042b2:	4b12      	ldr	r3, [pc, #72]	; (80042fc <prvAddCurrentTaskToDelayedList+0x84>)
 80042b4:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 80042b8:	605c      	str	r4, [r3, #4]

			if( xTimeToWake < xConstTickCount )
 80042ba:	42a5      	cmp	r5, r4
 80042bc:	d814      	bhi.n	80042e8 <prvAddCurrentTaskToDelayedList+0x70>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80042be:	4d0f      	ldr	r5, [pc, #60]	; (80042fc <prvAddCurrentTaskToDelayedList+0x84>)
 80042c0:	6aa8      	ldr	r0, [r5, #40]	; 0x28
 80042c2:	f8d5 1100 	ldr.w	r1, [r5, #256]	; 0x100
 80042c6:	3104      	adds	r1, #4
 80042c8:	f7ff fe82 	bl	8003fd0 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
 80042cc:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 80042ce:	42a3      	cmp	r3, r4
 80042d0:	d912      	bls.n	80042f8 <prvAddCurrentTaskToDelayedList+0x80>
				{
					xNextTaskUnblockTime = xTimeToWake;
 80042d2:	62ec      	str	r4, [r5, #44]	; 0x2c

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 80042d4:	e010      	b.n	80042f8 <prvAddCurrentTaskToDelayedList+0x80>
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 80042d6:	2e00      	cmp	r6, #0
 80042d8:	d0ea      	beq.n	80042b0 <prvAddCurrentTaskToDelayedList+0x38>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80042da:	4808      	ldr	r0, [pc, #32]	; (80042fc <prvAddCurrentTaskToDelayedList+0x84>)
 80042dc:	f8d0 1100 	ldr.w	r1, [r0, #256]	; 0x100
 80042e0:	3104      	adds	r1, #4
 80042e2:	f7ff fe69 	bl	8003fb8 <vListInsertEnd>
 80042e6:	e007      	b.n	80042f8 <prvAddCurrentTaskToDelayedList+0x80>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80042e8:	4b04      	ldr	r3, [pc, #16]	; (80042fc <prvAddCurrentTaskToDelayedList+0x84>)
 80042ea:	f8d3 00f8 	ldr.w	r0, [r3, #248]	; 0xf8
 80042ee:	f8d3 1100 	ldr.w	r1, [r3, #256]	; 0x100
 80042f2:	3104      	adds	r1, #4
 80042f4:	f7ff fe6c 	bl	8003fd0 <vListInsert>
}
 80042f8:	bd70      	pop	{r4, r5, r6, pc}
 80042fa:	bf00      	nop
 80042fc:	2000002c 	.word	0x2000002c

08004300 <xTaskCreateStatic>:
	{
 8004300:	b570      	push	{r4, r5, r6, lr}
 8004302:	b086      	sub	sp, #24
 8004304:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 8004306:	9c0c      	ldr	r4, [sp, #48]	; 0x30
		configASSERT( puxStackBuffer != NULL );
 8004308:	b945      	cbnz	r5, 800431c <xTaskCreateStatic+0x1c>
 800430a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800430e:	f383 8811 	msr	BASEPRI, r3
 8004312:	f3bf 8f6f 	isb	sy
 8004316:	f3bf 8f4f 	dsb	sy
 800431a:	e7fe      	b.n	800431a <xTaskCreateStatic+0x1a>
		configASSERT( pxTaskBuffer != NULL );
 800431c:	b944      	cbnz	r4, 8004330 <xTaskCreateStatic+0x30>
 800431e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004322:	f383 8811 	msr	BASEPRI, r3
 8004326:	f3bf 8f6f 	isb	sy
 800432a:	f3bf 8f4f 	dsb	sy
 800432e:	e7fe      	b.n	800432e <xTaskCreateStatic+0x2e>
			volatile size_t xSize = sizeof( StaticTask_t );
 8004330:	2654      	movs	r6, #84	; 0x54
 8004332:	9604      	str	r6, [sp, #16]
			configASSERT( xSize == sizeof( TCB_t ) );
 8004334:	9e04      	ldr	r6, [sp, #16]
 8004336:	2e54      	cmp	r6, #84	; 0x54
 8004338:	d008      	beq.n	800434c <xTaskCreateStatic+0x4c>
 800433a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800433e:	f383 8811 	msr	BASEPRI, r3
 8004342:	f3bf 8f6f 	isb	sy
 8004346:	f3bf 8f4f 	dsb	sy
 800434a:	e7fe      	b.n	800434a <xTaskCreateStatic+0x4a>
			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 800434c:	6325      	str	r5, [r4, #48]	; 0x30
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 800434e:	2502      	movs	r5, #2
 8004350:	f884 5051 	strb.w	r5, [r4, #81]	; 0x51
			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
 8004354:	2500      	movs	r5, #0
 8004356:	9503      	str	r5, [sp, #12]
 8004358:	9402      	str	r4, [sp, #8]
 800435a:	ad05      	add	r5, sp, #20
 800435c:	9501      	str	r5, [sp, #4]
 800435e:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 8004360:	9500      	str	r5, [sp, #0]
 8004362:	f7ff fe75 	bl	8004050 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
 8004366:	4620      	mov	r0, r4
 8004368:	f7ff fede 	bl	8004128 <prvAddNewTaskToReadyList>
	}
 800436c:	9805      	ldr	r0, [sp, #20]
 800436e:	b006      	add	sp, #24
 8004370:	bd70      	pop	{r4, r5, r6, pc}

08004372 <xTaskCreate>:
	{
 8004372:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8004376:	b085      	sub	sp, #20
 8004378:	4607      	mov	r7, r0
 800437a:	4688      	mov	r8, r1
 800437c:	4615      	mov	r5, r2
 800437e:	4699      	mov	r9, r3
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004380:	0090      	lsls	r0, r2, #2
 8004382:	f000 fb79 	bl	8004a78 <pvPortMalloc>
			if( pxStack != NULL )
 8004386:	b308      	cbz	r0, 80043cc <xTaskCreate+0x5a>
 8004388:	4606      	mov	r6, r0
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
 800438a:	2054      	movs	r0, #84	; 0x54
 800438c:	f000 fb74 	bl	8004a78 <pvPortMalloc>
				if( pxNewTCB != NULL )
 8004390:	4604      	mov	r4, r0
 8004392:	b1b8      	cbz	r0, 80043c4 <xTaskCreate+0x52>
					pxNewTCB->pxStack = pxStack;
 8004394:	6306      	str	r6, [r0, #48]	; 0x30
		if( pxNewTCB != NULL )
 8004396:	b1e4      	cbz	r4, 80043d2 <xTaskCreate+0x60>
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 8004398:	2300      	movs	r3, #0
 800439a:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 800439e:	9303      	str	r3, [sp, #12]
 80043a0:	9402      	str	r4, [sp, #8]
 80043a2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80043a4:	9301      	str	r3, [sp, #4]
 80043a6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80043a8:	9300      	str	r3, [sp, #0]
 80043aa:	464b      	mov	r3, r9
 80043ac:	462a      	mov	r2, r5
 80043ae:	4641      	mov	r1, r8
 80043b0:	4638      	mov	r0, r7
 80043b2:	f7ff fe4d 	bl	8004050 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
 80043b6:	4620      	mov	r0, r4
 80043b8:	f7ff feb6 	bl	8004128 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
 80043bc:	2001      	movs	r0, #1
	}
 80043be:	b005      	add	sp, #20
 80043c0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
					vPortFree( pxStack );
 80043c4:	4630      	mov	r0, r6
 80043c6:	f000 fbdd 	bl	8004b84 <vPortFree>
 80043ca:	e7e4      	b.n	8004396 <xTaskCreate+0x24>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 80043cc:	f04f 30ff 	mov.w	r0, #4294967295
 80043d0:	e7f5      	b.n	80043be <xTaskCreate+0x4c>
 80043d2:	f04f 30ff 	mov.w	r0, #4294967295
		return xReturn;
 80043d6:	e7f2      	b.n	80043be <xTaskCreate+0x4c>

080043d8 <vTaskStartScheduler>:
{
 80043d8:	b510      	push	{r4, lr}
 80043da:	b088      	sub	sp, #32
		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
 80043dc:	2400      	movs	r4, #0
 80043de:	9405      	str	r4, [sp, #20]
		StackType_t *pxIdleTaskStackBuffer = NULL;
 80043e0:	9406      	str	r4, [sp, #24]
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
 80043e2:	aa07      	add	r2, sp, #28
 80043e4:	a906      	add	r1, sp, #24
 80043e6:	a805      	add	r0, sp, #20
 80043e8:	f000 fc04 	bl	8004bf4 <vApplicationGetIdleTaskMemory>
		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
 80043ec:	9b05      	ldr	r3, [sp, #20]
 80043ee:	9302      	str	r3, [sp, #8]
 80043f0:	9b06      	ldr	r3, [sp, #24]
 80043f2:	9301      	str	r3, [sp, #4]
 80043f4:	9400      	str	r4, [sp, #0]
 80043f6:	4623      	mov	r3, r4
 80043f8:	9a07      	ldr	r2, [sp, #28]
 80043fa:	490d      	ldr	r1, [pc, #52]	; (8004430 <vTaskStartScheduler+0x58>)
 80043fc:	480d      	ldr	r0, [pc, #52]	; (8004434 <vTaskStartScheduler+0x5c>)
 80043fe:	f7ff ff7f 	bl	8004300 <xTaskCreateStatic>
		if( xIdleTaskHandle != NULL )
 8004402:	b908      	cbnz	r0, 8004408 <vTaskStartScheduler+0x30>
}
 8004404:	b008      	add	sp, #32
 8004406:	bd10      	pop	{r4, pc}
 8004408:	f04f 0350 	mov.w	r3, #80	; 0x50
 800440c:	f383 8811 	msr	BASEPRI, r3
 8004410:	f3bf 8f6f 	isb	sy
 8004414:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
 8004418:	4b07      	ldr	r3, [pc, #28]	; (8004438 <vTaskStartScheduler+0x60>)
 800441a:	f04f 32ff 	mov.w	r2, #4294967295
 800441e:	62da      	str	r2, [r3, #44]	; 0x2c
		xSchedulerRunning = pdTRUE;
 8004420:	2201      	movs	r2, #1
 8004422:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
		xTickCount = ( TickType_t ) 0U;
 8004426:	f8c3 4114 	str.w	r4, [r3, #276]	; 0x114
		if( xPortStartScheduler() != pdFALSE )
 800442a:	f000 fa75 	bl	8004918 <xPortStartScheduler>
 800442e:	e7e9      	b.n	8004404 <vTaskStartScheduler+0x2c>
 8004430:	08005efc 	.word	0x08005efc
 8004434:	08004251 	.word	0x08004251
 8004438:	2000002c 	.word	0x2000002c

0800443c <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 800443c:	4a03      	ldr	r2, [pc, #12]	; (800444c <vTaskSuspendAll+0x10>)
 800443e:	f8d2 3118 	ldr.w	r3, [r2, #280]	; 0x118
 8004442:	3301      	adds	r3, #1
 8004444:	f8c2 3118 	str.w	r3, [r2, #280]	; 0x118
}
 8004448:	4770      	bx	lr
 800444a:	bf00      	nop
 800444c:	2000002c 	.word	0x2000002c

08004450 <xTaskIncrementTick>:
{
 8004450:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8004454:	4b40      	ldr	r3, [pc, #256]	; (8004558 <xTaskIncrementTick+0x108>)
 8004456:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 800445a:	2b00      	cmp	r3, #0
 800445c:	d16c      	bne.n	8004538 <xTaskIncrementTick+0xe8>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 800445e:	4b3e      	ldr	r3, [pc, #248]	; (8004558 <xTaskIncrementTick+0x108>)
 8004460:	f8d3 5114 	ldr.w	r5, [r3, #276]	; 0x114
 8004464:	3501      	adds	r5, #1
		xTickCount = xConstTickCount;
 8004466:	f8c3 5114 	str.w	r5, [r3, #276]	; 0x114
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 800446a:	b9cd      	cbnz	r5, 80044a0 <xTaskIncrementTick+0x50>
			taskSWITCH_DELAYED_LISTS();
 800446c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800446e:	681b      	ldr	r3, [r3, #0]
 8004470:	b143      	cbz	r3, 8004484 <xTaskIncrementTick+0x34>
 8004472:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004476:	f383 8811 	msr	BASEPRI, r3
 800447a:	f3bf 8f6f 	isb	sy
 800447e:	f3bf 8f4f 	dsb	sy
 8004482:	e7fe      	b.n	8004482 <xTaskIncrementTick+0x32>
 8004484:	4b34      	ldr	r3, [pc, #208]	; (8004558 <xTaskIncrementTick+0x108>)
 8004486:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8004488:	f8d3 10f8 	ldr.w	r1, [r3, #248]	; 0xf8
 800448c:	6299      	str	r1, [r3, #40]	; 0x28
 800448e:	f8c3 20f8 	str.w	r2, [r3, #248]	; 0xf8
 8004492:	f8d3 211c 	ldr.w	r2, [r3, #284]	; 0x11c
 8004496:	3201      	adds	r2, #1
 8004498:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
 800449c:	f7ff fdc6 	bl	800402c <prvResetNextTaskUnblockTime>
		if( xConstTickCount >= xNextTaskUnblockTime )
 80044a0:	4b2d      	ldr	r3, [pc, #180]	; (8004558 <xTaskIncrementTick+0x108>)
 80044a2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80044a4:	42ab      	cmp	r3, r5
 80044a6:	d93d      	bls.n	8004524 <xTaskIncrementTick+0xd4>
BaseType_t xSwitchRequired = pdFALSE;
 80044a8:	2400      	movs	r4, #0
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 80044aa:	4a2b      	ldr	r2, [pc, #172]	; (8004558 <xTaskIncrementTick+0x108>)
 80044ac:	f8d2 3100 	ldr.w	r3, [r2, #256]	; 0x100
 80044b0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80044b2:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80044b6:	0099      	lsls	r1, r3, #2
 80044b8:	440a      	add	r2, r1
 80044ba:	6b13      	ldr	r3, [r2, #48]	; 0x30
 80044bc:	2b01      	cmp	r3, #1
 80044be:	d942      	bls.n	8004546 <xTaskIncrementTick+0xf6>
				xSwitchRequired = pdTRUE;
 80044c0:	2401      	movs	r4, #1
 80044c2:	e040      	b.n	8004546 <xTaskIncrementTick+0xf6>
							xSwitchRequired = pdTRUE;
 80044c4:	2401      	movs	r4, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80044c6:	4b24      	ldr	r3, [pc, #144]	; (8004558 <xTaskIncrementTick+0x108>)
 80044c8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80044ca:	681b      	ldr	r3, [r3, #0]
 80044cc:	b363      	cbz	r3, 8004528 <xTaskIncrementTick+0xd8>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 80044ce:	4b22      	ldr	r3, [pc, #136]	; (8004558 <xTaskIncrementTick+0x108>)
 80044d0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80044d2:	68db      	ldr	r3, [r3, #12]
 80044d4:	68de      	ldr	r6, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 80044d6:	6873      	ldr	r3, [r6, #4]
					if( xConstTickCount < xItemValue )
 80044d8:	429d      	cmp	r5, r3
 80044da:	d32a      	bcc.n	8004532 <xTaskIncrementTick+0xe2>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 80044dc:	f106 0804 	add.w	r8, r6, #4
 80044e0:	4640      	mov	r0, r8
 80044e2:	f7ff fd8f 	bl	8004004 <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 80044e6:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 80044e8:	b11b      	cbz	r3, 80044f2 <xTaskIncrementTick+0xa2>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 80044ea:	f106 0018 	add.w	r0, r6, #24
 80044ee:	f7ff fd89 	bl	8004004 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 80044f2:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 80044f4:	2201      	movs	r2, #1
 80044f6:	409a      	lsls	r2, r3
 80044f8:	4f17      	ldr	r7, [pc, #92]	; (8004558 <xTaskIncrementTick+0x108>)
 80044fa:	f8d7 110c 	ldr.w	r1, [r7, #268]	; 0x10c
 80044fe:	430a      	orrs	r2, r1
 8004500:	f8c7 210c 	str.w	r2, [r7, #268]	; 0x10c
 8004504:	f107 0030 	add.w	r0, r7, #48	; 0x30
 8004508:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800450c:	009a      	lsls	r2, r3, #2
 800450e:	4641      	mov	r1, r8
 8004510:	4410      	add	r0, r2
 8004512:	f7ff fd51 	bl	8003fb8 <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8004516:	6af2      	ldr	r2, [r6, #44]	; 0x2c
 8004518:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800451c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800451e:	429a      	cmp	r2, r3
 8004520:	d2d0      	bcs.n	80044c4 <xTaskIncrementTick+0x74>
 8004522:	e7d0      	b.n	80044c6 <xTaskIncrementTick+0x76>
BaseType_t xSwitchRequired = pdFALSE;
 8004524:	2400      	movs	r4, #0
 8004526:	e7ce      	b.n	80044c6 <xTaskIncrementTick+0x76>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004528:	4b0b      	ldr	r3, [pc, #44]	; (8004558 <xTaskIncrementTick+0x108>)
 800452a:	f04f 32ff 	mov.w	r2, #4294967295
 800452e:	62da      	str	r2, [r3, #44]	; 0x2c
					break;
 8004530:	e7bb      	b.n	80044aa <xTaskIncrementTick+0x5a>
						xNextTaskUnblockTime = xItemValue;
 8004532:	4a09      	ldr	r2, [pc, #36]	; (8004558 <xTaskIncrementTick+0x108>)
 8004534:	62d3      	str	r3, [r2, #44]	; 0x2c
						break;
 8004536:	e7b8      	b.n	80044aa <xTaskIncrementTick+0x5a>
		++uxPendedTicks;
 8004538:	4a07      	ldr	r2, [pc, #28]	; (8004558 <xTaskIncrementTick+0x108>)
 800453a:	f8d2 3120 	ldr.w	r3, [r2, #288]	; 0x120
 800453e:	3301      	adds	r3, #1
 8004540:	f8c2 3120 	str.w	r3, [r2, #288]	; 0x120
BaseType_t xSwitchRequired = pdFALSE;
 8004544:	2400      	movs	r4, #0
		if( xYieldPending != pdFALSE )
 8004546:	4b04      	ldr	r3, [pc, #16]	; (8004558 <xTaskIncrementTick+0x108>)
 8004548:	f8d3 3124 	ldr.w	r3, [r3, #292]	; 0x124
 800454c:	b103      	cbz	r3, 8004550 <xTaskIncrementTick+0x100>
			xSwitchRequired = pdTRUE;
 800454e:	2401      	movs	r4, #1
}
 8004550:	4620      	mov	r0, r4
 8004552:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8004556:	bf00      	nop
 8004558:	2000002c 	.word	0x2000002c

0800455c <xTaskResumeAll>:
	configASSERT( uxSchedulerSuspended );
 800455c:	4b39      	ldr	r3, [pc, #228]	; (8004644 <xTaskResumeAll+0xe8>)
 800455e:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 8004562:	b943      	cbnz	r3, 8004576 <xTaskResumeAll+0x1a>
 8004564:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004568:	f383 8811 	msr	BASEPRI, r3
 800456c:	f3bf 8f6f 	isb	sy
 8004570:	f3bf 8f4f 	dsb	sy
 8004574:	e7fe      	b.n	8004574 <xTaskResumeAll+0x18>
{
 8004576:	b570      	push	{r4, r5, r6, lr}
	taskENTER_CRITICAL();
 8004578:	f000 f93c 	bl	80047f4 <vPortEnterCritical>
		--uxSchedulerSuspended;
 800457c:	4b31      	ldr	r3, [pc, #196]	; (8004644 <xTaskResumeAll+0xe8>)
 800457e:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8004582:	3a01      	subs	r2, #1
 8004584:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8004588:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 800458c:	2b00      	cmp	r3, #0
 800458e:	d154      	bne.n	800463a <xTaskResumeAll+0xde>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 8004590:	4b2c      	ldr	r3, [pc, #176]	; (8004644 <xTaskResumeAll+0xe8>)
 8004592:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 8004596:	b923      	cbnz	r3, 80045a2 <xTaskResumeAll+0x46>
BaseType_t xAlreadyYielded = pdFALSE;
 8004598:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 800459a:	f000 f94d 	bl	8004838 <vPortExitCritical>
}
 800459e:	4620      	mov	r0, r4
 80045a0:	bd70      	pop	{r4, r5, r6, pc}
TCB_t *pxTCB = NULL;
 80045a2:	2400      	movs	r4, #0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 80045a4:	4b27      	ldr	r3, [pc, #156]	; (8004644 <xTaskResumeAll+0xe8>)
 80045a6:	695b      	ldr	r3, [r3, #20]
 80045a8:	b32b      	cbz	r3, 80045f6 <xTaskResumeAll+0x9a>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 80045aa:	4d26      	ldr	r5, [pc, #152]	; (8004644 <xTaskResumeAll+0xe8>)
 80045ac:	6a2b      	ldr	r3, [r5, #32]
 80045ae:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 80045b0:	f104 0018 	add.w	r0, r4, #24
 80045b4:	f7ff fd26 	bl	8004004 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 80045b8:	1d26      	adds	r6, r4, #4
 80045ba:	4630      	mov	r0, r6
 80045bc:	f7ff fd22 	bl	8004004 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 80045c0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80045c2:	2201      	movs	r2, #1
 80045c4:	409a      	lsls	r2, r3
 80045c6:	f8d5 110c 	ldr.w	r1, [r5, #268]	; 0x10c
 80045ca:	430a      	orrs	r2, r1
 80045cc:	f8c5 210c 	str.w	r2, [r5, #268]	; 0x10c
 80045d0:	f105 0030 	add.w	r0, r5, #48	; 0x30
 80045d4:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80045d8:	009a      	lsls	r2, r3, #2
 80045da:	4631      	mov	r1, r6
 80045dc:	4410      	add	r0, r2
 80045de:	f7ff fceb 	bl	8003fb8 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 80045e2:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80045e4:	f8d5 3100 	ldr.w	r3, [r5, #256]	; 0x100
 80045e8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80045ea:	429a      	cmp	r2, r3
 80045ec:	d3da      	bcc.n	80045a4 <xTaskResumeAll+0x48>
						xYieldPending = pdTRUE;
 80045ee:	2201      	movs	r2, #1
 80045f0:	f8c5 2124 	str.w	r2, [r5, #292]	; 0x124
 80045f4:	e7d6      	b.n	80045a4 <xTaskResumeAll+0x48>
				if( pxTCB != NULL )
 80045f6:	b10c      	cbz	r4, 80045fc <xTaskResumeAll+0xa0>
					prvResetNextTaskUnblockTime();
 80045f8:	f7ff fd18 	bl	800402c <prvResetNextTaskUnblockTime>
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 80045fc:	4b11      	ldr	r3, [pc, #68]	; (8004644 <xTaskResumeAll+0xe8>)
 80045fe:	f8d3 4120 	ldr.w	r4, [r3, #288]	; 0x120
					if( uxPendedCounts > ( UBaseType_t ) 0U )
 8004602:	b164      	cbz	r4, 800461e <xTaskResumeAll+0xc2>
							if( xTaskIncrementTick() != pdFALSE )
 8004604:	f7ff ff24 	bl	8004450 <xTaskIncrementTick>
 8004608:	b118      	cbz	r0, 8004612 <xTaskResumeAll+0xb6>
								xYieldPending = pdTRUE;
 800460a:	4b0e      	ldr	r3, [pc, #56]	; (8004644 <xTaskResumeAll+0xe8>)
 800460c:	2201      	movs	r2, #1
 800460e:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 8004612:	3c01      	subs	r4, #1
 8004614:	d1f6      	bne.n	8004604 <xTaskResumeAll+0xa8>
						uxPendedTicks = 0;
 8004616:	4b0b      	ldr	r3, [pc, #44]	; (8004644 <xTaskResumeAll+0xe8>)
 8004618:	2200      	movs	r2, #0
 800461a:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
				if( xYieldPending != pdFALSE )
 800461e:	4b09      	ldr	r3, [pc, #36]	; (8004644 <xTaskResumeAll+0xe8>)
 8004620:	f8d3 3124 	ldr.w	r3, [r3, #292]	; 0x124
 8004624:	b15b      	cbz	r3, 800463e <xTaskResumeAll+0xe2>
					taskYIELD_IF_USING_PREEMPTION();
 8004626:	4b08      	ldr	r3, [pc, #32]	; (8004648 <xTaskResumeAll+0xec>)
 8004628:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800462c:	601a      	str	r2, [r3, #0]
 800462e:	f3bf 8f4f 	dsb	sy
 8004632:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
 8004636:	2401      	movs	r4, #1
 8004638:	e7af      	b.n	800459a <xTaskResumeAll+0x3e>
BaseType_t xAlreadyYielded = pdFALSE;
 800463a:	2400      	movs	r4, #0
 800463c:	e7ad      	b.n	800459a <xTaskResumeAll+0x3e>
 800463e:	2400      	movs	r4, #0
 8004640:	e7ab      	b.n	800459a <xTaskResumeAll+0x3e>
 8004642:	bf00      	nop
 8004644:	2000002c 	.word	0x2000002c
 8004648:	e000ed04 	.word	0xe000ed04

0800464c <vTaskDelay>:
	{
 800464c:	b510      	push	{r4, lr}
		if( xTicksToDelay > ( TickType_t ) 0U )
 800464e:	b1b0      	cbz	r0, 800467e <vTaskDelay+0x32>
 8004650:	4604      	mov	r4, r0
			configASSERT( uxSchedulerSuspended == 0 );
 8004652:	4b0f      	ldr	r3, [pc, #60]	; (8004690 <vTaskDelay+0x44>)
 8004654:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 8004658:	b143      	cbz	r3, 800466c <vTaskDelay+0x20>
 800465a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800465e:	f383 8811 	msr	BASEPRI, r3
 8004662:	f3bf 8f6f 	isb	sy
 8004666:	f3bf 8f4f 	dsb	sy
 800466a:	e7fe      	b.n	800466a <vTaskDelay+0x1e>
			vTaskSuspendAll();
 800466c:	f7ff fee6 	bl	800443c <vTaskSuspendAll>
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 8004670:	2100      	movs	r1, #0
 8004672:	4620      	mov	r0, r4
 8004674:	f7ff fe00 	bl	8004278 <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
 8004678:	f7ff ff70 	bl	800455c <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
 800467c:	b938      	cbnz	r0, 800468e <vTaskDelay+0x42>
			portYIELD_WITHIN_API();
 800467e:	4b05      	ldr	r3, [pc, #20]	; (8004694 <vTaskDelay+0x48>)
 8004680:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004684:	601a      	str	r2, [r3, #0]
 8004686:	f3bf 8f4f 	dsb	sy
 800468a:	f3bf 8f6f 	isb	sy
	}
 800468e:	bd10      	pop	{r4, pc}
 8004690:	2000002c 	.word	0x2000002c
 8004694:	e000ed04 	.word	0xe000ed04

08004698 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8004698:	4b22      	ldr	r3, [pc, #136]	; (8004724 <vTaskSwitchContext+0x8c>)
 800469a:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 800469e:	b123      	cbz	r3, 80046aa <vTaskSwitchContext+0x12>
		xYieldPending = pdTRUE;
 80046a0:	4b20      	ldr	r3, [pc, #128]	; (8004724 <vTaskSwitchContext+0x8c>)
 80046a2:	2201      	movs	r2, #1
 80046a4:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
 80046a8:	4770      	bx	lr
		xYieldPending = pdFALSE;
 80046aa:	4a1e      	ldr	r2, [pc, #120]	; (8004724 <vTaskSwitchContext+0x8c>)
 80046ac:	2300      	movs	r3, #0
 80046ae:	f8c2 3124 	str.w	r3, [r2, #292]	; 0x124
		taskSELECT_HIGHEST_PRIORITY_TASK();
 80046b2:	f8d2 310c 	ldr.w	r3, [r2, #268]	; 0x10c
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 80046b6:	fab3 f383 	clz	r3, r3
 80046ba:	b2db      	uxtb	r3, r3
 80046bc:	f1c3 031f 	rsb	r3, r3, #31
 80046c0:	eb03 0083 	add.w	r0, r3, r3, lsl #2
 80046c4:	0081      	lsls	r1, r0, #2
 80046c6:	440a      	add	r2, r1
 80046c8:	6b12      	ldr	r2, [r2, #48]	; 0x30
 80046ca:	b942      	cbnz	r2, 80046de <vTaskSwitchContext+0x46>
	__asm volatile
 80046cc:	f04f 0350 	mov.w	r3, #80	; 0x50
 80046d0:	f383 8811 	msr	BASEPRI, r3
 80046d4:	f3bf 8f6f 	isb	sy
 80046d8:	f3bf 8f4f 	dsb	sy
 80046dc:	e7fe      	b.n	80046dc <vTaskSwitchContext+0x44>
{
 80046de:	b410      	push	{r4}
		taskSELECT_HIGHEST_PRIORITY_TASK();
 80046e0:	4a10      	ldr	r2, [pc, #64]	; (8004724 <vTaskSwitchContext+0x8c>)
 80046e2:	0099      	lsls	r1, r3, #2
 80046e4:	18cc      	adds	r4, r1, r3
 80046e6:	00a0      	lsls	r0, r4, #2
 80046e8:	4410      	add	r0, r2
 80046ea:	6b44      	ldr	r4, [r0, #52]	; 0x34
 80046ec:	6864      	ldr	r4, [r4, #4]
 80046ee:	6344      	str	r4, [r0, #52]	; 0x34
 80046f0:	3230      	adds	r2, #48	; 0x30
 80046f2:	4419      	add	r1, r3
 80046f4:	0088      	lsls	r0, r1, #2
 80046f6:	3008      	adds	r0, #8
 80046f8:	4402      	add	r2, r0
 80046fa:	4294      	cmp	r4, r2
 80046fc:	d00a      	beq.n	8004714 <vTaskSwitchContext+0x7c>
 80046fe:	4909      	ldr	r1, [pc, #36]	; (8004724 <vTaskSwitchContext+0x8c>)
 8004700:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8004704:	009a      	lsls	r2, r3, #2
 8004706:	440a      	add	r2, r1
 8004708:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800470a:	68db      	ldr	r3, [r3, #12]
 800470c:	f8c1 3100 	str.w	r3, [r1, #256]	; 0x100
}
 8004710:	bc10      	pop	{r4}
 8004712:	4770      	bx	lr
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8004714:	6861      	ldr	r1, [r4, #4]
 8004716:	4803      	ldr	r0, [pc, #12]	; (8004724 <vTaskSwitchContext+0x8c>)
 8004718:	2214      	movs	r2, #20
 800471a:	fb02 0203 	mla	r2, r2, r3, r0
 800471e:	6351      	str	r1, [r2, #52]	; 0x34
 8004720:	e7ed      	b.n	80046fe <vTaskSwitchContext+0x66>
 8004722:	bf00      	nop
 8004724:	2000002c 	.word	0x2000002c

08004728 <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
 8004728:	4b06      	ldr	r3, [pc, #24]	; (8004744 <xTaskGetSchedulerState+0x1c>)
 800472a:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 800472e:	b13b      	cbz	r3, 8004740 <xTaskGetSchedulerState+0x18>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8004730:	4b04      	ldr	r3, [pc, #16]	; (8004744 <xTaskGetSchedulerState+0x1c>)
 8004732:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 8004736:	b10b      	cbz	r3, 800473c <xTaskGetSchedulerState+0x14>
				xReturn = taskSCHEDULER_SUSPENDED;
 8004738:	2000      	movs	r0, #0
	}
 800473a:	4770      	bx	lr
				xReturn = taskSCHEDULER_RUNNING;
 800473c:	2002      	movs	r0, #2
 800473e:	4770      	bx	lr
			xReturn = taskSCHEDULER_NOT_STARTED;
 8004740:	2001      	movs	r0, #1
 8004742:	4770      	bx	lr
 8004744:	2000002c 	.word	0x2000002c

08004748 <prvTaskExitError>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
 8004748:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0UL;
 800474a:	2300      	movs	r3, #0
 800474c:	9301      	str	r3, [sp, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 800474e:	4b0d      	ldr	r3, [pc, #52]	; (8004784 <prvTaskExitError+0x3c>)
 8004750:	681b      	ldr	r3, [r3, #0]
 8004752:	f1b3 3fff 	cmp.w	r3, #4294967295
 8004756:	d008      	beq.n	800476a <prvTaskExitError+0x22>
 8004758:	f04f 0350 	mov.w	r3, #80	; 0x50
 800475c:	f383 8811 	msr	BASEPRI, r3
 8004760:	f3bf 8f6f 	isb	sy
 8004764:	f3bf 8f4f 	dsb	sy
 8004768:	e7fe      	b.n	8004768 <prvTaskExitError+0x20>
 800476a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800476e:	f383 8811 	msr	BASEPRI, r3
 8004772:	f3bf 8f6f 	isb	sy
 8004776:	f3bf 8f4f 	dsb	sy
	portDISABLE_INTERRUPTS();
	while( ulDummy == 0 )
 800477a:	9b01      	ldr	r3, [sp, #4]
 800477c:	2b00      	cmp	r3, #0
 800477e:	d0fc      	beq.n	800477a <prvTaskExitError+0x32>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
 8004780:	b002      	add	sp, #8
 8004782:	4770      	bx	lr
 8004784:	20000008 	.word	0x20000008

08004788 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
 8004788:	4806      	ldr	r0, [pc, #24]	; (80047a4 <prvPortStartFirstTask+0x1c>)
 800478a:	6800      	ldr	r0, [r0, #0]
 800478c:	6800      	ldr	r0, [r0, #0]
 800478e:	f380 8808 	msr	MSP, r0
 8004792:	b662      	cpsie	i
 8004794:	b661      	cpsie	f
 8004796:	f3bf 8f4f 	dsb	sy
 800479a:	f3bf 8f6f 	isb	sy
 800479e:	df00      	svc	0
 80047a0:	bf00      	nop
 80047a2:	0000      	.short	0x0000
 80047a4:	e000ed08 	.word	0xe000ed08

080047a8 <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 80047a8:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 80047ac:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 80047b0:	f021 0101 	bic.w	r1, r1, #1
 80047b4:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 80047b8:	4b03      	ldr	r3, [pc, #12]	; (80047c8 <pxPortInitialiseStack+0x20>)
 80047ba:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 80047be:	f840 2c20 	str.w	r2, [r0, #-32]
}
 80047c2:	3840      	subs	r0, #64	; 0x40
 80047c4:	4770      	bx	lr
 80047c6:	bf00      	nop
 80047c8:	08004749 	.word	0x08004749
 80047cc:	00000000 	.word	0x00000000

080047d0 <SVC_Handler>:
	__asm volatile (
 80047d0:	4b07      	ldr	r3, [pc, #28]	; (80047f0 <pxCurrentTCBConst2>)
 80047d2:	6819      	ldr	r1, [r3, #0]
 80047d4:	6808      	ldr	r0, [r1, #0]
 80047d6:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80047da:	f380 8809 	msr	PSP, r0
 80047de:	f3bf 8f6f 	isb	sy
 80047e2:	f04f 0000 	mov.w	r0, #0
 80047e6:	f380 8811 	msr	BASEPRI, r0
 80047ea:	f04e 0e0d 	orr.w	lr, lr, #13
 80047ee:	4770      	bx	lr

080047f0 <pxCurrentTCBConst2>:
 80047f0:	2000012c 	.word	0x2000012c

080047f4 <vPortEnterCritical>:
 80047f4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80047f8:	f383 8811 	msr	BASEPRI, r3
 80047fc:	f3bf 8f6f 	isb	sy
 8004800:	f3bf 8f4f 	dsb	sy
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
	portDISABLE_INTERRUPTS();
	uxCriticalNesting++;
 8004804:	4a0a      	ldr	r2, [pc, #40]	; (8004830 <vPortEnterCritical+0x3c>)
 8004806:	6813      	ldr	r3, [r2, #0]
 8004808:	3301      	adds	r3, #1
 800480a:	6013      	str	r3, [r2, #0]
	/* This is not the interrupt safe version of the enter critical function so
	assert() if it is being called from an interrupt context.  Only API
	functions that end in "FromISR" can be used in an interrupt.  Only assert if
	the critical nesting count is 1 to protect against recursive calls if the
	assert function also uses a critical section. */
	if( uxCriticalNesting == 1 )
 800480c:	2b01      	cmp	r3, #1
 800480e:	d000      	beq.n	8004812 <vPortEnterCritical+0x1e>
	{
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
	}
}
 8004810:	4770      	bx	lr
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 8004812:	4b08      	ldr	r3, [pc, #32]	; (8004834 <vPortEnterCritical+0x40>)
 8004814:	681b      	ldr	r3, [r3, #0]
 8004816:	f013 0fff 	tst.w	r3, #255	; 0xff
 800481a:	d0f9      	beq.n	8004810 <vPortEnterCritical+0x1c>
 800481c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004820:	f383 8811 	msr	BASEPRI, r3
 8004824:	f3bf 8f6f 	isb	sy
 8004828:	f3bf 8f4f 	dsb	sy
 800482c:	e7fe      	b.n	800482c <vPortEnterCritical+0x38>
 800482e:	bf00      	nop
 8004830:	20000008 	.word	0x20000008
 8004834:	e000ed04 	.word	0xe000ed04

08004838 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	configASSERT( uxCriticalNesting );
 8004838:	4b09      	ldr	r3, [pc, #36]	; (8004860 <vPortExitCritical+0x28>)
 800483a:	681b      	ldr	r3, [r3, #0]
 800483c:	b943      	cbnz	r3, 8004850 <vPortExitCritical+0x18>
 800483e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004842:	f383 8811 	msr	BASEPRI, r3
 8004846:	f3bf 8f6f 	isb	sy
 800484a:	f3bf 8f4f 	dsb	sy
 800484e:	e7fe      	b.n	800484e <vPortExitCritical+0x16>
	uxCriticalNesting--;
 8004850:	3b01      	subs	r3, #1
 8004852:	4a03      	ldr	r2, [pc, #12]	; (8004860 <vPortExitCritical+0x28>)
 8004854:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 8004856:	b90b      	cbnz	r3, 800485c <vPortExitCritical+0x24>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 8004858:	f383 8811 	msr	BASEPRI, r3
	{
		portENABLE_INTERRUPTS();
	}
}
 800485c:	4770      	bx	lr
 800485e:	bf00      	nop
 8004860:	20000008 	.word	0x20000008
	...

08004870 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 8004870:	f3ef 8009 	mrs	r0, PSP
 8004874:	f3bf 8f6f 	isb	sy
 8004878:	4b0d      	ldr	r3, [pc, #52]	; (80048b0 <pxCurrentTCBConst>)
 800487a:	681a      	ldr	r2, [r3, #0]
 800487c:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8004880:	6010      	str	r0, [r2, #0]
 8004882:	e92d 4008 	stmdb	sp!, {r3, lr}
 8004886:	f04f 0050 	mov.w	r0, #80	; 0x50
 800488a:	f380 8811 	msr	BASEPRI, r0
 800488e:	f7ff ff03 	bl	8004698 <vTaskSwitchContext>
 8004892:	f04f 0000 	mov.w	r0, #0
 8004896:	f380 8811 	msr	BASEPRI, r0
 800489a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 800489e:	6819      	ldr	r1, [r3, #0]
 80048a0:	6808      	ldr	r0, [r1, #0]
 80048a2:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80048a6:	f380 8809 	msr	PSP, r0
 80048aa:	f3bf 8f6f 	isb	sy
 80048ae:	4770      	bx	lr

080048b0 <pxCurrentTCBConst>:
 80048b0:	2000012c 	.word	0x2000012c

080048b4 <xPortSysTickHandler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 80048b4:	b508      	push	{r3, lr}
	__asm volatile
 80048b6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80048ba:	f383 8811 	msr	BASEPRI, r3
 80048be:	f3bf 8f6f 	isb	sy
 80048c2:	f3bf 8f4f 	dsb	sy
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 80048c6:	f7ff fdc3 	bl	8004450 <xTaskIncrementTick>
 80048ca:	b118      	cbz	r0, 80048d4 <xPortSysTickHandler+0x20>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 80048cc:	4b03      	ldr	r3, [pc, #12]	; (80048dc <xPortSysTickHandler+0x28>)
 80048ce:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80048d2:	601a      	str	r2, [r3, #0]
	__asm volatile
 80048d4:	2300      	movs	r3, #0
 80048d6:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portENABLE_INTERRUPTS();
}
 80048da:	bd08      	pop	{r3, pc}
 80048dc:	e000ed04 	.word	0xe000ed04

080048e0 <vPortSetupTimerInterrupt>:
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Stop and clear the SysTick. */
	portNVIC_SYSTICK_CTRL_REG = 0UL;
 80048e0:	4a08      	ldr	r2, [pc, #32]	; (8004904 <vPortSetupTimerInterrupt+0x24>)
 80048e2:	2300      	movs	r3, #0
 80048e4:	6013      	str	r3, [r2, #0]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 80048e6:	4908      	ldr	r1, [pc, #32]	; (8004908 <vPortSetupTimerInterrupt+0x28>)
 80048e8:	600b      	str	r3, [r1, #0]

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 80048ea:	4b08      	ldr	r3, [pc, #32]	; (800490c <vPortSetupTimerInterrupt+0x2c>)
 80048ec:	681b      	ldr	r3, [r3, #0]
 80048ee:	4908      	ldr	r1, [pc, #32]	; (8004910 <vPortSetupTimerInterrupt+0x30>)
 80048f0:	fba1 1303 	umull	r1, r3, r1, r3
 80048f4:	099b      	lsrs	r3, r3, #6
 80048f6:	3b01      	subs	r3, #1
 80048f8:	4906      	ldr	r1, [pc, #24]	; (8004914 <vPortSetupTimerInterrupt+0x34>)
 80048fa:	600b      	str	r3, [r1, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 80048fc:	2307      	movs	r3, #7
 80048fe:	6013      	str	r3, [r2, #0]
}
 8004900:	4770      	bx	lr
 8004902:	bf00      	nop
 8004904:	e000e010 	.word	0xe000e010
 8004908:	e000e018 	.word	0xe000e018
 800490c:	2000000c 	.word	0x2000000c
 8004910:	10624dd3 	.word	0x10624dd3
 8004914:	e000e014 	.word	0xe000e014

08004918 <xPortStartScheduler>:
{
 8004918:	b510      	push	{r4, lr}
 800491a:	b082      	sub	sp, #8
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 800491c:	4b27      	ldr	r3, [pc, #156]	; (80049bc <xPortStartScheduler+0xa4>)
 800491e:	781a      	ldrb	r2, [r3, #0]
 8004920:	b2d2      	uxtb	r2, r2
 8004922:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 8004924:	22ff      	movs	r2, #255	; 0xff
 8004926:	701a      	strb	r2, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 8004928:	781b      	ldrb	r3, [r3, #0]
 800492a:	b2db      	uxtb	r3, r3
 800492c:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8004930:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8004934:	f003 0350 	and.w	r3, r3, #80	; 0x50
 8004938:	4a21      	ldr	r2, [pc, #132]	; (80049c0 <xPortStartScheduler+0xa8>)
 800493a:	7013      	strb	r3, [r2, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 800493c:	2307      	movs	r3, #7
 800493e:	6053      	str	r3, [r2, #4]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8004940:	e009      	b.n	8004956 <xPortStartScheduler+0x3e>
			ulMaxPRIGROUPValue--;
 8004942:	4a1f      	ldr	r2, [pc, #124]	; (80049c0 <xPortStartScheduler+0xa8>)
 8004944:	6853      	ldr	r3, [r2, #4]
 8004946:	3b01      	subs	r3, #1
 8004948:	6053      	str	r3, [r2, #4]
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 800494a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800494e:	005b      	lsls	r3, r3, #1
 8004950:	b2db      	uxtb	r3, r3
 8004952:	f88d 3003 	strb.w	r3, [sp, #3]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8004956:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800495a:	f013 0f80 	tst.w	r3, #128	; 0x80
 800495e:	d1f0      	bne.n	8004942 <xPortStartScheduler+0x2a>
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
 8004960:	4b17      	ldr	r3, [pc, #92]	; (80049c0 <xPortStartScheduler+0xa8>)
 8004962:	685b      	ldr	r3, [r3, #4]
 8004964:	2b03      	cmp	r3, #3
 8004966:	d008      	beq.n	800497a <xPortStartScheduler+0x62>
	__asm volatile
 8004968:	f04f 0350 	mov.w	r3, #80	; 0x50
 800496c:	f383 8811 	msr	BASEPRI, r3
 8004970:	f3bf 8f6f 	isb	sy
 8004974:	f3bf 8f4f 	dsb	sy
 8004978:	e7fe      	b.n	8004978 <xPortStartScheduler+0x60>
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 800497a:	021b      	lsls	r3, r3, #8
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 800497c:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8004980:	4a0f      	ldr	r2, [pc, #60]	; (80049c0 <xPortStartScheduler+0xa8>)
 8004982:	6053      	str	r3, [r2, #4]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 8004984:	9b01      	ldr	r3, [sp, #4]
 8004986:	b2db      	uxtb	r3, r3
 8004988:	4a0c      	ldr	r2, [pc, #48]	; (80049bc <xPortStartScheduler+0xa4>)
 800498a:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 800498c:	4b0d      	ldr	r3, [pc, #52]	; (80049c4 <xPortStartScheduler+0xac>)
 800498e:	681a      	ldr	r2, [r3, #0]
 8004990:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 8004994:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 8004996:	681a      	ldr	r2, [r3, #0]
 8004998:	f042 4270 	orr.w	r2, r2, #4026531840	; 0xf0000000
 800499c:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
 800499e:	f7ff ff9f 	bl	80048e0 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
 80049a2:	2400      	movs	r4, #0
 80049a4:	4b08      	ldr	r3, [pc, #32]	; (80049c8 <xPortStartScheduler+0xb0>)
 80049a6:	601c      	str	r4, [r3, #0]
	prvPortStartFirstTask();
 80049a8:	f7ff feee 	bl	8004788 <prvPortStartFirstTask>
	vTaskSwitchContext();
 80049ac:	f7ff fe74 	bl	8004698 <vTaskSwitchContext>
	prvTaskExitError();
 80049b0:	f7ff feca 	bl	8004748 <prvTaskExitError>
}
 80049b4:	4620      	mov	r0, r4
 80049b6:	b002      	add	sp, #8
 80049b8:	bd10      	pop	{r4, pc}
 80049ba:	bf00      	nop
 80049bc:	e000e400 	.word	0xe000e400
 80049c0:	20000154 	.word	0x20000154
 80049c4:	e000ed20 	.word	0xe000ed20
 80049c8:	20000008 	.word	0x20000008

080049cc <prvHeapInit>:
uint8_t *pucAlignedHeap;
size_t uxAddress;
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;

	/* Ensure the heap starts on a correctly aligned boundary. */
	uxAddress = ( size_t ) ucHeap;
 80049cc:	4a13      	ldr	r2, [pc, #76]	; (8004a1c <prvHeapInit+0x50>)

	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 80049ce:	f012 0f07 	tst.w	r2, #7
 80049d2:	d020      	beq.n	8004a16 <prvHeapInit+0x4a>
	{
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 80049d4:	1dd1      	adds	r1, r2, #7
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 80049d6:	f021 0107 	bic.w	r1, r1, #7
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 80049da:	f5c1 6340 	rsb	r3, r1, #3072	; 0xc00
 80049de:	4413      	add	r3, r2
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 80049e0:	460a      	mov	r2, r1

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 80049e2:	490e      	ldr	r1, [pc, #56]	; (8004a1c <prvHeapInit+0x50>)
 80049e4:	f8c1 2c00 	str.w	r2, [r1, #3072]	; 0xc00
	xStart.xBlockSize = ( size_t ) 0;
 80049e8:	2000      	movs	r0, #0
 80049ea:	f8c1 0c04 	str.w	r0, [r1, #3076]	; 0xc04

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 80049ee:	4413      	add	r3, r2
	uxAddress -= xHeapStructSize;
 80049f0:	3b08      	subs	r3, #8
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 80049f2:	f023 0307 	bic.w	r3, r3, #7
	pxEnd = ( void * ) uxAddress;
 80049f6:	f8c1 3c08 	str.w	r3, [r1, #3080]	; 0xc08
	pxEnd->xBlockSize = 0;
 80049fa:	6058      	str	r0, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
 80049fc:	6018      	str	r0, [r3, #0]

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 80049fe:	1a98      	subs	r0, r3, r2
 8004a00:	6050      	str	r0, [r2, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 8004a02:	6013      	str	r3, [r2, #0]

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8004a04:	f8c1 0c0c 	str.w	r0, [r1, #3084]	; 0xc0c
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8004a08:	f8c1 0c10 	str.w	r0, [r1, #3088]	; 0xc10

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 8004a0c:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 8004a10:	f8c1 3c14 	str.w	r3, [r1, #3092]	; 0xc14
}
 8004a14:	4770      	bx	lr
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
 8004a16:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 8004a1a:	e7e2      	b.n	80049e2 <prvHeapInit+0x16>
 8004a1c:	2000015c 	.word	0x2000015c

08004a20 <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 8004a20:	b410      	push	{r4}
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 8004a22:	4b13      	ldr	r3, [pc, #76]	; (8004a70 <prvInsertBlockIntoFreeList+0x50>)
 8004a24:	681a      	ldr	r2, [r3, #0]
 8004a26:	4282      	cmp	r2, r0
 8004a28:	d31b      	bcc.n	8004a62 <prvInsertBlockIntoFreeList+0x42>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 8004a2a:	6859      	ldr	r1, [r3, #4]
 8004a2c:	185c      	adds	r4, r3, r1
 8004a2e:	4284      	cmp	r4, r0
 8004a30:	d103      	bne.n	8004a3a <prvInsertBlockIntoFreeList+0x1a>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 8004a32:	6840      	ldr	r0, [r0, #4]
 8004a34:	4401      	add	r1, r0
 8004a36:	6059      	str	r1, [r3, #4]
		pxBlockToInsert = pxIterator;
 8004a38:	4618      	mov	r0, r3
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 8004a3a:	6841      	ldr	r1, [r0, #4]
 8004a3c:	1844      	adds	r4, r0, r1
 8004a3e:	42a2      	cmp	r2, r4
 8004a40:	d113      	bne.n	8004a6a <prvInsertBlockIntoFreeList+0x4a>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 8004a42:	4c0c      	ldr	r4, [pc, #48]	; (8004a74 <prvInsertBlockIntoFreeList+0x54>)
 8004a44:	f8d4 4c08 	ldr.w	r4, [r4, #3080]	; 0xc08
 8004a48:	42a2      	cmp	r2, r4
 8004a4a:	d00c      	beq.n	8004a66 <prvInsertBlockIntoFreeList+0x46>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8004a4c:	6852      	ldr	r2, [r2, #4]
 8004a4e:	4411      	add	r1, r2
 8004a50:	6041      	str	r1, [r0, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8004a52:	681a      	ldr	r2, [r3, #0]
 8004a54:	6812      	ldr	r2, [r2, #0]
 8004a56:	6002      	str	r2, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 8004a58:	4298      	cmp	r0, r3
 8004a5a:	d000      	beq.n	8004a5e <prvInsertBlockIntoFreeList+0x3e>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 8004a5c:	6018      	str	r0, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 8004a5e:	bc10      	pop	{r4}
 8004a60:	4770      	bx	lr
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 8004a62:	4613      	mov	r3, r2
 8004a64:	e7de      	b.n	8004a24 <prvInsertBlockIntoFreeList+0x4>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
 8004a66:	6004      	str	r4, [r0, #0]
 8004a68:	e7f6      	b.n	8004a58 <prvInsertBlockIntoFreeList+0x38>
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 8004a6a:	6002      	str	r2, [r0, #0]
 8004a6c:	e7f4      	b.n	8004a58 <prvInsertBlockIntoFreeList+0x38>
 8004a6e:	bf00      	nop
 8004a70:	20000d5c 	.word	0x20000d5c
 8004a74:	2000015c 	.word	0x2000015c

08004a78 <pvPortMalloc>:
{
 8004a78:	b570      	push	{r4, r5, r6, lr}
 8004a7a:	4604      	mov	r4, r0
	vTaskSuspendAll();
 8004a7c:	f7ff fcde 	bl	800443c <vTaskSuspendAll>
		if( pxEnd == NULL )
 8004a80:	4b3f      	ldr	r3, [pc, #252]	; (8004b80 <pvPortMalloc+0x108>)
 8004a82:	f8d3 3c08 	ldr.w	r3, [r3, #3080]	; 0xc08
 8004a86:	b1c3      	cbz	r3, 8004aba <pvPortMalloc+0x42>
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 8004a88:	4b3d      	ldr	r3, [pc, #244]	; (8004b80 <pvPortMalloc+0x108>)
 8004a8a:	f8d3 3c14 	ldr.w	r3, [r3, #3092]	; 0xc14
 8004a8e:	421c      	tst	r4, r3
 8004a90:	d16c      	bne.n	8004b6c <pvPortMalloc+0xf4>
			if( xWantedSize > 0 )
 8004a92:	b1ac      	cbz	r4, 8004ac0 <pvPortMalloc+0x48>
				xWantedSize += xHeapStructSize;
 8004a94:	3408      	adds	r4, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 8004a96:	f014 0f07 	tst.w	r4, #7
 8004a9a:	d011      	beq.n	8004ac0 <pvPortMalloc+0x48>
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 8004a9c:	f024 0407 	bic.w	r4, r4, #7
 8004aa0:	3408      	adds	r4, #8
					configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
 8004aa2:	f004 0307 	and.w	r3, r4, #7
 8004aa6:	b15b      	cbz	r3, 8004ac0 <pvPortMalloc+0x48>
 8004aa8:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004aac:	f383 8811 	msr	BASEPRI, r3
 8004ab0:	f3bf 8f6f 	isb	sy
 8004ab4:	f3bf 8f4f 	dsb	sy
 8004ab8:	e7fe      	b.n	8004ab8 <pvPortMalloc+0x40>
			prvHeapInit();
 8004aba:	f7ff ff87 	bl	80049cc <prvHeapInit>
 8004abe:	e7e3      	b.n	8004a88 <pvPortMalloc+0x10>
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 8004ac0:	2c00      	cmp	r4, #0
 8004ac2:	d055      	beq.n	8004b70 <pvPortMalloc+0xf8>
 8004ac4:	4b2e      	ldr	r3, [pc, #184]	; (8004b80 <pvPortMalloc+0x108>)
 8004ac6:	f8d3 3c10 	ldr.w	r3, [r3, #3088]	; 0xc10
 8004aca:	42a3      	cmp	r3, r4
 8004acc:	d352      	bcc.n	8004b74 <pvPortMalloc+0xfc>
				pxBlock = xStart.pxNextFreeBlock;
 8004ace:	4b2c      	ldr	r3, [pc, #176]	; (8004b80 <pvPortMalloc+0x108>)
 8004ad0:	f8d3 5c00 	ldr.w	r5, [r3, #3072]	; 0xc00
				pxPreviousBlock = &xStart;
 8004ad4:	f503 6340 	add.w	r3, r3, #3072	; 0xc00
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8004ad8:	e001      	b.n	8004ade <pvPortMalloc+0x66>
					pxPreviousBlock = pxBlock;
 8004ada:	462b      	mov	r3, r5
					pxBlock = pxBlock->pxNextFreeBlock;
 8004adc:	4615      	mov	r5, r2
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8004ade:	686a      	ldr	r2, [r5, #4]
 8004ae0:	42a2      	cmp	r2, r4
 8004ae2:	d202      	bcs.n	8004aea <pvPortMalloc+0x72>
 8004ae4:	682a      	ldr	r2, [r5, #0]
 8004ae6:	2a00      	cmp	r2, #0
 8004ae8:	d1f7      	bne.n	8004ada <pvPortMalloc+0x62>
				if( pxBlock != pxEnd )
 8004aea:	4a25      	ldr	r2, [pc, #148]	; (8004b80 <pvPortMalloc+0x108>)
 8004aec:	f8d2 2c08 	ldr.w	r2, [r2, #3080]	; 0xc08
 8004af0:	42aa      	cmp	r2, r5
 8004af2:	d041      	beq.n	8004b78 <pvPortMalloc+0x100>
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 8004af4:	681e      	ldr	r6, [r3, #0]
 8004af6:	3608      	adds	r6, #8
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8004af8:	682a      	ldr	r2, [r5, #0]
 8004afa:	601a      	str	r2, [r3, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 8004afc:	686b      	ldr	r3, [r5, #4]
 8004afe:	1b1b      	subs	r3, r3, r4
 8004b00:	2b10      	cmp	r3, #16
 8004b02:	d910      	bls.n	8004b26 <pvPortMalloc+0xae>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 8004b04:	1928      	adds	r0, r5, r4
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 8004b06:	f010 0f07 	tst.w	r0, #7
 8004b0a:	d008      	beq.n	8004b1e <pvPortMalloc+0xa6>
 8004b0c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004b10:	f383 8811 	msr	BASEPRI, r3
 8004b14:	f3bf 8f6f 	isb	sy
 8004b18:	f3bf 8f4f 	dsb	sy
 8004b1c:	e7fe      	b.n	8004b1c <pvPortMalloc+0xa4>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 8004b1e:	6043      	str	r3, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
 8004b20:	606c      	str	r4, [r5, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 8004b22:	f7ff ff7d 	bl	8004a20 <prvInsertBlockIntoFreeList>
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8004b26:	6869      	ldr	r1, [r5, #4]
 8004b28:	4a15      	ldr	r2, [pc, #84]	; (8004b80 <pvPortMalloc+0x108>)
 8004b2a:	f8d2 3c10 	ldr.w	r3, [r2, #3088]	; 0xc10
 8004b2e:	1a5b      	subs	r3, r3, r1
 8004b30:	f8c2 3c10 	str.w	r3, [r2, #3088]	; 0xc10
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8004b34:	f8d2 2c0c 	ldr.w	r2, [r2, #3084]	; 0xc0c
 8004b38:	4293      	cmp	r3, r2
 8004b3a:	d202      	bcs.n	8004b42 <pvPortMalloc+0xca>
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 8004b3c:	4a10      	ldr	r2, [pc, #64]	; (8004b80 <pvPortMalloc+0x108>)
 8004b3e:	f8c2 3c0c 	str.w	r3, [r2, #3084]	; 0xc0c
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 8004b42:	4b0f      	ldr	r3, [pc, #60]	; (8004b80 <pvPortMalloc+0x108>)
 8004b44:	f8d3 3c14 	ldr.w	r3, [r3, #3092]	; 0xc14
 8004b48:	430b      	orrs	r3, r1
 8004b4a:	606b      	str	r3, [r5, #4]
					pxBlock->pxNextFreeBlock = NULL;
 8004b4c:	2300      	movs	r3, #0
 8004b4e:	602b      	str	r3, [r5, #0]
	( void ) xTaskResumeAll();
 8004b50:	f7ff fd04 	bl	800455c <xTaskResumeAll>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 8004b54:	f016 0f07 	tst.w	r6, #7
 8004b58:	d010      	beq.n	8004b7c <pvPortMalloc+0x104>
 8004b5a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004b5e:	f383 8811 	msr	BASEPRI, r3
 8004b62:	f3bf 8f6f 	isb	sy
 8004b66:	f3bf 8f4f 	dsb	sy
 8004b6a:	e7fe      	b.n	8004b6a <pvPortMalloc+0xf2>
void *pvReturn = NULL;
 8004b6c:	2600      	movs	r6, #0
 8004b6e:	e7ef      	b.n	8004b50 <pvPortMalloc+0xd8>
 8004b70:	2600      	movs	r6, #0
 8004b72:	e7ed      	b.n	8004b50 <pvPortMalloc+0xd8>
 8004b74:	2600      	movs	r6, #0
 8004b76:	e7eb      	b.n	8004b50 <pvPortMalloc+0xd8>
 8004b78:	2600      	movs	r6, #0
 8004b7a:	e7e9      	b.n	8004b50 <pvPortMalloc+0xd8>
}
 8004b7c:	4630      	mov	r0, r6
 8004b7e:	bd70      	pop	{r4, r5, r6, pc}
 8004b80:	2000015c 	.word	0x2000015c

08004b84 <vPortFree>:
	if( pv != NULL )
 8004b84:	b398      	cbz	r0, 8004bee <vPortFree+0x6a>
{
 8004b86:	b538      	push	{r3, r4, r5, lr}
 8004b88:	4604      	mov	r4, r0
		puc -= xHeapStructSize;
 8004b8a:	f1a0 0508 	sub.w	r5, r0, #8
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 8004b8e:	f850 2c04 	ldr.w	r2, [r0, #-4]
 8004b92:	4917      	ldr	r1, [pc, #92]	; (8004bf0 <vPortFree+0x6c>)
 8004b94:	f8d1 1c14 	ldr.w	r1, [r1, #3092]	; 0xc14
 8004b98:	420a      	tst	r2, r1
 8004b9a:	d108      	bne.n	8004bae <vPortFree+0x2a>
 8004b9c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004ba0:	f383 8811 	msr	BASEPRI, r3
 8004ba4:	f3bf 8f6f 	isb	sy
 8004ba8:	f3bf 8f4f 	dsb	sy
 8004bac:	e7fe      	b.n	8004bac <vPortFree+0x28>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 8004bae:	f850 0c08 	ldr.w	r0, [r0, #-8]
 8004bb2:	b140      	cbz	r0, 8004bc6 <vPortFree+0x42>
 8004bb4:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004bb8:	f383 8811 	msr	BASEPRI, r3
 8004bbc:	f3bf 8f6f 	isb	sy
 8004bc0:	f3bf 8f4f 	dsb	sy
 8004bc4:	e7fe      	b.n	8004bc4 <vPortFree+0x40>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 8004bc6:	ea22 0201 	bic.w	r2, r2, r1
 8004bca:	f844 2c04 	str.w	r2, [r4, #-4]
				vTaskSuspendAll();
 8004bce:	f7ff fc35 	bl	800443c <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 8004bd2:	f854 1c04 	ldr.w	r1, [r4, #-4]
 8004bd6:	4a06      	ldr	r2, [pc, #24]	; (8004bf0 <vPortFree+0x6c>)
 8004bd8:	f8d2 3c10 	ldr.w	r3, [r2, #3088]	; 0xc10
 8004bdc:	440b      	add	r3, r1
 8004bde:	f8c2 3c10 	str.w	r3, [r2, #3088]	; 0xc10
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8004be2:	4628      	mov	r0, r5
 8004be4:	f7ff ff1c 	bl	8004a20 <prvInsertBlockIntoFreeList>
				( void ) xTaskResumeAll();
 8004be8:	f7ff fcb8 	bl	800455c <xTaskResumeAll>
}
 8004bec:	bd38      	pop	{r3, r4, r5, pc}
 8004bee:	4770      	bx	lr
 8004bf0:	2000015c 	.word	0x2000015c

08004bf4 <vApplicationGetIdleTaskMemory>:
static StaticTask_t xIdleTaskTCBBuffer;
static StackType_t xIdleStack[configMINIMAL_STACK_SIZE];

void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize )
{
  *ppxIdleTaskTCBBuffer = &xIdleTaskTCBBuffer;
 8004bf4:	4b03      	ldr	r3, [pc, #12]	; (8004c04 <vApplicationGetIdleTaskMemory+0x10>)
 8004bf6:	6003      	str	r3, [r0, #0]
  *ppxIdleTaskStackBuffer = &xIdleStack[0];
 8004bf8:	3354      	adds	r3, #84	; 0x54
 8004bfa:	600b      	str	r3, [r1, #0]
  *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
 8004bfc:	2380      	movs	r3, #128	; 0x80
 8004bfe:	6013      	str	r3, [r2, #0]
  /* place for user code */
}
 8004c00:	4770      	bx	lr
 8004c02:	bf00      	nop
 8004c04:	20000d74 	.word	0x20000d74

08004c08 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 8004c08:	b510      	push	{r4, lr}
 8004c0a:	b088      	sub	sp, #32
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8004c0c:	2300      	movs	r3, #0
 8004c0e:	9306      	str	r3, [sp, #24]
 8004c10:	9307      	str	r3, [sp, #28]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8004c12:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8004c16:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
 8004c1a:	699a      	ldr	r2, [r3, #24]
 8004c1c:	f042 0210 	orr.w	r2, r2, #16
 8004c20:	619a      	str	r2, [r3, #24]
 8004c22:	699a      	ldr	r2, [r3, #24]
 8004c24:	f002 0210 	and.w	r2, r2, #16
 8004c28:	9200      	str	r2, [sp, #0]
 8004c2a:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8004c2c:	699a      	ldr	r2, [r3, #24]
 8004c2e:	f042 0220 	orr.w	r2, r2, #32
 8004c32:	619a      	str	r2, [r3, #24]
 8004c34:	699a      	ldr	r2, [r3, #24]
 8004c36:	f002 0220 	and.w	r2, r2, #32
 8004c3a:	9201      	str	r2, [sp, #4]
 8004c3c:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8004c3e:	699a      	ldr	r2, [r3, #24]
 8004c40:	f042 0204 	orr.w	r2, r2, #4
 8004c44:	619a      	str	r2, [r3, #24]
 8004c46:	699a      	ldr	r2, [r3, #24]
 8004c48:	f002 0204 	and.w	r2, r2, #4
 8004c4c:	9202      	str	r2, [sp, #8]
 8004c4e:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8004c50:	699a      	ldr	r2, [r3, #24]
 8004c52:	f042 0208 	orr.w	r2, r2, #8
 8004c56:	619a      	str	r2, [r3, #24]
 8004c58:	699b      	ldr	r3, [r3, #24]
 8004c5a:	f003 0308 	and.w	r3, r3, #8
 8004c5e:	9303      	str	r3, [sp, #12]
 8004c60:	9b03      	ldr	r3, [sp, #12]

  /*Configure GPIO pins : PC13 PC14 PC15 PC0
                           PC1 PC2 PC3 PC4
                           PC5 PC12 */
  GPIO_InitStruct.Pin = GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15|GPIO_PIN_0
 8004c62:	f24f 033f 	movw	r3, #61503	; 0xf03f
 8004c66:	9304      	str	r3, [sp, #16]
                          |GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4
                          |GPIO_PIN_5|GPIO_PIN_12;
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8004c68:	2403      	movs	r4, #3
 8004c6a:	9405      	str	r4, [sp, #20]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8004c6c:	a904      	add	r1, sp, #16
 8004c6e:	480e      	ldr	r0, [pc, #56]	; (8004ca8 <MX_GPIO_Init+0xa0>)
 8004c70:	f7fc fa0c 	bl	800108c <HAL_GPIO_Init>

  /*Configure GPIO pins : PA0 PA4 PA5 PA12 */
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_12;
 8004c74:	f241 0331 	movw	r3, #4145	; 0x1031
 8004c78:	9304      	str	r3, [sp, #16]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8004c7a:	9405      	str	r4, [sp, #20]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8004c7c:	a904      	add	r1, sp, #16
 8004c7e:	480b      	ldr	r0, [pc, #44]	; (8004cac <MX_GPIO_Init+0xa4>)
 8004c80:	f7fc fa04 	bl	800108c <HAL_GPIO_Init>

  /*Configure GPIO pins : PB2 PB12 PB13 PB14
                           PB15 PB4 PB5 */
  GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14
 8004c84:	f24f 0334 	movw	r3, #61492	; 0xf034
 8004c88:	9304      	str	r3, [sp, #16]
                          |GPIO_PIN_15|GPIO_PIN_4|GPIO_PIN_5;
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8004c8a:	9405      	str	r4, [sp, #20]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8004c8c:	a904      	add	r1, sp, #16
 8004c8e:	4808      	ldr	r0, [pc, #32]	; (8004cb0 <MX_GPIO_Init+0xa8>)
 8004c90:	f7fc f9fc 	bl	800108c <HAL_GPIO_Init>

  /*Configure GPIO pin : PD2 */
  GPIO_InitStruct.Pin = GPIO_PIN_2;
 8004c94:	2304      	movs	r3, #4
 8004c96:	9304      	str	r3, [sp, #16]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8004c98:	9405      	str	r4, [sp, #20]
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8004c9a:	a904      	add	r1, sp, #16
 8004c9c:	4805      	ldr	r0, [pc, #20]	; (8004cb4 <MX_GPIO_Init+0xac>)
 8004c9e:	f7fc f9f5 	bl	800108c <HAL_GPIO_Init>

}
 8004ca2:	b008      	add	sp, #32
 8004ca4:	bd10      	pop	{r4, pc}
 8004ca6:	bf00      	nop
 8004ca8:	40011000 	.word	0x40011000
 8004cac:	40010800 	.word	0x40010800
 8004cb0:	40010c00 	.word	0x40010c00
 8004cb4:	40011400 	.word	0x40011400

08004cb8 <MX_DMA_Init>:
{
 8004cb8:	b500      	push	{lr}
 8004cba:	b083      	sub	sp, #12
  __HAL_RCC_DMA2_CLK_ENABLE();
 8004cbc:	4b0e      	ldr	r3, [pc, #56]	; (8004cf8 <MX_DMA_Init+0x40>)
 8004cbe:	695a      	ldr	r2, [r3, #20]
 8004cc0:	f042 0202 	orr.w	r2, r2, #2
 8004cc4:	615a      	str	r2, [r3, #20]
 8004cc6:	695b      	ldr	r3, [r3, #20]
 8004cc8:	f003 0302 	and.w	r3, r3, #2
 8004ccc:	9301      	str	r3, [sp, #4]
 8004cce:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriority(DMA2_Channel3_IRQn, 5, 0);
 8004cd0:	2200      	movs	r2, #0
 8004cd2:	2105      	movs	r1, #5
 8004cd4:	203a      	movs	r0, #58	; 0x3a
 8004cd6:	f7fb fe05 	bl	80008e4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Channel3_IRQn);
 8004cda:	203a      	movs	r0, #58	; 0x3a
 8004cdc:	f7fb fe48 	bl	8000970 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(DMA2_Channel4_5_IRQn, 5, 0);
 8004ce0:	2200      	movs	r2, #0
 8004ce2:	2105      	movs	r1, #5
 8004ce4:	203b      	movs	r0, #59	; 0x3b
 8004ce6:	f7fb fdfd 	bl	80008e4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Channel4_5_IRQn);
 8004cea:	203b      	movs	r0, #59	; 0x3b
 8004cec:	f7fb fe40 	bl	8000970 <HAL_NVIC_EnableIRQ>
}
 8004cf0:	b003      	add	sp, #12
 8004cf2:	f85d fb04 	ldr.w	pc, [sp], #4
 8004cf6:	bf00      	nop
 8004cf8:	40021000 	.word	0x40021000

08004cfc <StartTask02>:
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_StartTask02 */
void StartTask02(void const * argument)
{
 8004cfc:	b508      	push	{r3, lr}
	  {
		  for(int i = 0; i<3; i++)
		  setServoVal(2,i, j);
	  }
	  */
	  osDelay(100);
 8004cfe:	2064      	movs	r0, #100	; 0x64
 8004d00:	f7ff f943 	bl	8003f8a <osDelay>
 8004d04:	e7fb      	b.n	8004cfe <StartTask02+0x2>

08004d06 <StartTask03>:
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_StartTask03 */
void StartTask03(void const * argument)
{
 8004d06:	b508      	push	{r3, lr}
  /* USER CODE BEGIN StartTask03 */
  /* Infinite loop */
  for(;;)
  {

	  osDelay(1);
 8004d08:	2001      	movs	r0, #1
 8004d0a:	f7ff f93e 	bl	8003f8a <osDelay>
 8004d0e:	e7fb      	b.n	8004d08 <StartTask03+0x2>

08004d10 <map>:
{
 8004d10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004d12:	460f      	mov	r7, r1
 8004d14:	4616      	mov	r6, r2
 8004d16:	461c      	mov	r4, r3
	return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
 8004d18:	f7fb fa8e 	bl	8000238 <__aeabi_fsub>
 8004d1c:	4605      	mov	r5, r0
 8004d1e:	4621      	mov	r1, r4
 8004d20:	9806      	ldr	r0, [sp, #24]
 8004d22:	f7fb fa89 	bl	8000238 <__aeabi_fsub>
 8004d26:	4601      	mov	r1, r0
 8004d28:	4628      	mov	r0, r5
 8004d2a:	f7fb fb8f 	bl	800044c <__aeabi_fmul>
 8004d2e:	4605      	mov	r5, r0
 8004d30:	4639      	mov	r1, r7
 8004d32:	4630      	mov	r0, r6
 8004d34:	f7fb fa80 	bl	8000238 <__aeabi_fsub>
 8004d38:	4601      	mov	r1, r0
 8004d3a:	4628      	mov	r0, r5
 8004d3c:	f7fb fc3a 	bl	80005b4 <__aeabi_fdiv>
 8004d40:	4621      	mov	r1, r4
 8004d42:	f7fb fa7b 	bl	800023c <__addsf3>
}
 8004d46:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08004d48 <servoWrite>:
float servoWrite(float value){
 8004d48:	b510      	push	{r4, lr}
 8004d4a:	b082      	sub	sp, #8
 8004d4c:	4604      	mov	r4, r0
	return map(constrain(value,0.0,180.0), 0.0,180.0,SERVO_MIN,SERVO_MAX);
 8004d4e:	2100      	movs	r1, #0
 8004d50:	f7fb fd1a 	bl	8000788 <__aeabi_fcmplt>
 8004d54:	b980      	cbnz	r0, 8004d78 <servoWrite+0x30>
 8004d56:	4909      	ldr	r1, [pc, #36]	; (8004d7c <servoWrite+0x34>)
 8004d58:	4620      	mov	r0, r4
 8004d5a:	f7fb fd33 	bl	80007c4 <__aeabi_fcmpgt>
 8004d5e:	b948      	cbnz	r0, 8004d74 <servoWrite+0x2c>
 8004d60:	4b07      	ldr	r3, [pc, #28]	; (8004d80 <servoWrite+0x38>)
 8004d62:	9300      	str	r3, [sp, #0]
 8004d64:	4b07      	ldr	r3, [pc, #28]	; (8004d84 <servoWrite+0x3c>)
 8004d66:	4a05      	ldr	r2, [pc, #20]	; (8004d7c <servoWrite+0x34>)
 8004d68:	2100      	movs	r1, #0
 8004d6a:	4620      	mov	r0, r4
 8004d6c:	f7ff ffd0 	bl	8004d10 <map>
}
 8004d70:	b002      	add	sp, #8
 8004d72:	bd10      	pop	{r4, pc}
	return map(constrain(value,0.0,180.0), 0.0,180.0,SERVO_MIN,SERVO_MAX);
 8004d74:	4c01      	ldr	r4, [pc, #4]	; (8004d7c <servoWrite+0x34>)
 8004d76:	e7f3      	b.n	8004d60 <servoWrite+0x18>
 8004d78:	2400      	movs	r4, #0
 8004d7a:	e7f1      	b.n	8004d60 <servoWrite+0x18>
 8004d7c:	43340000 	.word	0x43340000
 8004d80:	45048000 	.word	0x45048000
 8004d84:	43eb0000 	.word	0x43eb0000

08004d88 <setServoVal>:
void setServoVal(uint8_t leg,uint8_t num, float val){
 8004d88:	b570      	push	{r4, r5, r6, lr}
 8004d8a:	4605      	mov	r5, r0
 8004d8c:	460e      	mov	r6, r1
 8004d8e:	4614      	mov	r4, r2
	if(val <= 180.0){
 8004d90:	494d      	ldr	r1, [pc, #308]	; (8004ec8 <setServoVal+0x140>)
 8004d92:	4610      	mov	r0, r2
 8004d94:	f7fb fd02 	bl	800079c <__aeabi_fcmple>
 8004d98:	b118      	cbz	r0, 8004da2 <setServoVal+0x1a>
		val = servoWrite(val);
 8004d9a:	4620      	mov	r0, r4
 8004d9c:	f7ff ffd4 	bl	8004d48 <servoWrite>
 8004da0:	4604      	mov	r4, r0
	switch(leg)
 8004da2:	2d05      	cmp	r5, #5
 8004da4:	d809      	bhi.n	8004dba <setServoVal+0x32>
 8004da6:	e8df f005 	tbb	[pc, r5]
 8004daa:	1b03      	.short	0x1b03
 8004dac:	77604932 	.word	0x77604932
		case 0:	switch(num)
 8004db0:	2e01      	cmp	r6, #1
 8004db2:	d009      	beq.n	8004dc8 <setServoVal+0x40>
 8004db4:	b116      	cbz	r6, 8004dbc <setServoVal+0x34>
 8004db6:	2e02      	cmp	r6, #2
 8004db8:	d00c      	beq.n	8004dd4 <setServoVal+0x4c>
}
 8004dba:	bd70      	pop	{r4, r5, r6, pc}
					case 0: TIM3->CCR4=val;	break;	//1_1
 8004dbc:	4620      	mov	r0, r4
 8004dbe:	f7fb fd0b 	bl	80007d8 <__aeabi_f2uiz>
 8004dc2:	4b42      	ldr	r3, [pc, #264]	; (8004ecc <setServoVal+0x144>)
 8004dc4:	6418      	str	r0, [r3, #64]	; 0x40
 8004dc6:	e7f8      	b.n	8004dba <setServoVal+0x32>
					case 1: TIM3->CCR3=val;	break;	//1_2
 8004dc8:	4620      	mov	r0, r4
 8004dca:	f7fb fd05 	bl	80007d8 <__aeabi_f2uiz>
 8004dce:	4b3f      	ldr	r3, [pc, #252]	; (8004ecc <setServoVal+0x144>)
 8004dd0:	63d8      	str	r0, [r3, #60]	; 0x3c
 8004dd2:	e7f2      	b.n	8004dba <setServoVal+0x32>
					case 2: TIM3->CCR2=val;			//1_3
 8004dd4:	4620      	mov	r0, r4
 8004dd6:	f7fb fcff 	bl	80007d8 <__aeabi_f2uiz>
 8004dda:	4b3c      	ldr	r3, [pc, #240]	; (8004ecc <setServoVal+0x144>)
 8004ddc:	6398      	str	r0, [r3, #56]	; 0x38
 8004dde:	e7ec      	b.n	8004dba <setServoVal+0x32>
		case 1:	switch(num)
 8004de0:	2e01      	cmp	r6, #1
 8004de2:	d00e      	beq.n	8004e02 <setServoVal+0x7a>
 8004de4:	b13e      	cbz	r6, 8004df6 <setServoVal+0x6e>
 8004de6:	2e02      	cmp	r6, #2
 8004de8:	d1e7      	bne.n	8004dba <setServoVal+0x32>
					case 2:	TIM5->CCR2=val;			//2_3
 8004dea:	4620      	mov	r0, r4
 8004dec:	f7fb fcf4 	bl	80007d8 <__aeabi_f2uiz>
 8004df0:	4b37      	ldr	r3, [pc, #220]	; (8004ed0 <setServoVal+0x148>)
 8004df2:	6398      	str	r0, [r3, #56]	; 0x38
 8004df4:	e7e1      	b.n	8004dba <setServoVal+0x32>
					case 0: TIM5->CCR4=val;	break;	//2_1
 8004df6:	4620      	mov	r0, r4
 8004df8:	f7fb fcee 	bl	80007d8 <__aeabi_f2uiz>
 8004dfc:	4b34      	ldr	r3, [pc, #208]	; (8004ed0 <setServoVal+0x148>)
 8004dfe:	6418      	str	r0, [r3, #64]	; 0x40
 8004e00:	e7db      	b.n	8004dba <setServoVal+0x32>
					case 1: TIM5->CCR3=val;	break;	//2_2
 8004e02:	4620      	mov	r0, r4
 8004e04:	f7fb fce8 	bl	80007d8 <__aeabi_f2uiz>
 8004e08:	4b31      	ldr	r3, [pc, #196]	; (8004ed0 <setServoVal+0x148>)
 8004e0a:	63d8      	str	r0, [r3, #60]	; 0x3c
 8004e0c:	e7d5      	b.n	8004dba <setServoVal+0x32>
		case 2:	switch(num)
 8004e0e:	2e01      	cmp	r6, #1
 8004e10:	d00e      	beq.n	8004e30 <setServoVal+0xa8>
 8004e12:	b13e      	cbz	r6, 8004e24 <setServoVal+0x9c>
 8004e14:	2e02      	cmp	r6, #2
 8004e16:	d1d0      	bne.n	8004dba <setServoVal+0x32>
					case 2: TIM1->CCR4=val;			//3_3
 8004e18:	4620      	mov	r0, r4
 8004e1a:	f7fb fcdd 	bl	80007d8 <__aeabi_f2uiz>
 8004e1e:	4b2d      	ldr	r3, [pc, #180]	; (8004ed4 <setServoVal+0x14c>)
 8004e20:	6418      	str	r0, [r3, #64]	; 0x40
 8004e22:	e7ca      	b.n	8004dba <setServoVal+0x32>
					case 0: TIM4->CCR1=val;	break;	//3_1
 8004e24:	4620      	mov	r0, r4
 8004e26:	f7fb fcd7 	bl	80007d8 <__aeabi_f2uiz>
 8004e2a:	4b2b      	ldr	r3, [pc, #172]	; (8004ed8 <setServoVal+0x150>)
 8004e2c:	6358      	str	r0, [r3, #52]	; 0x34
 8004e2e:	e7c4      	b.n	8004dba <setServoVal+0x32>
					case 1: TIM3->CCR1=val;	break;	//3_2
 8004e30:	4620      	mov	r0, r4
 8004e32:	f7fb fcd1 	bl	80007d8 <__aeabi_f2uiz>
 8004e36:	4b25      	ldr	r3, [pc, #148]	; (8004ecc <setServoVal+0x144>)
 8004e38:	6358      	str	r0, [r3, #52]	; 0x34
 8004e3a:	e7be      	b.n	8004dba <setServoVal+0x32>
		case 3:	switch(num)
 8004e3c:	2e01      	cmp	r6, #1
 8004e3e:	d00e      	beq.n	8004e5e <setServoVal+0xd6>
 8004e40:	b13e      	cbz	r6, 8004e52 <setServoVal+0xca>
 8004e42:	2e02      	cmp	r6, #2
 8004e44:	d1b9      	bne.n	8004dba <setServoVal+0x32>
					case 2: TIM4->CCR2=val;			//4_3
 8004e46:	4620      	mov	r0, r4
 8004e48:	f7fb fcc6 	bl	80007d8 <__aeabi_f2uiz>
 8004e4c:	4b22      	ldr	r3, [pc, #136]	; (8004ed8 <setServoVal+0x150>)
 8004e4e:	6398      	str	r0, [r3, #56]	; 0x38
 8004e50:	e7b3      	b.n	8004dba <setServoVal+0x32>
					case 0: TIM4->CCR4=val;	break;	//4_1
 8004e52:	4620      	mov	r0, r4
 8004e54:	f7fb fcc0 	bl	80007d8 <__aeabi_f2uiz>
 8004e58:	4b1f      	ldr	r3, [pc, #124]	; (8004ed8 <setServoVal+0x150>)
 8004e5a:	6418      	str	r0, [r3, #64]	; 0x40
 8004e5c:	e7ad      	b.n	8004dba <setServoVal+0x32>
					case 1: TIM4->CCR3=val;	break;	//4_2
 8004e5e:	4620      	mov	r0, r4
 8004e60:	f7fb fcba 	bl	80007d8 <__aeabi_f2uiz>
 8004e64:	4b1c      	ldr	r3, [pc, #112]	; (8004ed8 <setServoVal+0x150>)
 8004e66:	63d8      	str	r0, [r3, #60]	; 0x3c
 8004e68:	e7a7      	b.n	8004dba <setServoVal+0x32>
		case 4:	switch(num)
 8004e6a:	2e01      	cmp	r6, #1
 8004e6c:	d00e      	beq.n	8004e8c <setServoVal+0x104>
 8004e6e:	b13e      	cbz	r6, 8004e80 <setServoVal+0xf8>
 8004e70:	2e02      	cmp	r6, #2
 8004e72:	d1a2      	bne.n	8004dba <setServoVal+0x32>
					case 2: TIM1->CCR3=val; 		//5_3
 8004e74:	4620      	mov	r0, r4
 8004e76:	f7fb fcaf 	bl	80007d8 <__aeabi_f2uiz>
 8004e7a:	4b16      	ldr	r3, [pc, #88]	; (8004ed4 <setServoVal+0x14c>)
 8004e7c:	63d8      	str	r0, [r3, #60]	; 0x3c
 8004e7e:	e79c      	b.n	8004dba <setServoVal+0x32>
					case 0: TIM1->CCR1=val; break;	//5_1
 8004e80:	4620      	mov	r0, r4
 8004e82:	f7fb fca9 	bl	80007d8 <__aeabi_f2uiz>
 8004e86:	4b13      	ldr	r3, [pc, #76]	; (8004ed4 <setServoVal+0x14c>)
 8004e88:	6358      	str	r0, [r3, #52]	; 0x34
 8004e8a:	e796      	b.n	8004dba <setServoVal+0x32>
					case 1: TIM1->CCR2=val; break;	//5_2
 8004e8c:	4620      	mov	r0, r4
 8004e8e:	f7fb fca3 	bl	80007d8 <__aeabi_f2uiz>
 8004e92:	4b10      	ldr	r3, [pc, #64]	; (8004ed4 <setServoVal+0x14c>)
 8004e94:	6398      	str	r0, [r3, #56]	; 0x38
 8004e96:	e790      	b.n	8004dba <setServoVal+0x32>
		case 5:	switch(num)
 8004e98:	2e01      	cmp	r6, #1
 8004e9a:	d00e      	beq.n	8004eba <setServoVal+0x132>
 8004e9c:	b13e      	cbz	r6, 8004eae <setServoVal+0x126>
 8004e9e:	2e02      	cmp	r6, #2
 8004ea0:	d18b      	bne.n	8004dba <setServoVal+0x32>
					case 2: TIM8->CCR3=val; 		//6_3
 8004ea2:	4620      	mov	r0, r4
 8004ea4:	f7fb fc98 	bl	80007d8 <__aeabi_f2uiz>
 8004ea8:	4b0c      	ldr	r3, [pc, #48]	; (8004edc <setServoVal+0x154>)
 8004eaa:	63d8      	str	r0, [r3, #60]	; 0x3c
}
 8004eac:	e785      	b.n	8004dba <setServoVal+0x32>
					case 0: TIM8->CCR1=val; break;	//6_1
 8004eae:	4620      	mov	r0, r4
 8004eb0:	f7fb fc92 	bl	80007d8 <__aeabi_f2uiz>
 8004eb4:	4b09      	ldr	r3, [pc, #36]	; (8004edc <setServoVal+0x154>)
 8004eb6:	6358      	str	r0, [r3, #52]	; 0x34
 8004eb8:	e77f      	b.n	8004dba <setServoVal+0x32>
					case 1: TIM8->CCR2=val; break;	//6_2
 8004eba:	4620      	mov	r0, r4
 8004ebc:	f7fb fc8c 	bl	80007d8 <__aeabi_f2uiz>
 8004ec0:	4b06      	ldr	r3, [pc, #24]	; (8004edc <setServoVal+0x154>)
 8004ec2:	6398      	str	r0, [r3, #56]	; 0x38
 8004ec4:	e779      	b.n	8004dba <setServoVal+0x32>
 8004ec6:	bf00      	nop
 8004ec8:	43340000 	.word	0x43340000
 8004ecc:	40000400 	.word	0x40000400
 8004ed0:	40000c00 	.word	0x40000c00
 8004ed4:	40012c00 	.word	0x40012c00
 8004ed8:	40000800 	.word	0x40000800
 8004edc:	40013400 	.word	0x40013400

08004ee0 <StartDefaultTask>:
{
 8004ee0:	b580      	push	{r7, lr}
 8004ee2:	b082      	sub	sp, #8
 8004ee4:	e002      	b.n	8004eec <StartDefaultTask+0xc>
	  osDelay(1);
 8004ee6:	2001      	movs	r0, #1
 8004ee8:	f7ff f84f 	bl	8003f8a <osDelay>
	  if(hdma_uart4_rx.State == HAL_DMA_STATE_READY){
 8004eec:	4b1d      	ldr	r3, [pc, #116]	; (8004f64 <StartDefaultTask+0x84>)
 8004eee:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 8004ef2:	2b01      	cmp	r3, #1
 8004ef4:	d1f7      	bne.n	8004ee6 <StartDefaultTask+0x6>
		  HAL_UART_Receive_DMA(&huart4, rx_uart_buf,4);
 8004ef6:	4c1c      	ldr	r4, [pc, #112]	; (8004f68 <StartDefaultTask+0x88>)
 8004ef8:	4d1c      	ldr	r5, [pc, #112]	; (8004f6c <StartDefaultTask+0x8c>)
 8004efa:	2204      	movs	r2, #4
 8004efc:	4621      	mov	r1, r4
 8004efe:	4628      	mov	r0, r5
 8004f00:	f7fe fe4a 	bl	8003b98 <HAL_UART_Receive_DMA>
		  setServoVal(3,1, map(rx_uart_buf[2],-90,90,SERVO_MIN,SERVO_MAX));
 8004f04:	f8df 8070 	ldr.w	r8, [pc, #112]	; 8004f78 <StartDefaultTask+0x98>
 8004f08:	4f19      	ldr	r7, [pc, #100]	; (8004f70 <StartDefaultTask+0x90>)
 8004f0a:	4e1a      	ldr	r6, [pc, #104]	; (8004f74 <StartDefaultTask+0x94>)
 8004f0c:	f994 0002 	ldrsb.w	r0, [r4, #2]
 8004f10:	f7fb fa48 	bl	80003a4 <__aeabi_i2f>
 8004f14:	f8df 9064 	ldr.w	r9, [pc, #100]	; 8004f7c <StartDefaultTask+0x9c>
 8004f18:	f8cd 9000 	str.w	r9, [sp]
 8004f1c:	4643      	mov	r3, r8
 8004f1e:	463a      	mov	r2, r7
 8004f20:	4631      	mov	r1, r6
 8004f22:	f7ff fef5 	bl	8004d10 <map>
 8004f26:	4602      	mov	r2, r0
 8004f28:	2101      	movs	r1, #1
 8004f2a:	2003      	movs	r0, #3
 8004f2c:	f7ff ff2c 	bl	8004d88 <setServoVal>
		  setServoVal(3,2, map(rx_uart_buf[3],-90,90,SERVO_MIN,SERVO_MAX));
 8004f30:	f994 0003 	ldrsb.w	r0, [r4, #3]
 8004f34:	f7fb fa36 	bl	80003a4 <__aeabi_i2f>
 8004f38:	f8cd 9000 	str.w	r9, [sp]
 8004f3c:	4643      	mov	r3, r8
 8004f3e:	463a      	mov	r2, r7
 8004f40:	4631      	mov	r1, r6
 8004f42:	f7ff fee5 	bl	8004d10 <map>
 8004f46:	4602      	mov	r2, r0
 8004f48:	2102      	movs	r1, #2
 8004f4a:	2003      	movs	r0, #3
 8004f4c:	f7ff ff1c 	bl	8004d88 <setServoVal>
		  HAL_UART_Transmit_DMA(&huart4, rx_uart_buf,4);
 8004f50:	2204      	movs	r2, #4
 8004f52:	4621      	mov	r1, r4
 8004f54:	4628      	mov	r0, r5
 8004f56:	f7fe fdd9 	bl	8003b0c <HAL_UART_Transmit_DMA>
		  hdma_uart4_rx.State = HAL_DMA_STATE_BUSY;
 8004f5a:	4b02      	ldr	r3, [pc, #8]	; (8004f64 <StartDefaultTask+0x84>)
 8004f5c:	2202      	movs	r2, #2
 8004f5e:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
 8004f62:	e7c0      	b.n	8004ee6 <StartDefaultTask+0x6>
 8004f64:	20000fcc 	.word	0x20000fcc
 8004f68:	20001198 	.word	0x20001198
 8004f6c:	20001208 	.word	0x20001208
 8004f70:	42b40000 	.word	0x42b40000
 8004f74:	c2b40000 	.word	0xc2b40000
 8004f78:	43eb0000 	.word	0x43eb0000
 8004f7c:	45048000 	.word	0x45048000

08004f80 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 8004f80:	e7fe      	b.n	8004f80 <Error_Handler>
	...

08004f84 <MX_I2C2_Init>:
{
 8004f84:	b508      	push	{r3, lr}
  hi2c2.Instance = I2C2;
 8004f86:	480a      	ldr	r0, [pc, #40]	; (8004fb0 <MX_I2C2_Init+0x2c>)
 8004f88:	4b0a      	ldr	r3, [pc, #40]	; (8004fb4 <MX_I2C2_Init+0x30>)
 8004f8a:	6003      	str	r3, [r0, #0]
  hi2c2.Init.ClockSpeed = 100000;
 8004f8c:	4b0a      	ldr	r3, [pc, #40]	; (8004fb8 <MX_I2C2_Init+0x34>)
 8004f8e:	6043      	str	r3, [r0, #4]
  hi2c2.Init.DutyCycle = I2C_DUTYCYCLE_2;
 8004f90:	2300      	movs	r3, #0
 8004f92:	6083      	str	r3, [r0, #8]
  hi2c2.Init.OwnAddress1 = 0;
 8004f94:	60c3      	str	r3, [r0, #12]
  hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8004f96:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8004f9a:	6102      	str	r2, [r0, #16]
  hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 8004f9c:	6143      	str	r3, [r0, #20]
  hi2c2.Init.OwnAddress2 = 0;
 8004f9e:	6183      	str	r3, [r0, #24]
  hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 8004fa0:	61c3      	str	r3, [r0, #28]
  hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 8004fa2:	6203      	str	r3, [r0, #32]
  if (HAL_I2C_Init(&hi2c2) != HAL_OK)
 8004fa4:	f7fc fbe8 	bl	8001778 <HAL_I2C_Init>
 8004fa8:	b900      	cbnz	r0, 8004fac <MX_I2C2_Init+0x28>
}
 8004faa:	bd08      	pop	{r3, pc}
    Error_Handler();
 8004fac:	f7ff ffe8 	bl	8004f80 <Error_Handler>
 8004fb0:	200010b4 	.word	0x200010b4
 8004fb4:	40005800 	.word	0x40005800
 8004fb8:	000186a0 	.word	0x000186a0

08004fbc <MX_TIM1_Init>:
{
 8004fbc:	b510      	push	{r4, lr}
 8004fbe:	b092      	sub	sp, #72	; 0x48
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8004fc0:	2400      	movs	r4, #0
 8004fc2:	9410      	str	r4, [sp, #64]	; 0x40
 8004fc4:	9411      	str	r4, [sp, #68]	; 0x44
  TIM_OC_InitTypeDef sConfigOC = {0};
 8004fc6:	9409      	str	r4, [sp, #36]	; 0x24
 8004fc8:	940a      	str	r4, [sp, #40]	; 0x28
 8004fca:	940b      	str	r4, [sp, #44]	; 0x2c
 8004fcc:	940c      	str	r4, [sp, #48]	; 0x30
 8004fce:	940d      	str	r4, [sp, #52]	; 0x34
 8004fd0:	940e      	str	r4, [sp, #56]	; 0x38
 8004fd2:	940f      	str	r4, [sp, #60]	; 0x3c
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};
 8004fd4:	2220      	movs	r2, #32
 8004fd6:	4621      	mov	r1, r4
 8004fd8:	a801      	add	r0, sp, #4
 8004fda:	f000 fe53 	bl	8005c84 <memset>
  htim1.Instance = TIM1;
 8004fde:	482e      	ldr	r0, [pc, #184]	; (8005098 <MX_TIM1_Init+0xdc>)
 8004fe0:	4b2e      	ldr	r3, [pc, #184]	; (800509c <MX_TIM1_Init+0xe0>)
 8004fe2:	6003      	str	r3, [r0, #0]
  htim1.Init.Prescaler = 17;
 8004fe4:	2311      	movs	r3, #17
 8004fe6:	6043      	str	r3, [r0, #4]
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
 8004fe8:	6084      	str	r4, [r0, #8]
  htim1.Init.Period = 19999;
 8004fea:	f644 631f 	movw	r3, #19999	; 0x4e1f
 8004fee:	60c3      	str	r3, [r0, #12]
  htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8004ff0:	6104      	str	r4, [r0, #16]
  htim1.Init.RepetitionCounter = 0;
 8004ff2:	6144      	str	r4, [r0, #20]
  htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
 8004ff4:	2380      	movs	r3, #128	; 0x80
 8004ff6:	6183      	str	r3, [r0, #24]
  if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)
 8004ff8:	f7fe f860 	bl	80030bc <HAL_TIM_PWM_Init>
 8004ffc:	2800      	cmp	r0, #0
 8004ffe:	d13d      	bne.n	800507c <MX_TIM1_Init+0xc0>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8005000:	2300      	movs	r3, #0
 8005002:	9310      	str	r3, [sp, #64]	; 0x40
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8005004:	9311      	str	r3, [sp, #68]	; 0x44
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 8005006:	a910      	add	r1, sp, #64	; 0x40
 8005008:	4823      	ldr	r0, [pc, #140]	; (8005098 <MX_TIM1_Init+0xdc>)
 800500a:	f7fe fb29 	bl	8003660 <HAL_TIMEx_MasterConfigSynchronization>
 800500e:	2800      	cmp	r0, #0
 8005010:	d136      	bne.n	8005080 <MX_TIM1_Init+0xc4>
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 8005012:	2360      	movs	r3, #96	; 0x60
 8005014:	9309      	str	r3, [sp, #36]	; 0x24
  sConfigOC.Pulse = 0;
 8005016:	2200      	movs	r2, #0
 8005018:	920a      	str	r2, [sp, #40]	; 0x28
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 800501a:	920b      	str	r2, [sp, #44]	; 0x2c
  sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
 800501c:	920c      	str	r2, [sp, #48]	; 0x30
  sConfigOC.OCFastMode = TIM_OCFAST_ENABLE;
 800501e:	2304      	movs	r3, #4
 8005020:	930d      	str	r3, [sp, #52]	; 0x34
  sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
 8005022:	920e      	str	r2, [sp, #56]	; 0x38
  sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
 8005024:	920f      	str	r2, [sp, #60]	; 0x3c
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8005026:	a909      	add	r1, sp, #36	; 0x24
 8005028:	481b      	ldr	r0, [pc, #108]	; (8005098 <MX_TIM1_Init+0xdc>)
 800502a:	f7fe f925 	bl	8003278 <HAL_TIM_PWM_ConfigChannel>
 800502e:	bb48      	cbnz	r0, 8005084 <MX_TIM1_Init+0xc8>
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 8005030:	2204      	movs	r2, #4
 8005032:	a909      	add	r1, sp, #36	; 0x24
 8005034:	4818      	ldr	r0, [pc, #96]	; (8005098 <MX_TIM1_Init+0xdc>)
 8005036:	f7fe f91f 	bl	8003278 <HAL_TIM_PWM_ConfigChannel>
 800503a:	bb28      	cbnz	r0, 8005088 <MX_TIM1_Init+0xcc>
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
 800503c:	2208      	movs	r2, #8
 800503e:	a909      	add	r1, sp, #36	; 0x24
 8005040:	4815      	ldr	r0, [pc, #84]	; (8005098 <MX_TIM1_Init+0xdc>)
 8005042:	f7fe f919 	bl	8003278 <HAL_TIM_PWM_ConfigChannel>
 8005046:	bb08      	cbnz	r0, 800508c <MX_TIM1_Init+0xd0>
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
 8005048:	220c      	movs	r2, #12
 800504a:	a909      	add	r1, sp, #36	; 0x24
 800504c:	4812      	ldr	r0, [pc, #72]	; (8005098 <MX_TIM1_Init+0xdc>)
 800504e:	f7fe f913 	bl	8003278 <HAL_TIM_PWM_ConfigChannel>
 8005052:	b9e8      	cbnz	r0, 8005090 <MX_TIM1_Init+0xd4>
  sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
 8005054:	2300      	movs	r3, #0
 8005056:	9301      	str	r3, [sp, #4]
  sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
 8005058:	9302      	str	r3, [sp, #8]
  sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
 800505a:	9303      	str	r3, [sp, #12]
  sBreakDeadTimeConfig.DeadTime = 0;
 800505c:	9304      	str	r3, [sp, #16]
  sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
 800505e:	9305      	str	r3, [sp, #20]
  sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
 8005060:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8005064:	9206      	str	r2, [sp, #24]
  sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
 8005066:	9308      	str	r3, [sp, #32]
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
 8005068:	a901      	add	r1, sp, #4
 800506a:	480b      	ldr	r0, [pc, #44]	; (8005098 <MX_TIM1_Init+0xdc>)
 800506c:	f7fe fb7c 	bl	8003768 <HAL_TIMEx_ConfigBreakDeadTime>
 8005070:	b980      	cbnz	r0, 8005094 <MX_TIM1_Init+0xd8>
  HAL_TIM_MspPostInit(&htim1);
 8005072:	4809      	ldr	r0, [pc, #36]	; (8005098 <MX_TIM1_Init+0xdc>)
 8005074:	f000 fc02 	bl	800587c <HAL_TIM_MspPostInit>
}
 8005078:	b012      	add	sp, #72	; 0x48
 800507a:	bd10      	pop	{r4, pc}
    Error_Handler();
 800507c:	f7ff ff80 	bl	8004f80 <Error_Handler>
    Error_Handler();
 8005080:	f7ff ff7e 	bl	8004f80 <Error_Handler>
    Error_Handler();
 8005084:	f7ff ff7c 	bl	8004f80 <Error_Handler>
    Error_Handler();
 8005088:	f7ff ff7a 	bl	8004f80 <Error_Handler>
    Error_Handler();
 800508c:	f7ff ff78 	bl	8004f80 <Error_Handler>
    Error_Handler();
 8005090:	f7ff ff76 	bl	8004f80 <Error_Handler>
    Error_Handler();
 8005094:	f7ff ff74 	bl	8004f80 <Error_Handler>
 8005098:	200011bc 	.word	0x200011bc
 800509c:	40012c00 	.word	0x40012c00

080050a0 <MX_TIM2_Init>:
{
 80050a0:	b500      	push	{lr}
 80050a2:	b08b      	sub	sp, #44	; 0x2c
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 80050a4:	2300      	movs	r3, #0
 80050a6:	9308      	str	r3, [sp, #32]
 80050a8:	9309      	str	r3, [sp, #36]	; 0x24
  TIM_OC_InitTypeDef sConfigOC = {0};
 80050aa:	9301      	str	r3, [sp, #4]
 80050ac:	9302      	str	r3, [sp, #8]
 80050ae:	9303      	str	r3, [sp, #12]
 80050b0:	9304      	str	r3, [sp, #16]
 80050b2:	9305      	str	r3, [sp, #20]
 80050b4:	9306      	str	r3, [sp, #24]
 80050b6:	9307      	str	r3, [sp, #28]
  htim2.Instance = TIM2;
 80050b8:	481c      	ldr	r0, [pc, #112]	; (800512c <MX_TIM2_Init+0x8c>)
 80050ba:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 80050be:	6002      	str	r2, [r0, #0]
  htim2.Init.Prescaler = 0;
 80050c0:	6043      	str	r3, [r0, #4]
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 80050c2:	6083      	str	r3, [r0, #8]
  htim2.Init.Period = 65535;
 80050c4:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80050c8:	60c2      	str	r2, [r0, #12]
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 80050ca:	6103      	str	r3, [r0, #16]
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
 80050cc:	2380      	movs	r3, #128	; 0x80
 80050ce:	6183      	str	r3, [r0, #24]
  if (HAL_TIM_PWM_Init(&htim2) != HAL_OK)
 80050d0:	f7fd fff4 	bl	80030bc <HAL_TIM_PWM_Init>
 80050d4:	bb08      	cbnz	r0, 800511a <MX_TIM2_Init+0x7a>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 80050d6:	2300      	movs	r3, #0
 80050d8:	9308      	str	r3, [sp, #32]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 80050da:	9309      	str	r3, [sp, #36]	; 0x24
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 80050dc:	a908      	add	r1, sp, #32
 80050de:	4813      	ldr	r0, [pc, #76]	; (800512c <MX_TIM2_Init+0x8c>)
 80050e0:	f7fe fabe 	bl	8003660 <HAL_TIMEx_MasterConfigSynchronization>
 80050e4:	b9d8      	cbnz	r0, 800511e <MX_TIM2_Init+0x7e>
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 80050e6:	2360      	movs	r3, #96	; 0x60
 80050e8:	9301      	str	r3, [sp, #4]
  sConfigOC.Pulse = 0;
 80050ea:	2200      	movs	r2, #0
 80050ec:	9202      	str	r2, [sp, #8]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 80050ee:	9203      	str	r2, [sp, #12]
  sConfigOC.OCFastMode = TIM_OCFAST_ENABLE;
 80050f0:	2304      	movs	r3, #4
 80050f2:	9305      	str	r3, [sp, #20]
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 80050f4:	eb0d 0103 	add.w	r1, sp, r3
 80050f8:	480c      	ldr	r0, [pc, #48]	; (800512c <MX_TIM2_Init+0x8c>)
 80050fa:	f7fe f8bd 	bl	8003278 <HAL_TIM_PWM_ConfigChannel>
 80050fe:	b980      	cbnz	r0, 8005122 <MX_TIM2_Init+0x82>
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 8005100:	2204      	movs	r2, #4
 8005102:	eb0d 0102 	add.w	r1, sp, r2
 8005106:	4809      	ldr	r0, [pc, #36]	; (800512c <MX_TIM2_Init+0x8c>)
 8005108:	f7fe f8b6 	bl	8003278 <HAL_TIM_PWM_ConfigChannel>
 800510c:	b958      	cbnz	r0, 8005126 <MX_TIM2_Init+0x86>
  HAL_TIM_MspPostInit(&htim2);
 800510e:	4807      	ldr	r0, [pc, #28]	; (800512c <MX_TIM2_Init+0x8c>)
 8005110:	f000 fbb4 	bl	800587c <HAL_TIM_MspPostInit>
}
 8005114:	b00b      	add	sp, #44	; 0x2c
 8005116:	f85d fb04 	ldr.w	pc, [sp], #4
    Error_Handler();
 800511a:	f7ff ff31 	bl	8004f80 <Error_Handler>
    Error_Handler();
 800511e:	f7ff ff2f 	bl	8004f80 <Error_Handler>
    Error_Handler();
 8005122:	f7ff ff2d 	bl	8004f80 <Error_Handler>
    Error_Handler();
 8005126:	f7ff ff2b 	bl	8004f80 <Error_Handler>
 800512a:	bf00      	nop
 800512c:	20001248 	.word	0x20001248

08005130 <MX_TIM3_Init>:
{
 8005130:	b500      	push	{lr}
 8005132:	b08b      	sub	sp, #44	; 0x2c
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8005134:	2300      	movs	r3, #0
 8005136:	9308      	str	r3, [sp, #32]
 8005138:	9309      	str	r3, [sp, #36]	; 0x24
  TIM_OC_InitTypeDef sConfigOC = {0};
 800513a:	9301      	str	r3, [sp, #4]
 800513c:	9302      	str	r3, [sp, #8]
 800513e:	9303      	str	r3, [sp, #12]
 8005140:	9304      	str	r3, [sp, #16]
 8005142:	9305      	str	r3, [sp, #20]
 8005144:	9306      	str	r3, [sp, #24]
 8005146:	9307      	str	r3, [sp, #28]
  htim3.Instance = TIM3;
 8005148:	4824      	ldr	r0, [pc, #144]	; (80051dc <MX_TIM3_Init+0xac>)
 800514a:	4a25      	ldr	r2, [pc, #148]	; (80051e0 <MX_TIM3_Init+0xb0>)
 800514c:	6002      	str	r2, [r0, #0]
  htim3.Init.Prescaler = 8;
 800514e:	2208      	movs	r2, #8
 8005150:	6042      	str	r2, [r0, #4]
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
 8005152:	6083      	str	r3, [r0, #8]
  htim3.Init.Period = 19999;
 8005154:	f644 621f 	movw	r2, #19999	; 0x4e1f
 8005158:	60c2      	str	r2, [r0, #12]
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 800515a:	6103      	str	r3, [r0, #16]
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
 800515c:	2380      	movs	r3, #128	; 0x80
 800515e:	6183      	str	r3, [r0, #24]
  if (HAL_TIM_PWM_Init(&htim3) != HAL_OK)
 8005160:	f7fd ffac 	bl	80030bc <HAL_TIM_PWM_Init>
 8005164:	bb68      	cbnz	r0, 80051c2 <MX_TIM3_Init+0x92>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8005166:	2300      	movs	r3, #0
 8005168:	9308      	str	r3, [sp, #32]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 800516a:	9309      	str	r3, [sp, #36]	; 0x24
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 800516c:	a908      	add	r1, sp, #32
 800516e:	481b      	ldr	r0, [pc, #108]	; (80051dc <MX_TIM3_Init+0xac>)
 8005170:	f7fe fa76 	bl	8003660 <HAL_TIMEx_MasterConfigSynchronization>
 8005174:	bb38      	cbnz	r0, 80051c6 <MX_TIM3_Init+0x96>
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 8005176:	2360      	movs	r3, #96	; 0x60
 8005178:	9301      	str	r3, [sp, #4]
  sConfigOC.Pulse = 0;
 800517a:	2200      	movs	r2, #0
 800517c:	9202      	str	r2, [sp, #8]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 800517e:	9203      	str	r2, [sp, #12]
  sConfigOC.OCFastMode = TIM_OCFAST_ENABLE;
 8005180:	2304      	movs	r3, #4
 8005182:	9305      	str	r3, [sp, #20]
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8005184:	eb0d 0103 	add.w	r1, sp, r3
 8005188:	4814      	ldr	r0, [pc, #80]	; (80051dc <MX_TIM3_Init+0xac>)
 800518a:	f7fe f875 	bl	8003278 <HAL_TIM_PWM_ConfigChannel>
 800518e:	b9e0      	cbnz	r0, 80051ca <MX_TIM3_Init+0x9a>
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 8005190:	2204      	movs	r2, #4
 8005192:	eb0d 0102 	add.w	r1, sp, r2
 8005196:	4811      	ldr	r0, [pc, #68]	; (80051dc <MX_TIM3_Init+0xac>)
 8005198:	f7fe f86e 	bl	8003278 <HAL_TIM_PWM_ConfigChannel>
 800519c:	b9b8      	cbnz	r0, 80051ce <MX_TIM3_Init+0x9e>
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
 800519e:	2208      	movs	r2, #8
 80051a0:	a901      	add	r1, sp, #4
 80051a2:	480e      	ldr	r0, [pc, #56]	; (80051dc <MX_TIM3_Init+0xac>)
 80051a4:	f7fe f868 	bl	8003278 <HAL_TIM_PWM_ConfigChannel>
 80051a8:	b998      	cbnz	r0, 80051d2 <MX_TIM3_Init+0xa2>
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
 80051aa:	220c      	movs	r2, #12
 80051ac:	a901      	add	r1, sp, #4
 80051ae:	480b      	ldr	r0, [pc, #44]	; (80051dc <MX_TIM3_Init+0xac>)
 80051b0:	f7fe f862 	bl	8003278 <HAL_TIM_PWM_ConfigChannel>
 80051b4:	b978      	cbnz	r0, 80051d6 <MX_TIM3_Init+0xa6>
  HAL_TIM_MspPostInit(&htim3);
 80051b6:	4809      	ldr	r0, [pc, #36]	; (80051dc <MX_TIM3_Init+0xac>)
 80051b8:	f000 fb60 	bl	800587c <HAL_TIM_MspPostInit>
}
 80051bc:	b00b      	add	sp, #44	; 0x2c
 80051be:	f85d fb04 	ldr.w	pc, [sp], #4
    Error_Handler();
 80051c2:	f7ff fedd 	bl	8004f80 <Error_Handler>
    Error_Handler();
 80051c6:	f7ff fedb 	bl	8004f80 <Error_Handler>
    Error_Handler();
 80051ca:	f7ff fed9 	bl	8004f80 <Error_Handler>
    Error_Handler();
 80051ce:	f7ff fed7 	bl	8004f80 <Error_Handler>
    Error_Handler();
 80051d2:	f7ff fed5 	bl	8004f80 <Error_Handler>
    Error_Handler();
 80051d6:	f7ff fed3 	bl	8004f80 <Error_Handler>
 80051da:	bf00      	nop
 80051dc:	20001150 	.word	0x20001150
 80051e0:	40000400 	.word	0x40000400

080051e4 <MX_TIM4_Init>:
{
 80051e4:	b500      	push	{lr}
 80051e6:	b08b      	sub	sp, #44	; 0x2c
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 80051e8:	2300      	movs	r3, #0
 80051ea:	9308      	str	r3, [sp, #32]
 80051ec:	9309      	str	r3, [sp, #36]	; 0x24
  TIM_OC_InitTypeDef sConfigOC = {0};
 80051ee:	9301      	str	r3, [sp, #4]
 80051f0:	9302      	str	r3, [sp, #8]
 80051f2:	9303      	str	r3, [sp, #12]
 80051f4:	9304      	str	r3, [sp, #16]
 80051f6:	9305      	str	r3, [sp, #20]
 80051f8:	9306      	str	r3, [sp, #24]
 80051fa:	9307      	str	r3, [sp, #28]
  htim4.Instance = TIM4;
 80051fc:	4824      	ldr	r0, [pc, #144]	; (8005290 <MX_TIM4_Init+0xac>)
 80051fe:	4a25      	ldr	r2, [pc, #148]	; (8005294 <MX_TIM4_Init+0xb0>)
 8005200:	6002      	str	r2, [r0, #0]
  htim4.Init.Prescaler = 8;
 8005202:	2208      	movs	r2, #8
 8005204:	6042      	str	r2, [r0, #4]
  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
 8005206:	6083      	str	r3, [r0, #8]
  htim4.Init.Period = 19999;
 8005208:	f644 621f 	movw	r2, #19999	; 0x4e1f
 800520c:	60c2      	str	r2, [r0, #12]
  htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 800520e:	6103      	str	r3, [r0, #16]
  htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
 8005210:	2380      	movs	r3, #128	; 0x80
 8005212:	6183      	str	r3, [r0, #24]
  if (HAL_TIM_PWM_Init(&htim4) != HAL_OK)
 8005214:	f7fd ff52 	bl	80030bc <HAL_TIM_PWM_Init>
 8005218:	bb68      	cbnz	r0, 8005276 <MX_TIM4_Init+0x92>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 800521a:	2300      	movs	r3, #0
 800521c:	9308      	str	r3, [sp, #32]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 800521e:	9309      	str	r3, [sp, #36]	; 0x24
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
 8005220:	a908      	add	r1, sp, #32
 8005222:	481b      	ldr	r0, [pc, #108]	; (8005290 <MX_TIM4_Init+0xac>)
 8005224:	f7fe fa1c 	bl	8003660 <HAL_TIMEx_MasterConfigSynchronization>
 8005228:	bb38      	cbnz	r0, 800527a <MX_TIM4_Init+0x96>
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 800522a:	2360      	movs	r3, #96	; 0x60
 800522c:	9301      	str	r3, [sp, #4]
  sConfigOC.Pulse = 0;
 800522e:	2200      	movs	r2, #0
 8005230:	9202      	str	r2, [sp, #8]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 8005232:	9203      	str	r2, [sp, #12]
  sConfigOC.OCFastMode = TIM_OCFAST_ENABLE;
 8005234:	2304      	movs	r3, #4
 8005236:	9305      	str	r3, [sp, #20]
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8005238:	eb0d 0103 	add.w	r1, sp, r3
 800523c:	4814      	ldr	r0, [pc, #80]	; (8005290 <MX_TIM4_Init+0xac>)
 800523e:	f7fe f81b 	bl	8003278 <HAL_TIM_PWM_ConfigChannel>
 8005242:	b9e0      	cbnz	r0, 800527e <MX_TIM4_Init+0x9a>
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 8005244:	2204      	movs	r2, #4
 8005246:	eb0d 0102 	add.w	r1, sp, r2
 800524a:	4811      	ldr	r0, [pc, #68]	; (8005290 <MX_TIM4_Init+0xac>)
 800524c:	f7fe f814 	bl	8003278 <HAL_TIM_PWM_ConfigChannel>
 8005250:	b9b8      	cbnz	r0, 8005282 <MX_TIM4_Init+0x9e>
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
 8005252:	2208      	movs	r2, #8
 8005254:	a901      	add	r1, sp, #4
 8005256:	480e      	ldr	r0, [pc, #56]	; (8005290 <MX_TIM4_Init+0xac>)
 8005258:	f7fe f80e 	bl	8003278 <HAL_TIM_PWM_ConfigChannel>
 800525c:	b998      	cbnz	r0, 8005286 <MX_TIM4_Init+0xa2>
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
 800525e:	220c      	movs	r2, #12
 8005260:	a901      	add	r1, sp, #4
 8005262:	480b      	ldr	r0, [pc, #44]	; (8005290 <MX_TIM4_Init+0xac>)
 8005264:	f7fe f808 	bl	8003278 <HAL_TIM_PWM_ConfigChannel>
 8005268:	b978      	cbnz	r0, 800528a <MX_TIM4_Init+0xa6>
  HAL_TIM_MspPostInit(&htim4);
 800526a:	4809      	ldr	r0, [pc, #36]	; (8005290 <MX_TIM4_Init+0xac>)
 800526c:	f000 fb06 	bl	800587c <HAL_TIM_MspPostInit>
}
 8005270:	b00b      	add	sp, #44	; 0x2c
 8005272:	f85d fb04 	ldr.w	pc, [sp], #4
    Error_Handler();
 8005276:	f7ff fe83 	bl	8004f80 <Error_Handler>
    Error_Handler();
 800527a:	f7ff fe81 	bl	8004f80 <Error_Handler>
    Error_Handler();
 800527e:	f7ff fe7f 	bl	8004f80 <Error_Handler>
    Error_Handler();
 8005282:	f7ff fe7d 	bl	8004f80 <Error_Handler>
    Error_Handler();
 8005286:	f7ff fe7b 	bl	8004f80 <Error_Handler>
    Error_Handler();
 800528a:	f7ff fe79 	bl	8004f80 <Error_Handler>
 800528e:	bf00      	nop
 8005290:	2000105c 	.word	0x2000105c
 8005294:	40000800 	.word	0x40000800

08005298 <MX_TIM5_Init>:
{
 8005298:	b500      	push	{lr}
 800529a:	b08b      	sub	sp, #44	; 0x2c
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 800529c:	2300      	movs	r3, #0
 800529e:	9308      	str	r3, [sp, #32]
 80052a0:	9309      	str	r3, [sp, #36]	; 0x24
  TIM_OC_InitTypeDef sConfigOC = {0};
 80052a2:	9301      	str	r3, [sp, #4]
 80052a4:	9302      	str	r3, [sp, #8]
 80052a6:	9303      	str	r3, [sp, #12]
 80052a8:	9304      	str	r3, [sp, #16]
 80052aa:	9305      	str	r3, [sp, #20]
 80052ac:	9306      	str	r3, [sp, #24]
 80052ae:	9307      	str	r3, [sp, #28]
  htim5.Instance = TIM5;
 80052b0:	481f      	ldr	r0, [pc, #124]	; (8005330 <MX_TIM5_Init+0x98>)
 80052b2:	4a20      	ldr	r2, [pc, #128]	; (8005334 <MX_TIM5_Init+0x9c>)
 80052b4:	6002      	str	r2, [r0, #0]
  htim5.Init.Prescaler = 8;
 80052b6:	2208      	movs	r2, #8
 80052b8:	6042      	str	r2, [r0, #4]
  htim5.Init.CounterMode = TIM_COUNTERMODE_UP;
 80052ba:	6083      	str	r3, [r0, #8]
  htim5.Init.Period = 19999;
 80052bc:	f644 621f 	movw	r2, #19999	; 0x4e1f
 80052c0:	60c2      	str	r2, [r0, #12]
  htim5.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 80052c2:	6103      	str	r3, [r0, #16]
  htim5.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
 80052c4:	2380      	movs	r3, #128	; 0x80
 80052c6:	6183      	str	r3, [r0, #24]
  if (HAL_TIM_PWM_Init(&htim5) != HAL_OK)
 80052c8:	f7fd fef8 	bl	80030bc <HAL_TIM_PWM_Init>
 80052cc:	bb30      	cbnz	r0, 800531c <MX_TIM5_Init+0x84>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 80052ce:	2300      	movs	r3, #0
 80052d0:	9308      	str	r3, [sp, #32]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 80052d2:	9309      	str	r3, [sp, #36]	; 0x24
  if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig) != HAL_OK)
 80052d4:	a908      	add	r1, sp, #32
 80052d6:	4816      	ldr	r0, [pc, #88]	; (8005330 <MX_TIM5_Init+0x98>)
 80052d8:	f7fe f9c2 	bl	8003660 <HAL_TIMEx_MasterConfigSynchronization>
 80052dc:	bb00      	cbnz	r0, 8005320 <MX_TIM5_Init+0x88>
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 80052de:	2360      	movs	r3, #96	; 0x60
 80052e0:	9301      	str	r3, [sp, #4]
  sConfigOC.Pulse = 0;
 80052e2:	2300      	movs	r3, #0
 80052e4:	9302      	str	r3, [sp, #8]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 80052e6:	9303      	str	r3, [sp, #12]
  sConfigOC.OCFastMode = TIM_OCFAST_ENABLE;
 80052e8:	2204      	movs	r2, #4
 80052ea:	9205      	str	r2, [sp, #20]
  if (HAL_TIM_PWM_ConfigChannel(&htim5, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 80052ec:	eb0d 0102 	add.w	r1, sp, r2
 80052f0:	480f      	ldr	r0, [pc, #60]	; (8005330 <MX_TIM5_Init+0x98>)
 80052f2:	f7fd ffc1 	bl	8003278 <HAL_TIM_PWM_ConfigChannel>
 80052f6:	b9a8      	cbnz	r0, 8005324 <MX_TIM5_Init+0x8c>
  if (HAL_TIM_PWM_ConfigChannel(&htim5, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
 80052f8:	2208      	movs	r2, #8
 80052fa:	a901      	add	r1, sp, #4
 80052fc:	480c      	ldr	r0, [pc, #48]	; (8005330 <MX_TIM5_Init+0x98>)
 80052fe:	f7fd ffbb 	bl	8003278 <HAL_TIM_PWM_ConfigChannel>
 8005302:	b988      	cbnz	r0, 8005328 <MX_TIM5_Init+0x90>
  if (HAL_TIM_PWM_ConfigChannel(&htim5, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
 8005304:	220c      	movs	r2, #12
 8005306:	a901      	add	r1, sp, #4
 8005308:	4809      	ldr	r0, [pc, #36]	; (8005330 <MX_TIM5_Init+0x98>)
 800530a:	f7fd ffb5 	bl	8003278 <HAL_TIM_PWM_ConfigChannel>
 800530e:	b968      	cbnz	r0, 800532c <MX_TIM5_Init+0x94>
  HAL_TIM_MspPostInit(&htim5);
 8005310:	4807      	ldr	r0, [pc, #28]	; (8005330 <MX_TIM5_Init+0x98>)
 8005312:	f000 fab3 	bl	800587c <HAL_TIM_MspPostInit>
}
 8005316:	b00b      	add	sp, #44	; 0x2c
 8005318:	f85d fb04 	ldr.w	pc, [sp], #4
    Error_Handler();
 800531c:	f7ff fe30 	bl	8004f80 <Error_Handler>
    Error_Handler();
 8005320:	f7ff fe2e 	bl	8004f80 <Error_Handler>
    Error_Handler();
 8005324:	f7ff fe2c 	bl	8004f80 <Error_Handler>
    Error_Handler();
 8005328:	f7ff fe2a 	bl	8004f80 <Error_Handler>
    Error_Handler();
 800532c:	f7ff fe28 	bl	8004f80 <Error_Handler>
 8005330:	20001108 	.word	0x20001108
 8005334:	40000c00 	.word	0x40000c00

08005338 <MX_TIM8_Init>:
{
 8005338:	b510      	push	{r4, lr}
 800533a:	b092      	sub	sp, #72	; 0x48
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 800533c:	2400      	movs	r4, #0
 800533e:	9410      	str	r4, [sp, #64]	; 0x40
 8005340:	9411      	str	r4, [sp, #68]	; 0x44
  TIM_OC_InitTypeDef sConfigOC = {0};
 8005342:	9409      	str	r4, [sp, #36]	; 0x24
 8005344:	940a      	str	r4, [sp, #40]	; 0x28
 8005346:	940b      	str	r4, [sp, #44]	; 0x2c
 8005348:	940c      	str	r4, [sp, #48]	; 0x30
 800534a:	940d      	str	r4, [sp, #52]	; 0x34
 800534c:	940e      	str	r4, [sp, #56]	; 0x38
 800534e:	940f      	str	r4, [sp, #60]	; 0x3c
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};
 8005350:	2220      	movs	r2, #32
 8005352:	4621      	mov	r1, r4
 8005354:	a801      	add	r0, sp, #4
 8005356:	f000 fc95 	bl	8005c84 <memset>
  htim8.Instance = TIM8;
 800535a:	482e      	ldr	r0, [pc, #184]	; (8005414 <MX_TIM8_Init+0xdc>)
 800535c:	4b2e      	ldr	r3, [pc, #184]	; (8005418 <MX_TIM8_Init+0xe0>)
 800535e:	6003      	str	r3, [r0, #0]
  htim8.Init.Prescaler = 17;
 8005360:	2311      	movs	r3, #17
 8005362:	6043      	str	r3, [r0, #4]
  htim8.Init.CounterMode = TIM_COUNTERMODE_UP;
 8005364:	6084      	str	r4, [r0, #8]
  htim8.Init.Period = 19999;
 8005366:	f644 631f 	movw	r3, #19999	; 0x4e1f
 800536a:	60c3      	str	r3, [r0, #12]
  htim8.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 800536c:	6104      	str	r4, [r0, #16]
  htim8.Init.RepetitionCounter = 0;
 800536e:	6144      	str	r4, [r0, #20]
  htim8.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
 8005370:	2380      	movs	r3, #128	; 0x80
 8005372:	6183      	str	r3, [r0, #24]
  if (HAL_TIM_PWM_Init(&htim8) != HAL_OK)
 8005374:	f7fd fea2 	bl	80030bc <HAL_TIM_PWM_Init>
 8005378:	2800      	cmp	r0, #0
 800537a:	d13d      	bne.n	80053f8 <MX_TIM8_Init+0xc0>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 800537c:	2300      	movs	r3, #0
 800537e:	9310      	str	r3, [sp, #64]	; 0x40
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8005380:	9311      	str	r3, [sp, #68]	; 0x44
  if (HAL_TIMEx_MasterConfigSynchronization(&htim8, &sMasterConfig) != HAL_OK)
 8005382:	a910      	add	r1, sp, #64	; 0x40
 8005384:	4823      	ldr	r0, [pc, #140]	; (8005414 <MX_TIM8_Init+0xdc>)
 8005386:	f7fe f96b 	bl	8003660 <HAL_TIMEx_MasterConfigSynchronization>
 800538a:	2800      	cmp	r0, #0
 800538c:	d136      	bne.n	80053fc <MX_TIM8_Init+0xc4>
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 800538e:	2360      	movs	r3, #96	; 0x60
 8005390:	9309      	str	r3, [sp, #36]	; 0x24
  sConfigOC.Pulse = 0;
 8005392:	2200      	movs	r2, #0
 8005394:	920a      	str	r2, [sp, #40]	; 0x28
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 8005396:	920b      	str	r2, [sp, #44]	; 0x2c
  sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
 8005398:	920c      	str	r2, [sp, #48]	; 0x30
  sConfigOC.OCFastMode = TIM_OCFAST_ENABLE;
 800539a:	2304      	movs	r3, #4
 800539c:	930d      	str	r3, [sp, #52]	; 0x34
  sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
 800539e:	920e      	str	r2, [sp, #56]	; 0x38
  sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
 80053a0:	920f      	str	r2, [sp, #60]	; 0x3c
  if (HAL_TIM_PWM_ConfigChannel(&htim8, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 80053a2:	a909      	add	r1, sp, #36	; 0x24
 80053a4:	481b      	ldr	r0, [pc, #108]	; (8005414 <MX_TIM8_Init+0xdc>)
 80053a6:	f7fd ff67 	bl	8003278 <HAL_TIM_PWM_ConfigChannel>
 80053aa:	bb48      	cbnz	r0, 8005400 <MX_TIM8_Init+0xc8>
  if (HAL_TIM_PWM_ConfigChannel(&htim8, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 80053ac:	2204      	movs	r2, #4
 80053ae:	a909      	add	r1, sp, #36	; 0x24
 80053b0:	4818      	ldr	r0, [pc, #96]	; (8005414 <MX_TIM8_Init+0xdc>)
 80053b2:	f7fd ff61 	bl	8003278 <HAL_TIM_PWM_ConfigChannel>
 80053b6:	bb28      	cbnz	r0, 8005404 <MX_TIM8_Init+0xcc>
  if (HAL_TIM_PWM_ConfigChannel(&htim8, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
 80053b8:	2208      	movs	r2, #8
 80053ba:	a909      	add	r1, sp, #36	; 0x24
 80053bc:	4815      	ldr	r0, [pc, #84]	; (8005414 <MX_TIM8_Init+0xdc>)
 80053be:	f7fd ff5b 	bl	8003278 <HAL_TIM_PWM_ConfigChannel>
 80053c2:	bb08      	cbnz	r0, 8005408 <MX_TIM8_Init+0xd0>
  if (HAL_TIM_PWM_ConfigChannel(&htim8, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
 80053c4:	220c      	movs	r2, #12
 80053c6:	a909      	add	r1, sp, #36	; 0x24
 80053c8:	4812      	ldr	r0, [pc, #72]	; (8005414 <MX_TIM8_Init+0xdc>)
 80053ca:	f7fd ff55 	bl	8003278 <HAL_TIM_PWM_ConfigChannel>
 80053ce:	b9e8      	cbnz	r0, 800540c <MX_TIM8_Init+0xd4>
  sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
 80053d0:	2300      	movs	r3, #0
 80053d2:	9301      	str	r3, [sp, #4]
  sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
 80053d4:	9302      	str	r3, [sp, #8]
  sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
 80053d6:	9303      	str	r3, [sp, #12]
  sBreakDeadTimeConfig.DeadTime = 0;
 80053d8:	9304      	str	r3, [sp, #16]
  sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
 80053da:	9305      	str	r3, [sp, #20]
  sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
 80053dc:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 80053e0:	9206      	str	r2, [sp, #24]
  sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
 80053e2:	9308      	str	r3, [sp, #32]
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim8, &sBreakDeadTimeConfig) != HAL_OK)
 80053e4:	a901      	add	r1, sp, #4
 80053e6:	480b      	ldr	r0, [pc, #44]	; (8005414 <MX_TIM8_Init+0xdc>)
 80053e8:	f7fe f9be 	bl	8003768 <HAL_TIMEx_ConfigBreakDeadTime>
 80053ec:	b980      	cbnz	r0, 8005410 <MX_TIM8_Init+0xd8>
  HAL_TIM_MspPostInit(&htim8);
 80053ee:	4809      	ldr	r0, [pc, #36]	; (8005414 <MX_TIM8_Init+0xdc>)
 80053f0:	f000 fa44 	bl	800587c <HAL_TIM_MspPostInit>
}
 80053f4:	b012      	add	sp, #72	; 0x48
 80053f6:	bd10      	pop	{r4, pc}
    Error_Handler();
 80053f8:	f7ff fdc2 	bl	8004f80 <Error_Handler>
    Error_Handler();
 80053fc:	f7ff fdc0 	bl	8004f80 <Error_Handler>
    Error_Handler();
 8005400:	f7ff fdbe 	bl	8004f80 <Error_Handler>
    Error_Handler();
 8005404:	f7ff fdbc 	bl	8004f80 <Error_Handler>
    Error_Handler();
 8005408:	f7ff fdba 	bl	8004f80 <Error_Handler>
    Error_Handler();
 800540c:	f7ff fdb8 	bl	8004f80 <Error_Handler>
    Error_Handler();
 8005410:	f7ff fdb6 	bl	8004f80 <Error_Handler>
 8005414:	20001014 	.word	0x20001014
 8005418:	40013400 	.word	0x40013400

0800541c <MX_UART4_Init>:
{
 800541c:	b508      	push	{r3, lr}
  huart4.Instance = UART4;
 800541e:	480a      	ldr	r0, [pc, #40]	; (8005448 <MX_UART4_Init+0x2c>)
 8005420:	4b0a      	ldr	r3, [pc, #40]	; (800544c <MX_UART4_Init+0x30>)
 8005422:	6003      	str	r3, [r0, #0]
  huart4.Init.BaudRate = 9600;
 8005424:	f44f 5316 	mov.w	r3, #9600	; 0x2580
 8005428:	6043      	str	r3, [r0, #4]
  huart4.Init.WordLength = UART_WORDLENGTH_8B;
 800542a:	2300      	movs	r3, #0
 800542c:	6083      	str	r3, [r0, #8]
  huart4.Init.StopBits = UART_STOPBITS_1;
 800542e:	60c3      	str	r3, [r0, #12]
  huart4.Init.Parity = UART_PARITY_NONE;
 8005430:	6103      	str	r3, [r0, #16]
  huart4.Init.Mode = UART_MODE_TX_RX;
 8005432:	220c      	movs	r2, #12
 8005434:	6142      	str	r2, [r0, #20]
  huart4.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8005436:	6183      	str	r3, [r0, #24]
  huart4.Init.OverSampling = UART_OVERSAMPLING_16;
 8005438:	61c3      	str	r3, [r0, #28]
  if (HAL_UART_Init(&huart4) != HAL_OK)
 800543a:	f7fe fae9 	bl	8003a10 <HAL_UART_Init>
 800543e:	b900      	cbnz	r0, 8005442 <MX_UART4_Init+0x26>
}
 8005440:	bd08      	pop	{r3, pc}
    Error_Handler();
 8005442:	f7ff fd9d 	bl	8004f80 <Error_Handler>
 8005446:	bf00      	nop
 8005448:	20001208 	.word	0x20001208
 800544c:	40004c00 	.word	0x40004c00

08005450 <SystemClock_Config>:
{
 8005450:	b500      	push	{lr}
 8005452:	b091      	sub	sp, #68	; 0x44
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8005454:	2300      	movs	r3, #0
 8005456:	9308      	str	r3, [sp, #32]
 8005458:	9309      	str	r3, [sp, #36]	; 0x24
 800545a:	930b      	str	r3, [sp, #44]	; 0x2c
 800545c:	930c      	str	r3, [sp, #48]	; 0x30
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 800545e:	9301      	str	r3, [sp, #4]
 8005460:	9302      	str	r3, [sp, #8]
 8005462:	9303      	str	r3, [sp, #12]
 8005464:	9304      	str	r3, [sp, #16]
 8005466:	9305      	str	r3, [sp, #20]
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8005468:	2201      	movs	r2, #1
 800546a:	9206      	str	r2, [sp, #24]
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 800546c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8005470:	9307      	str	r3, [sp, #28]
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 8005472:	920a      	str	r2, [sp, #40]	; 0x28
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8005474:	2202      	movs	r2, #2
 8005476:	920d      	str	r2, [sp, #52]	; 0x34
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8005478:	930e      	str	r3, [sp, #56]	; 0x38
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
 800547a:	f44f 13e0 	mov.w	r3, #1835008	; 0x1c0000
 800547e:	930f      	str	r3, [sp, #60]	; 0x3c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8005480:	a806      	add	r0, sp, #24
 8005482:	f7fd f8cb 	bl	800261c <HAL_RCC_OscConfig>
 8005486:	b990      	cbnz	r0, 80054ae <SystemClock_Config+0x5e>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8005488:	230f      	movs	r3, #15
 800548a:	9301      	str	r3, [sp, #4]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 800548c:	2102      	movs	r1, #2
 800548e:	9102      	str	r1, [sp, #8]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8005490:	2300      	movs	r3, #0
 8005492:	9303      	str	r3, [sp, #12]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV16;
 8005494:	f44f 63e0 	mov.w	r3, #1792	; 0x700
 8005498:	9304      	str	r3, [sp, #16]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV8;
 800549a:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 800549e:	9305      	str	r3, [sp, #20]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
 80054a0:	a801      	add	r0, sp, #4
 80054a2:	f7fd fb95 	bl	8002bd0 <HAL_RCC_ClockConfig>
 80054a6:	b920      	cbnz	r0, 80054b2 <SystemClock_Config+0x62>
}
 80054a8:	b011      	add	sp, #68	; 0x44
 80054aa:	f85d fb04 	ldr.w	pc, [sp], #4
    Error_Handler();
 80054ae:	f7ff fd67 	bl	8004f80 <Error_Handler>
    Error_Handler();
 80054b2:	f7ff fd65 	bl	8004f80 <Error_Handler>
	...

080054b8 <main>:
{
 80054b8:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 80054bc:	b097      	sub	sp, #92	; 0x5c
  HAL_Init();
 80054be:	f7fb f9cf 	bl	8000860 <HAL_Init>
  SystemClock_Config();
 80054c2:	f7ff ffc5 	bl	8005450 <SystemClock_Config>
  MX_GPIO_Init();
 80054c6:	f7ff fb9f 	bl	8004c08 <MX_GPIO_Init>
  MX_DMA_Init();
 80054ca:	f7ff fbf5 	bl	8004cb8 <MX_DMA_Init>
  MX_I2C2_Init();
 80054ce:	f7ff fd59 	bl	8004f84 <MX_I2C2_Init>
  MX_TIM1_Init();
 80054d2:	f7ff fd73 	bl	8004fbc <MX_TIM1_Init>
  MX_TIM2_Init();
 80054d6:	f7ff fde3 	bl	80050a0 <MX_TIM2_Init>
  MX_TIM3_Init();
 80054da:	f7ff fe29 	bl	8005130 <MX_TIM3_Init>
  MX_TIM4_Init();
 80054de:	f7ff fe81 	bl	80051e4 <MX_TIM4_Init>
  MX_TIM5_Init();
 80054e2:	f7ff fed9 	bl	8005298 <MX_TIM5_Init>
  MX_TIM8_Init();
 80054e6:	f7ff ff27 	bl	8005338 <MX_TIM8_Init>
  MX_UART4_Init();
 80054ea:	f7ff ff97 	bl	800541c <MX_UART4_Init>
  HAL_TIM_PWM_Start(&htim3,TIM_CHANNEL_4); TIM3->CCR4=servoWrite(90);	//1_1
 80054ee:	f8df 81d0 	ldr.w	r8, [pc, #464]	; 80056c0 <main+0x208>
 80054f2:	210c      	movs	r1, #12
 80054f4:	4640      	mov	r0, r8
 80054f6:	f7fe f80f 	bl	8003518 <HAL_TIM_PWM_Start>
 80054fa:	4866      	ldr	r0, [pc, #408]	; (8005694 <main+0x1dc>)
 80054fc:	f7ff fc24 	bl	8004d48 <servoWrite>
 8005500:	f7fb f96a 	bl	80007d8 <__aeabi_f2uiz>
 8005504:	4604      	mov	r4, r0
 8005506:	4f64      	ldr	r7, [pc, #400]	; (8005698 <main+0x1e0>)
 8005508:	6438      	str	r0, [r7, #64]	; 0x40
  HAL_TIM_PWM_Start(&htim3,TIM_CHANNEL_3); TIM3->CCR3=servoWrite(90);	//1_2
 800550a:	2108      	movs	r1, #8
 800550c:	4640      	mov	r0, r8
 800550e:	f7fe f803 	bl	8003518 <HAL_TIM_PWM_Start>
 8005512:	63fc      	str	r4, [r7, #60]	; 0x3c
  HAL_TIM_PWM_Start(&htim3,TIM_CHANNEL_2); TIM3->CCR2=servoWrite(120);	//1_3
 8005514:	2104      	movs	r1, #4
 8005516:	4640      	mov	r0, r8
 8005518:	f7fd fffe 	bl	8003518 <HAL_TIM_PWM_Start>
 800551c:	485f      	ldr	r0, [pc, #380]	; (800569c <main+0x1e4>)
 800551e:	f7ff fc13 	bl	8004d48 <servoWrite>
 8005522:	f7fb f959 	bl	80007d8 <__aeabi_f2uiz>
 8005526:	4683      	mov	fp, r0
 8005528:	63b8      	str	r0, [r7, #56]	; 0x38
  HAL_TIM_PWM_Start(&htim5,TIM_CHANNEL_4); TIM5->CCR4=servoWrite(90);	//2_1
 800552a:	4e5d      	ldr	r6, [pc, #372]	; (80056a0 <main+0x1e8>)
 800552c:	210c      	movs	r1, #12
 800552e:	4630      	mov	r0, r6
 8005530:	f7fd fff2 	bl	8003518 <HAL_TIM_PWM_Start>
 8005534:	4d5b      	ldr	r5, [pc, #364]	; (80056a4 <main+0x1ec>)
 8005536:	642c      	str	r4, [r5, #64]	; 0x40
  HAL_TIM_PWM_Start(&htim5,TIM_CHANNEL_3); TIM5->CCR3=servoWrite(90);	//2_2
 8005538:	2108      	movs	r1, #8
 800553a:	4630      	mov	r0, r6
 800553c:	f7fd ffec 	bl	8003518 <HAL_TIM_PWM_Start>
 8005540:	63ec      	str	r4, [r5, #60]	; 0x3c
  HAL_TIM_PWM_Start(&htim5,TIM_CHANNEL_2); TIM5->CCR2=servoWrite(120);	//2_3
 8005542:	2104      	movs	r1, #4
 8005544:	4630      	mov	r0, r6
 8005546:	f7fd ffe7 	bl	8003518 <HAL_TIM_PWM_Start>
 800554a:	f8c5 b038 	str.w	fp, [r5, #56]	; 0x38
  HAL_TIM_PWM_Start(&htim4,TIM_CHANNEL_1); TIM4->CCR1=servoWrite(90);	//3_1
 800554e:	f8df 9174 	ldr.w	r9, [pc, #372]	; 80056c4 <main+0x20c>
 8005552:	2100      	movs	r1, #0
 8005554:	4648      	mov	r0, r9
 8005556:	f7fd ffdf 	bl	8003518 <HAL_TIM_PWM_Start>
 800555a:	f8df a16c 	ldr.w	sl, [pc, #364]	; 80056c8 <main+0x210>
 800555e:	f8ca 4034 	str.w	r4, [sl, #52]	; 0x34
  HAL_TIM_PWM_Start(&htim3,TIM_CHANNEL_1); TIM3->CCR1=servoWrite(90);	//3_2
 8005562:	2100      	movs	r1, #0
 8005564:	4640      	mov	r0, r8
 8005566:	f7fd ffd7 	bl	8003518 <HAL_TIM_PWM_Start>
 800556a:	637c      	str	r4, [r7, #52]	; 0x34
  HAL_TIM_PWM_Start(&htim1,TIM_CHANNEL_4); TIM1->CCR4=servoWrite(120);	//3_3
 800556c:	f8df 815c 	ldr.w	r8, [pc, #348]	; 80056cc <main+0x214>
 8005570:	210c      	movs	r1, #12
 8005572:	4640      	mov	r0, r8
 8005574:	f7fd ffd0 	bl	8003518 <HAL_TIM_PWM_Start>
 8005578:	f507 3794 	add.w	r7, r7, #75776	; 0x12800
 800557c:	f8c7 b040 	str.w	fp, [r7, #64]	; 0x40
  HAL_TIM_PWM_Start(&htim4,TIM_CHANNEL_4); TIM4->CCR4=servoWrite(90);	//4_1
 8005580:	210c      	movs	r1, #12
 8005582:	4648      	mov	r0, r9
 8005584:	f7fd ffc8 	bl	8003518 <HAL_TIM_PWM_Start>
 8005588:	f8ca 4040 	str.w	r4, [sl, #64]	; 0x40
  HAL_TIM_PWM_Start(&htim4,TIM_CHANNEL_3); TIM4->CCR3=servoWrite(90);	//4_2
 800558c:	2108      	movs	r1, #8
 800558e:	4648      	mov	r0, r9
 8005590:	f7fd ffc2 	bl	8003518 <HAL_TIM_PWM_Start>
 8005594:	f8ca 403c 	str.w	r4, [sl, #60]	; 0x3c
  HAL_TIM_PWM_Start(&htim4,TIM_CHANNEL_2); TIM4->CCR2=servoWrite(70);	//4_3
 8005598:	2104      	movs	r1, #4
 800559a:	4648      	mov	r0, r9
 800559c:	f7fd ffbc 	bl	8003518 <HAL_TIM_PWM_Start>
 80055a0:	4841      	ldr	r0, [pc, #260]	; (80056a8 <main+0x1f0>)
 80055a2:	f7ff fbd1 	bl	8004d48 <servoWrite>
 80055a6:	f7fb f917 	bl	80007d8 <__aeabi_f2uiz>
 80055aa:	4681      	mov	r9, r0
 80055ac:	f8ca 0038 	str.w	r0, [sl, #56]	; 0x38
  HAL_TIM_PWM_Start(&htim1,TIM_CHANNEL_1); TIM1->CCR1=servoWrite(90); 	//5_1
 80055b0:	2100      	movs	r1, #0
 80055b2:	4640      	mov	r0, r8
 80055b4:	f7fd ffb0 	bl	8003518 <HAL_TIM_PWM_Start>
 80055b8:	637c      	str	r4, [r7, #52]	; 0x34
  HAL_TIM_PWM_Start(&htim1,TIM_CHANNEL_2); TIM1->CCR2=servoWrite(90); 	//5_2
 80055ba:	2104      	movs	r1, #4
 80055bc:	4640      	mov	r0, r8
 80055be:	f7fd ffab 	bl	8003518 <HAL_TIM_PWM_Start>
 80055c2:	63bc      	str	r4, [r7, #56]	; 0x38
  HAL_TIM_PWM_Start(&htim1,TIM_CHANNEL_3); TIM1->CCR3=servoWrite(70); 	//5_3
 80055c4:	2108      	movs	r1, #8
 80055c6:	4640      	mov	r0, r8
 80055c8:	f7fd ffa6 	bl	8003518 <HAL_TIM_PWM_Start>
 80055cc:	f8c7 903c 	str.w	r9, [r7, #60]	; 0x3c
  HAL_TIM_PWM_Start(&htim8,TIM_CHANNEL_1); TIM8->CCR1=servoWrite(90); 	//6_1
 80055d0:	4f36      	ldr	r7, [pc, #216]	; (80056ac <main+0x1f4>)
 80055d2:	2100      	movs	r1, #0
 80055d4:	4638      	mov	r0, r7
 80055d6:	f7fd ff9f 	bl	8003518 <HAL_TIM_PWM_Start>
 80055da:	f8df 80f4 	ldr.w	r8, [pc, #244]	; 80056d0 <main+0x218>
 80055de:	f8c8 4034 	str.w	r4, [r8, #52]	; 0x34
  HAL_TIM_PWM_Start(&htim8,TIM_CHANNEL_2); TIM8->CCR2=servoWrite(90); 	//6_2
 80055e2:	2104      	movs	r1, #4
 80055e4:	4638      	mov	r0, r7
 80055e6:	f7fd ff97 	bl	8003518 <HAL_TIM_PWM_Start>
 80055ea:	f8c8 4038 	str.w	r4, [r8, #56]	; 0x38
  HAL_TIM_PWM_Start(&htim8,TIM_CHANNEL_3); TIM8->CCR3=servoWrite(70); 	//6_3
 80055ee:	2108      	movs	r1, #8
 80055f0:	4638      	mov	r0, r7
 80055f2:	f7fd ff91 	bl	8003518 <HAL_TIM_PWM_Start>
 80055f6:	f8c8 903c 	str.w	r9, [r8, #60]	; 0x3c
  HAL_TIM_PWM_Start(&htim2,TIM_CHANNEL_1); TIM2->CCR1=55535;
 80055fa:	f8df a0d8 	ldr.w	sl, [pc, #216]	; 80056d4 <main+0x21c>
 80055fe:	2100      	movs	r1, #0
 8005600:	4650      	mov	r0, sl
 8005602:	f7fd ff89 	bl	8003518 <HAL_TIM_PWM_Start>
 8005606:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
 800560a:	f64d 09ef 	movw	r9, #55535	; 0xd8ef
 800560e:	f8c4 9034 	str.w	r9, [r4, #52]	; 0x34
  HAL_TIM_PWM_Start(&htim2,TIM_CHANNEL_2); TIM2->CCR2=55535;
 8005612:	2104      	movs	r1, #4
 8005614:	4650      	mov	r0, sl
 8005616:	f7fd ff7f 	bl	8003518 <HAL_TIM_PWM_Start>
 800561a:	f8c4 9038 	str.w	r9, [r4, #56]	; 0x38
  HAL_TIM_PWM_Start(&htim8,TIM_CHANNEL_4); TIM8->CCR4=0; // not use
 800561e:	210c      	movs	r1, #12
 8005620:	4638      	mov	r0, r7
 8005622:	f7fd ff79 	bl	8003518 <HAL_TIM_PWM_Start>
 8005626:	2700      	movs	r7, #0
 8005628:	f8c8 7040 	str.w	r7, [r8, #64]	; 0x40
  HAL_TIM_PWM_Start(&htim5,TIM_CHANNEL_1); TIM5->CCR1=0; // not use
 800562c:	4639      	mov	r1, r7
 800562e:	4630      	mov	r0, r6
 8005630:	f7fd ff72 	bl	8003518 <HAL_TIM_PWM_Start>
 8005634:	636f      	str	r7, [r5, #52]	; 0x34
  osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 128);
 8005636:	4c1e      	ldr	r4, [pc, #120]	; (80056b0 <main+0x1f8>)
 8005638:	ad0f      	add	r5, sp, #60	; 0x3c
 800563a:	4626      	mov	r6, r4
 800563c:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800563e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8005640:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
 8005644:	e885 0007 	stmia.w	r5, {r0, r1, r2}
  defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);
 8005648:	4639      	mov	r1, r7
 800564a:	a80f      	add	r0, sp, #60	; 0x3c
 800564c:	f7fe fc67 	bl	8003f1e <osThreadCreate>
 8005650:	4b18      	ldr	r3, [pc, #96]	; (80056b4 <main+0x1fc>)
 8005652:	6018      	str	r0, [r3, #0]
  osThreadDef(myTask02, StartTask02, osPriorityIdle, 0, 128);
 8005654:	ad08      	add	r5, sp, #32
 8005656:	f104 061c 	add.w	r6, r4, #28
 800565a:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800565c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800565e:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
 8005662:	e885 0007 	stmia.w	r5, {r0, r1, r2}
  myTask02Handle = osThreadCreate(osThread(myTask02), NULL);
 8005666:	4639      	mov	r1, r7
 8005668:	a808      	add	r0, sp, #32
 800566a:	f7fe fc58 	bl	8003f1e <osThreadCreate>
 800566e:	4b12      	ldr	r3, [pc, #72]	; (80056b8 <main+0x200>)
 8005670:	6018      	str	r0, [r3, #0]
  osThreadDef(myTask03, StartTask03, osPriorityIdle, 0, 128);
 8005672:	ad01      	add	r5, sp, #4
 8005674:	3438      	adds	r4, #56	; 0x38
 8005676:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8005678:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800567a:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 800567e:	e885 0007 	stmia.w	r5, {r0, r1, r2}
  myTask03Handle = osThreadCreate(osThread(myTask03), NULL);
 8005682:	4639      	mov	r1, r7
 8005684:	a801      	add	r0, sp, #4
 8005686:	f7fe fc4a 	bl	8003f1e <osThreadCreate>
 800568a:	4b0c      	ldr	r3, [pc, #48]	; (80056bc <main+0x204>)
 800568c:	6018      	str	r0, [r3, #0]
  osKernelStart();
 800568e:	f7fe fc41 	bl	8003f14 <osKernelStart>
 8005692:	e7fe      	b.n	8005692 <main+0x1da>
 8005694:	42b40000 	.word	0x42b40000
 8005698:	40000400 	.word	0x40000400
 800569c:	42f00000 	.word	0x42f00000
 80056a0:	20001108 	.word	0x20001108
 80056a4:	40000c00 	.word	0x40000c00
 80056a8:	428c0000 	.word	0x428c0000
 80056ac:	20001014 	.word	0x20001014
 80056b0:	08005cc0 	.word	0x08005cc0
 80056b4:	20001010 	.word	0x20001010
 80056b8:	2000119c 	.word	0x2000119c
 80056bc:	20001204 	.word	0x20001204
 80056c0:	20001150 	.word	0x20001150
 80056c4:	2000105c 	.word	0x2000105c
 80056c8:	40000800 	.word	0x40000800
 80056cc:	200011bc 	.word	0x200011bc
 80056d0:	40013400 	.word	0x40013400
 80056d4:	20001248 	.word	0x20001248

080056d8 <assert_failed>:
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     tex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
 80056d8:	4770      	bx	lr
	...

080056dc <HAL_MspInit>:
void HAL_TIM_MspPostInit(TIM_HandleTypeDef *htim);
                                                                                                                        /**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 80056dc:	b500      	push	{lr}
 80056de:	b083      	sub	sp, #12
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_AFIO_CLK_ENABLE();
 80056e0:	4b11      	ldr	r3, [pc, #68]	; (8005728 <HAL_MspInit+0x4c>)
 80056e2:	699a      	ldr	r2, [r3, #24]
 80056e4:	f042 0201 	orr.w	r2, r2, #1
 80056e8:	619a      	str	r2, [r3, #24]
 80056ea:	699a      	ldr	r2, [r3, #24]
 80056ec:	f002 0201 	and.w	r2, r2, #1
 80056f0:	9200      	str	r2, [sp, #0]
 80056f2:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 80056f4:	69da      	ldr	r2, [r3, #28]
 80056f6:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80056fa:	61da      	str	r2, [r3, #28]
 80056fc:	69db      	ldr	r3, [r3, #28]
 80056fe:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8005702:	9301      	str	r3, [sp, #4]
 8005704:	9b01      	ldr	r3, [sp, #4]

  /* System interrupt init*/
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 8005706:	2200      	movs	r2, #0
 8005708:	210f      	movs	r1, #15
 800570a:	f06f 0001 	mvn.w	r0, #1
 800570e:	f7fb f8e9 	bl	80008e4 <HAL_NVIC_SetPriority>

  /** NOJTAG: JTAG-DP Disabled and SW-DP Enabled
  */
  __HAL_AFIO_REMAP_SWJ_NOJTAG();
 8005712:	4a06      	ldr	r2, [pc, #24]	; (800572c <HAL_MspInit+0x50>)
 8005714:	6853      	ldr	r3, [r2, #4]
 8005716:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
 800571a:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 800571e:	6053      	str	r3, [r2, #4]

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8005720:	b003      	add	sp, #12
 8005722:	f85d fb04 	ldr.w	pc, [sp], #4
 8005726:	bf00      	nop
 8005728:	40021000 	.word	0x40021000
 800572c:	40010000 	.word	0x40010000

08005730 <HAL_I2C_MspInit>:
* This function configures the hardware resources used in this example
* @param hi2c: I2C handle pointer
* @retval None
*/
void HAL_I2C_MspInit(I2C_HandleTypeDef* hi2c)
{
 8005730:	b510      	push	{r4, lr}
 8005732:	b086      	sub	sp, #24
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8005734:	2300      	movs	r3, #0
 8005736:	9302      	str	r3, [sp, #8]
 8005738:	9303      	str	r3, [sp, #12]
 800573a:	9304      	str	r3, [sp, #16]
 800573c:	9305      	str	r3, [sp, #20]
  if(hi2c->Instance==I2C2)
 800573e:	6802      	ldr	r2, [r0, #0]
 8005740:	4b19      	ldr	r3, [pc, #100]	; (80057a8 <HAL_I2C_MspInit+0x78>)
 8005742:	429a      	cmp	r2, r3
 8005744:	d001      	beq.n	800574a <HAL_I2C_MspInit+0x1a>
  /* USER CODE BEGIN I2C2_MspInit 1 */

  /* USER CODE END I2C2_MspInit 1 */
  }

}
 8005746:	b006      	add	sp, #24
 8005748:	bd10      	pop	{r4, pc}
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800574a:	4c18      	ldr	r4, [pc, #96]	; (80057ac <HAL_I2C_MspInit+0x7c>)
 800574c:	69a3      	ldr	r3, [r4, #24]
 800574e:	f043 0308 	orr.w	r3, r3, #8
 8005752:	61a3      	str	r3, [r4, #24]
 8005754:	69a3      	ldr	r3, [r4, #24]
 8005756:	f003 0308 	and.w	r3, r3, #8
 800575a:	9300      	str	r3, [sp, #0]
 800575c:	9b00      	ldr	r3, [sp, #0]
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
 800575e:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 8005762:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8005764:	2312      	movs	r3, #18
 8005766:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005768:	2303      	movs	r3, #3
 800576a:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800576c:	a902      	add	r1, sp, #8
 800576e:	4810      	ldr	r0, [pc, #64]	; (80057b0 <HAL_I2C_MspInit+0x80>)
 8005770:	f7fb fc8c 	bl	800108c <HAL_GPIO_Init>
    __HAL_RCC_I2C2_CLK_ENABLE();
 8005774:	69e3      	ldr	r3, [r4, #28]
 8005776:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 800577a:	61e3      	str	r3, [r4, #28]
 800577c:	69e3      	ldr	r3, [r4, #28]
 800577e:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8005782:	9301      	str	r3, [sp, #4]
 8005784:	9b01      	ldr	r3, [sp, #4]
    HAL_NVIC_SetPriority(I2C2_EV_IRQn, 5, 0);
 8005786:	2200      	movs	r2, #0
 8005788:	2105      	movs	r1, #5
 800578a:	2021      	movs	r0, #33	; 0x21
 800578c:	f7fb f8aa 	bl	80008e4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C2_EV_IRQn);
 8005790:	2021      	movs	r0, #33	; 0x21
 8005792:	f7fb f8ed 	bl	8000970 <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(I2C2_ER_IRQn, 5, 0);
 8005796:	2200      	movs	r2, #0
 8005798:	2105      	movs	r1, #5
 800579a:	2022      	movs	r0, #34	; 0x22
 800579c:	f7fb f8a2 	bl	80008e4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C2_ER_IRQn);
 80057a0:	2022      	movs	r0, #34	; 0x22
 80057a2:	f7fb f8e5 	bl	8000970 <HAL_NVIC_EnableIRQ>
}
 80057a6:	e7ce      	b.n	8005746 <HAL_I2C_MspInit+0x16>
 80057a8:	40005800 	.word	0x40005800
 80057ac:	40021000 	.word	0x40021000
 80057b0:	40010c00 	.word	0x40010c00

080057b4 <HAL_TIM_PWM_MspInit>:
* This function configures the hardware resources used in this example
* @param htim_pwm: TIM_PWM handle pointer
* @retval None
*/
void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef* htim_pwm)
{
 80057b4:	b086      	sub	sp, #24
  if(htim_pwm->Instance==TIM1)
 80057b6:	6803      	ldr	r3, [r0, #0]
 80057b8:	4a2a      	ldr	r2, [pc, #168]	; (8005864 <HAL_TIM_PWM_MspInit+0xb0>)
 80057ba:	4293      	cmp	r3, r2
 80057bc:	d019      	beq.n	80057f2 <HAL_TIM_PWM_MspInit+0x3e>
    __HAL_RCC_TIM1_CLK_ENABLE();
  /* USER CODE BEGIN TIM1_MspInit 1 */

  /* USER CODE END TIM1_MspInit 1 */
  }
  else if(htim_pwm->Instance==TIM2)
 80057be:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80057c2:	d022      	beq.n	800580a <HAL_TIM_PWM_MspInit+0x56>
    __HAL_RCC_TIM2_CLK_ENABLE();
  /* USER CODE BEGIN TIM2_MspInit 1 */

  /* USER CODE END TIM2_MspInit 1 */
  }
  else if(htim_pwm->Instance==TIM3)
 80057c4:	4a28      	ldr	r2, [pc, #160]	; (8005868 <HAL_TIM_PWM_MspInit+0xb4>)
 80057c6:	4293      	cmp	r3, r2
 80057c8:	d02b      	beq.n	8005822 <HAL_TIM_PWM_MspInit+0x6e>
    __HAL_RCC_TIM3_CLK_ENABLE();
  /* USER CODE BEGIN TIM3_MspInit 1 */

  /* USER CODE END TIM3_MspInit 1 */
  }
  else if(htim_pwm->Instance==TIM4)
 80057ca:	4a28      	ldr	r2, [pc, #160]	; (800586c <HAL_TIM_PWM_MspInit+0xb8>)
 80057cc:	4293      	cmp	r3, r2
 80057ce:	d033      	beq.n	8005838 <HAL_TIM_PWM_MspInit+0x84>
    __HAL_RCC_TIM4_CLK_ENABLE();
  /* USER CODE BEGIN TIM4_MspInit 1 */

  /* USER CODE END TIM4_MspInit 1 */
  }
  else if(htim_pwm->Instance==TIM5)
 80057d0:	4a27      	ldr	r2, [pc, #156]	; (8005870 <HAL_TIM_PWM_MspInit+0xbc>)
 80057d2:	4293      	cmp	r3, r2
 80057d4:	d03b      	beq.n	800584e <HAL_TIM_PWM_MspInit+0x9a>
    __HAL_RCC_TIM5_CLK_ENABLE();
  /* USER CODE BEGIN TIM5_MspInit 1 */

  /* USER CODE END TIM5_MspInit 1 */
  }
  else if(htim_pwm->Instance==TIM8)
 80057d6:	4a27      	ldr	r2, [pc, #156]	; (8005874 <HAL_TIM_PWM_MspInit+0xc0>)
 80057d8:	4293      	cmp	r3, r2
 80057da:	d114      	bne.n	8005806 <HAL_TIM_PWM_MspInit+0x52>
  {
  /* USER CODE BEGIN TIM8_MspInit 0 */

  /* USER CODE END TIM8_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM8_CLK_ENABLE();
 80057dc:	4b26      	ldr	r3, [pc, #152]	; (8005878 <HAL_TIM_PWM_MspInit+0xc4>)
 80057de:	699a      	ldr	r2, [r3, #24]
 80057e0:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 80057e4:	619a      	str	r2, [r3, #24]
 80057e6:	699b      	ldr	r3, [r3, #24]
 80057e8:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 80057ec:	9305      	str	r3, [sp, #20]
 80057ee:	9b05      	ldr	r3, [sp, #20]
  /* USER CODE BEGIN TIM8_MspInit 1 */

  /* USER CODE END TIM8_MspInit 1 */
  }

}
 80057f0:	e009      	b.n	8005806 <HAL_TIM_PWM_MspInit+0x52>
    __HAL_RCC_TIM1_CLK_ENABLE();
 80057f2:	4b21      	ldr	r3, [pc, #132]	; (8005878 <HAL_TIM_PWM_MspInit+0xc4>)
 80057f4:	699a      	ldr	r2, [r3, #24]
 80057f6:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 80057fa:	619a      	str	r2, [r3, #24]
 80057fc:	699b      	ldr	r3, [r3, #24]
 80057fe:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8005802:	9300      	str	r3, [sp, #0]
 8005804:	9b00      	ldr	r3, [sp, #0]
}
 8005806:	b006      	add	sp, #24
 8005808:	4770      	bx	lr
    __HAL_RCC_TIM2_CLK_ENABLE();
 800580a:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
 800580e:	69da      	ldr	r2, [r3, #28]
 8005810:	f042 0201 	orr.w	r2, r2, #1
 8005814:	61da      	str	r2, [r3, #28]
 8005816:	69db      	ldr	r3, [r3, #28]
 8005818:	f003 0301 	and.w	r3, r3, #1
 800581c:	9301      	str	r3, [sp, #4]
 800581e:	9b01      	ldr	r3, [sp, #4]
 8005820:	e7f1      	b.n	8005806 <HAL_TIM_PWM_MspInit+0x52>
    __HAL_RCC_TIM3_CLK_ENABLE();
 8005822:	4b15      	ldr	r3, [pc, #84]	; (8005878 <HAL_TIM_PWM_MspInit+0xc4>)
 8005824:	69da      	ldr	r2, [r3, #28]
 8005826:	f042 0202 	orr.w	r2, r2, #2
 800582a:	61da      	str	r2, [r3, #28]
 800582c:	69db      	ldr	r3, [r3, #28]
 800582e:	f003 0302 	and.w	r3, r3, #2
 8005832:	9302      	str	r3, [sp, #8]
 8005834:	9b02      	ldr	r3, [sp, #8]
 8005836:	e7e6      	b.n	8005806 <HAL_TIM_PWM_MspInit+0x52>
    __HAL_RCC_TIM4_CLK_ENABLE();
 8005838:	4b0f      	ldr	r3, [pc, #60]	; (8005878 <HAL_TIM_PWM_MspInit+0xc4>)
 800583a:	69da      	ldr	r2, [r3, #28]
 800583c:	f042 0204 	orr.w	r2, r2, #4
 8005840:	61da      	str	r2, [r3, #28]
 8005842:	69db      	ldr	r3, [r3, #28]
 8005844:	f003 0304 	and.w	r3, r3, #4
 8005848:	9303      	str	r3, [sp, #12]
 800584a:	9b03      	ldr	r3, [sp, #12]
 800584c:	e7db      	b.n	8005806 <HAL_TIM_PWM_MspInit+0x52>
    __HAL_RCC_TIM5_CLK_ENABLE();
 800584e:	4b0a      	ldr	r3, [pc, #40]	; (8005878 <HAL_TIM_PWM_MspInit+0xc4>)
 8005850:	69da      	ldr	r2, [r3, #28]
 8005852:	f042 0208 	orr.w	r2, r2, #8
 8005856:	61da      	str	r2, [r3, #28]
 8005858:	69db      	ldr	r3, [r3, #28]
 800585a:	f003 0308 	and.w	r3, r3, #8
 800585e:	9304      	str	r3, [sp, #16]
 8005860:	9b04      	ldr	r3, [sp, #16]
 8005862:	e7d0      	b.n	8005806 <HAL_TIM_PWM_MspInit+0x52>
 8005864:	40012c00 	.word	0x40012c00
 8005868:	40000400 	.word	0x40000400
 800586c:	40000800 	.word	0x40000800
 8005870:	40000c00 	.word	0x40000c00
 8005874:	40013400 	.word	0x40013400
 8005878:	40021000 	.word	0x40021000

0800587c <HAL_TIM_MspPostInit>:

void HAL_TIM_MspPostInit(TIM_HandleTypeDef* htim)
{
 800587c:	b530      	push	{r4, r5, lr}
 800587e:	b08d      	sub	sp, #52	; 0x34
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8005880:	2300      	movs	r3, #0
 8005882:	9308      	str	r3, [sp, #32]
 8005884:	9309      	str	r3, [sp, #36]	; 0x24
 8005886:	930a      	str	r3, [sp, #40]	; 0x28
 8005888:	930b      	str	r3, [sp, #44]	; 0x2c
  if(htim->Instance==TIM1)
 800588a:	6803      	ldr	r3, [r0, #0]
 800588c:	4a61      	ldr	r2, [pc, #388]	; (8005a14 <HAL_TIM_MspPostInit+0x198>)
 800588e:	4293      	cmp	r3, r2
 8005890:	d012      	beq.n	80058b8 <HAL_TIM_MspPostInit+0x3c>

  /* USER CODE BEGIN TIM1_MspPostInit 1 */

  /* USER CODE END TIM1_MspPostInit 1 */
  }
  else if(htim->Instance==TIM2)
 8005892:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8005896:	d025      	beq.n	80058e4 <HAL_TIM_MspPostInit+0x68>

  /* USER CODE BEGIN TIM2_MspPostInit 1 */

  /* USER CODE END TIM2_MspPostInit 1 */
  }
  else if(htim->Instance==TIM3)
 8005898:	4a5f      	ldr	r2, [pc, #380]	; (8005a18 <HAL_TIM_MspPostInit+0x19c>)
 800589a:	4293      	cmp	r3, r2
 800589c:	d053      	beq.n	8005946 <HAL_TIM_MspPostInit+0xca>

  /* USER CODE BEGIN TIM3_MspPostInit 1 */

  /* USER CODE END TIM3_MspPostInit 1 */
  }
  else if(htim->Instance==TIM4)
 800589e:	4a5f      	ldr	r2, [pc, #380]	; (8005a1c <HAL_TIM_MspPostInit+0x1a0>)
 80058a0:	4293      	cmp	r3, r2
 80058a2:	d075      	beq.n	8005990 <HAL_TIM_MspPostInit+0x114>

  /* USER CODE BEGIN TIM4_MspPostInit 1 */

  /* USER CODE END TIM4_MspPostInit 1 */
  }
  else if(htim->Instance==TIM5)
 80058a4:	4a5e      	ldr	r2, [pc, #376]	; (8005a20 <HAL_TIM_MspPostInit+0x1a4>)
 80058a6:	4293      	cmp	r3, r2
 80058a8:	f000 8088 	beq.w	80059bc <HAL_TIM_MspPostInit+0x140>

  /* USER CODE BEGIN TIM5_MspPostInit 1 */

  /* USER CODE END TIM5_MspPostInit 1 */
  }
  else if(htim->Instance==TIM8)
 80058ac:	4a5d      	ldr	r2, [pc, #372]	; (8005a24 <HAL_TIM_MspPostInit+0x1a8>)
 80058ae:	4293      	cmp	r3, r2
 80058b0:	f000 8099 	beq.w	80059e6 <HAL_TIM_MspPostInit+0x16a>
  /* USER CODE BEGIN TIM8_MspPostInit 1 */

  /* USER CODE END TIM8_MspPostInit 1 */
  }

}
 80058b4:	b00d      	add	sp, #52	; 0x34
 80058b6:	bd30      	pop	{r4, r5, pc}
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80058b8:	4b5b      	ldr	r3, [pc, #364]	; (8005a28 <HAL_TIM_MspPostInit+0x1ac>)
 80058ba:	699a      	ldr	r2, [r3, #24]
 80058bc:	f042 0204 	orr.w	r2, r2, #4
 80058c0:	619a      	str	r2, [r3, #24]
 80058c2:	699b      	ldr	r3, [r3, #24]
 80058c4:	f003 0304 	and.w	r3, r3, #4
 80058c8:	9300      	str	r3, [sp, #0]
 80058ca:	9b00      	ldr	r3, [sp, #0]
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11;
 80058cc:	f44f 6370 	mov.w	r3, #3840	; 0xf00
 80058d0:	9308      	str	r3, [sp, #32]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80058d2:	2302      	movs	r3, #2
 80058d4:	9309      	str	r3, [sp, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 80058d6:	2303      	movs	r3, #3
 80058d8:	930b      	str	r3, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80058da:	a908      	add	r1, sp, #32
 80058dc:	4853      	ldr	r0, [pc, #332]	; (8005a2c <HAL_TIM_MspPostInit+0x1b0>)
 80058de:	f7fb fbd5 	bl	800108c <HAL_GPIO_Init>
 80058e2:	e7e7      	b.n	80058b4 <HAL_TIM_MspPostInit+0x38>
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80058e4:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
 80058e8:	699a      	ldr	r2, [r3, #24]
 80058ea:	f042 0204 	orr.w	r2, r2, #4
 80058ee:	619a      	str	r2, [r3, #24]
 80058f0:	699a      	ldr	r2, [r3, #24]
 80058f2:	f002 0204 	and.w	r2, r2, #4
 80058f6:	9201      	str	r2, [sp, #4]
 80058f8:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80058fa:	699a      	ldr	r2, [r3, #24]
 80058fc:	f042 0208 	orr.w	r2, r2, #8
 8005900:	619a      	str	r2, [r3, #24]
 8005902:	699b      	ldr	r3, [r3, #24]
 8005904:	f003 0308 	and.w	r3, r3, #8
 8005908:	9302      	str	r3, [sp, #8]
 800590a:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pin = GPIO_PIN_15;
 800590c:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8005910:	9308      	str	r3, [sp, #32]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005912:	2502      	movs	r5, #2
 8005914:	9509      	str	r5, [sp, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005916:	2403      	movs	r4, #3
 8005918:	940b      	str	r4, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800591a:	a908      	add	r1, sp, #32
 800591c:	4843      	ldr	r0, [pc, #268]	; (8005a2c <HAL_TIM_MspPostInit+0x1b0>)
 800591e:	f7fb fbb5 	bl	800108c <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_3;
 8005922:	2308      	movs	r3, #8
 8005924:	9308      	str	r3, [sp, #32]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005926:	9509      	str	r5, [sp, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005928:	940b      	str	r4, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800592a:	a908      	add	r1, sp, #32
 800592c:	4840      	ldr	r0, [pc, #256]	; (8005a30 <HAL_TIM_MspPostInit+0x1b4>)
 800592e:	f7fb fbad 	bl	800108c <HAL_GPIO_Init>
    __HAL_AFIO_REMAP_TIM2_PARTIAL_1();
 8005932:	4a40      	ldr	r2, [pc, #256]	; (8005a34 <HAL_TIM_MspPostInit+0x1b8>)
 8005934:	6853      	ldr	r3, [r2, #4]
 8005936:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800593a:	f043 63e0 	orr.w	r3, r3, #117440512	; 0x7000000
 800593e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8005942:	6053      	str	r3, [r2, #4]
 8005944:	e7b6      	b.n	80058b4 <HAL_TIM_MspPostInit+0x38>
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8005946:	4b38      	ldr	r3, [pc, #224]	; (8005a28 <HAL_TIM_MspPostInit+0x1ac>)
 8005948:	699a      	ldr	r2, [r3, #24]
 800594a:	f042 0204 	orr.w	r2, r2, #4
 800594e:	619a      	str	r2, [r3, #24]
 8005950:	699a      	ldr	r2, [r3, #24]
 8005952:	f002 0204 	and.w	r2, r2, #4
 8005956:	9203      	str	r2, [sp, #12]
 8005958:	9a03      	ldr	r2, [sp, #12]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800595a:	699a      	ldr	r2, [r3, #24]
 800595c:	f042 0208 	orr.w	r2, r2, #8
 8005960:	619a      	str	r2, [r3, #24]
 8005962:	699b      	ldr	r3, [r3, #24]
 8005964:	f003 0308 	and.w	r3, r3, #8
 8005968:	9304      	str	r3, [sp, #16]
 800596a:	9b04      	ldr	r3, [sp, #16]
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
 800596c:	23c0      	movs	r3, #192	; 0xc0
 800596e:	9308      	str	r3, [sp, #32]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005970:	2502      	movs	r5, #2
 8005972:	9509      	str	r5, [sp, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005974:	2403      	movs	r4, #3
 8005976:	940b      	str	r4, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8005978:	a908      	add	r1, sp, #32
 800597a:	482c      	ldr	r0, [pc, #176]	; (8005a2c <HAL_TIM_MspPostInit+0x1b0>)
 800597c:	f7fb fb86 	bl	800108c <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1;
 8005980:	9408      	str	r4, [sp, #32]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005982:	9509      	str	r5, [sp, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005984:	940b      	str	r4, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8005986:	a908      	add	r1, sp, #32
 8005988:	4829      	ldr	r0, [pc, #164]	; (8005a30 <HAL_TIM_MspPostInit+0x1b4>)
 800598a:	f7fb fb7f 	bl	800108c <HAL_GPIO_Init>
 800598e:	e791      	b.n	80058b4 <HAL_TIM_MspPostInit+0x38>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8005990:	4b25      	ldr	r3, [pc, #148]	; (8005a28 <HAL_TIM_MspPostInit+0x1ac>)
 8005992:	699a      	ldr	r2, [r3, #24]
 8005994:	f042 0208 	orr.w	r2, r2, #8
 8005998:	619a      	str	r2, [r3, #24]
 800599a:	699b      	ldr	r3, [r3, #24]
 800599c:	f003 0308 	and.w	r3, r3, #8
 80059a0:	9305      	str	r3, [sp, #20]
 80059a2:	9b05      	ldr	r3, [sp, #20]
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9;
 80059a4:	f44f 7370 	mov.w	r3, #960	; 0x3c0
 80059a8:	9308      	str	r3, [sp, #32]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80059aa:	2302      	movs	r3, #2
 80059ac:	9309      	str	r3, [sp, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 80059ae:	2303      	movs	r3, #3
 80059b0:	930b      	str	r3, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80059b2:	a908      	add	r1, sp, #32
 80059b4:	481e      	ldr	r0, [pc, #120]	; (8005a30 <HAL_TIM_MspPostInit+0x1b4>)
 80059b6:	f7fb fb69 	bl	800108c <HAL_GPIO_Init>
 80059ba:	e77b      	b.n	80058b4 <HAL_TIM_MspPostInit+0x38>
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80059bc:	4b1a      	ldr	r3, [pc, #104]	; (8005a28 <HAL_TIM_MspPostInit+0x1ac>)
 80059be:	699a      	ldr	r2, [r3, #24]
 80059c0:	f042 0204 	orr.w	r2, r2, #4
 80059c4:	619a      	str	r2, [r3, #24]
 80059c6:	699b      	ldr	r3, [r3, #24]
 80059c8:	f003 0304 	and.w	r3, r3, #4
 80059cc:	9306      	str	r3, [sp, #24]
 80059ce:	9b06      	ldr	r3, [sp, #24]
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3;
 80059d0:	230e      	movs	r3, #14
 80059d2:	9308      	str	r3, [sp, #32]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80059d4:	2302      	movs	r3, #2
 80059d6:	9309      	str	r3, [sp, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 80059d8:	2303      	movs	r3, #3
 80059da:	930b      	str	r3, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80059dc:	a908      	add	r1, sp, #32
 80059de:	4813      	ldr	r0, [pc, #76]	; (8005a2c <HAL_TIM_MspPostInit+0x1b0>)
 80059e0:	f7fb fb54 	bl	800108c <HAL_GPIO_Init>
 80059e4:	e766      	b.n	80058b4 <HAL_TIM_MspPostInit+0x38>
    __HAL_RCC_GPIOC_CLK_ENABLE();
 80059e6:	4b10      	ldr	r3, [pc, #64]	; (8005a28 <HAL_TIM_MspPostInit+0x1ac>)
 80059e8:	699a      	ldr	r2, [r3, #24]
 80059ea:	f042 0210 	orr.w	r2, r2, #16
 80059ee:	619a      	str	r2, [r3, #24]
 80059f0:	699b      	ldr	r3, [r3, #24]
 80059f2:	f003 0310 	and.w	r3, r3, #16
 80059f6:	9307      	str	r3, [sp, #28]
 80059f8:	9b07      	ldr	r3, [sp, #28]
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9;
 80059fa:	f44f 7370 	mov.w	r3, #960	; 0x3c0
 80059fe:	9308      	str	r3, [sp, #32]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005a00:	2302      	movs	r3, #2
 8005a02:	9309      	str	r3, [sp, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005a04:	2303      	movs	r3, #3
 8005a06:	930b      	str	r3, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8005a08:	a908      	add	r1, sp, #32
 8005a0a:	480b      	ldr	r0, [pc, #44]	; (8005a38 <HAL_TIM_MspPostInit+0x1bc>)
 8005a0c:	f7fb fb3e 	bl	800108c <HAL_GPIO_Init>
}
 8005a10:	e750      	b.n	80058b4 <HAL_TIM_MspPostInit+0x38>
 8005a12:	bf00      	nop
 8005a14:	40012c00 	.word	0x40012c00
 8005a18:	40000400 	.word	0x40000400
 8005a1c:	40000800 	.word	0x40000800
 8005a20:	40000c00 	.word	0x40000c00
 8005a24:	40013400 	.word	0x40013400
 8005a28:	40021000 	.word	0x40021000
 8005a2c:	40010800 	.word	0x40010800
 8005a30:	40010c00 	.word	0x40010c00
 8005a34:	40010000 	.word	0x40010000
 8005a38:	40011000 	.word	0x40011000

08005a3c <HAL_UART_MspInit>:
* This function configures the hardware resources used in this example
* @param huart: UART handle pointer
* @retval None
*/
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 8005a3c:	b570      	push	{r4, r5, r6, lr}
 8005a3e:	b086      	sub	sp, #24
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8005a40:	2300      	movs	r3, #0
 8005a42:	9302      	str	r3, [sp, #8]
 8005a44:	9303      	str	r3, [sp, #12]
 8005a46:	9304      	str	r3, [sp, #16]
 8005a48:	9305      	str	r3, [sp, #20]
  if(huart->Instance==UART4)
 8005a4a:	6802      	ldr	r2, [r0, #0]
 8005a4c:	4b33      	ldr	r3, [pc, #204]	; (8005b1c <HAL_UART_MspInit+0xe0>)
 8005a4e:	429a      	cmp	r2, r3
 8005a50:	d001      	beq.n	8005a56 <HAL_UART_MspInit+0x1a>
  /* USER CODE BEGIN UART4_MspInit 1 */

  /* USER CODE END UART4_MspInit 1 */
  }

}
 8005a52:	b006      	add	sp, #24
 8005a54:	bd70      	pop	{r4, r5, r6, pc}
 8005a56:	4604      	mov	r4, r0
    __HAL_RCC_UART4_CLK_ENABLE();
 8005a58:	f503 33e2 	add.w	r3, r3, #115712	; 0x1c400
 8005a5c:	69da      	ldr	r2, [r3, #28]
 8005a5e:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 8005a62:	61da      	str	r2, [r3, #28]
 8005a64:	69da      	ldr	r2, [r3, #28]
 8005a66:	f402 2200 	and.w	r2, r2, #524288	; 0x80000
 8005a6a:	9200      	str	r2, [sp, #0]
 8005a6c:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8005a6e:	699a      	ldr	r2, [r3, #24]
 8005a70:	f042 0210 	orr.w	r2, r2, #16
 8005a74:	619a      	str	r2, [r3, #24]
 8005a76:	699b      	ldr	r3, [r3, #24]
 8005a78:	f003 0310 	and.w	r3, r3, #16
 8005a7c:	9301      	str	r3, [sp, #4]
 8005a7e:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Pin = GPIO_PIN_10;
 8005a80:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8005a84:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005a86:	2302      	movs	r3, #2
 8005a88:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005a8a:	2303      	movs	r3, #3
 8005a8c:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8005a8e:	4e24      	ldr	r6, [pc, #144]	; (8005b20 <HAL_UART_MspInit+0xe4>)
 8005a90:	a902      	add	r1, sp, #8
 8005a92:	4630      	mov	r0, r6
 8005a94:	f7fb fafa 	bl	800108c <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_11;
 8005a98:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8005a9c:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8005a9e:	2500      	movs	r5, #0
 8005aa0:	9503      	str	r5, [sp, #12]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005aa2:	9504      	str	r5, [sp, #16]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8005aa4:	a902      	add	r1, sp, #8
 8005aa6:	4630      	mov	r0, r6
 8005aa8:	f7fb faf0 	bl	800108c <HAL_GPIO_Init>
    hdma_uart4_tx.Instance = DMA2_Channel5;
 8005aac:	481d      	ldr	r0, [pc, #116]	; (8005b24 <HAL_UART_MspInit+0xe8>)
 8005aae:	4b1e      	ldr	r3, [pc, #120]	; (8005b28 <HAL_UART_MspInit+0xec>)
 8005ab0:	6003      	str	r3, [r0, #0]
    hdma_uart4_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8005ab2:	2310      	movs	r3, #16
 8005ab4:	6043      	str	r3, [r0, #4]
    hdma_uart4_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 8005ab6:	6085      	str	r5, [r0, #8]
    hdma_uart4_tx.Init.MemInc = DMA_MINC_ENABLE;
 8005ab8:	2380      	movs	r3, #128	; 0x80
 8005aba:	60c3      	str	r3, [r0, #12]
    hdma_uart4_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 8005abc:	6105      	str	r5, [r0, #16]
    hdma_uart4_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8005abe:	6145      	str	r5, [r0, #20]
    hdma_uart4_tx.Init.Mode = DMA_NORMAL;
 8005ac0:	6185      	str	r5, [r0, #24]
    hdma_uart4_tx.Init.Priority = DMA_PRIORITY_MEDIUM;
 8005ac2:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8005ac6:	61c3      	str	r3, [r0, #28]
    if (HAL_DMA_Init(&hdma_uart4_tx) != HAL_OK)
 8005ac8:	f7fa ff96 	bl	80009f8 <HAL_DMA_Init>
 8005acc:	b9f8      	cbnz	r0, 8005b0e <HAL_UART_MspInit+0xd2>
    __HAL_LINKDMA(huart,hdmatx,hdma_uart4_tx);
 8005ace:	4b15      	ldr	r3, [pc, #84]	; (8005b24 <HAL_UART_MspInit+0xe8>)
 8005ad0:	6323      	str	r3, [r4, #48]	; 0x30
 8005ad2:	625c      	str	r4, [r3, #36]	; 0x24
    hdma_uart4_rx.Instance = DMA2_Channel3;
 8005ad4:	4815      	ldr	r0, [pc, #84]	; (8005b2c <HAL_UART_MspInit+0xf0>)
 8005ad6:	4b16      	ldr	r3, [pc, #88]	; (8005b30 <HAL_UART_MspInit+0xf4>)
 8005ad8:	6003      	str	r3, [r0, #0]
    hdma_uart4_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 8005ada:	2300      	movs	r3, #0
 8005adc:	6043      	str	r3, [r0, #4]
    hdma_uart4_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 8005ade:	6083      	str	r3, [r0, #8]
    hdma_uart4_rx.Init.MemInc = DMA_MINC_ENABLE;
 8005ae0:	2280      	movs	r2, #128	; 0x80
 8005ae2:	60c2      	str	r2, [r0, #12]
    hdma_uart4_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 8005ae4:	6103      	str	r3, [r0, #16]
    hdma_uart4_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8005ae6:	6143      	str	r3, [r0, #20]
    hdma_uart4_rx.Init.Mode = DMA_NORMAL;
 8005ae8:	6183      	str	r3, [r0, #24]
    hdma_uart4_rx.Init.Priority = DMA_PRIORITY_MEDIUM;
 8005aea:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8005aee:	61c3      	str	r3, [r0, #28]
    if (HAL_DMA_Init(&hdma_uart4_rx) != HAL_OK)
 8005af0:	f7fa ff82 	bl	80009f8 <HAL_DMA_Init>
 8005af4:	b970      	cbnz	r0, 8005b14 <HAL_UART_MspInit+0xd8>
    __HAL_LINKDMA(huart,hdmarx,hdma_uart4_rx);
 8005af6:	4b0d      	ldr	r3, [pc, #52]	; (8005b2c <HAL_UART_MspInit+0xf0>)
 8005af8:	6363      	str	r3, [r4, #52]	; 0x34
 8005afa:	625c      	str	r4, [r3, #36]	; 0x24
    HAL_NVIC_SetPriority(UART4_IRQn, 5, 0);
 8005afc:	2200      	movs	r2, #0
 8005afe:	2105      	movs	r1, #5
 8005b00:	2034      	movs	r0, #52	; 0x34
 8005b02:	f7fa feef 	bl	80008e4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(UART4_IRQn);
 8005b06:	2034      	movs	r0, #52	; 0x34
 8005b08:	f7fa ff32 	bl	8000970 <HAL_NVIC_EnableIRQ>
}
 8005b0c:	e7a1      	b.n	8005a52 <HAL_UART_MspInit+0x16>
      Error_Handler();
 8005b0e:	f7ff fa37 	bl	8004f80 <Error_Handler>
 8005b12:	e7dc      	b.n	8005ace <HAL_UART_MspInit+0x92>
      Error_Handler();
 8005b14:	f7ff fa34 	bl	8004f80 <Error_Handler>
 8005b18:	e7ed      	b.n	8005af6 <HAL_UART_MspInit+0xba>
 8005b1a:	bf00      	nop
 8005b1c:	40004c00 	.word	0x40004c00
 8005b20:	40011000 	.word	0x40011000
 8005b24:	20001290 	.word	0x20001290
 8005b28:	40020458 	.word	0x40020458
 8005b2c:	20000fcc 	.word	0x20000fcc
 8005b30:	40020430 	.word	0x40020430

08005b34 <NMI_Handler>:

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
 8005b34:	4770      	bx	lr

08005b36 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8005b36:	e7fe      	b.n	8005b36 <HardFault_Handler>

08005b38 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8005b38:	e7fe      	b.n	8005b38 <MemManage_Handler>

08005b3a <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 8005b3a:	e7fe      	b.n	8005b3a <BusFault_Handler>

08005b3c <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 8005b3c:	e7fe      	b.n	8005b3c <UsageFault_Handler>

08005b3e <DebugMon_Handler>:

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 8005b3e:	4770      	bx	lr

08005b40 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 8005b40:	b508      	push	{r3, lr}
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8005b42:	f7fa fe9f 	bl	8000884 <HAL_IncTick>
#if (INCLUDE_xTaskGetSchedulerState == 1 )
  if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
 8005b46:	f7fe fdef 	bl	8004728 <xTaskGetSchedulerState>
 8005b4a:	2801      	cmp	r0, #1
 8005b4c:	d001      	beq.n	8005b52 <SysTick_Handler+0x12>
  {
#endif /* INCLUDE_xTaskGetSchedulerState */
  xPortSysTickHandler();
 8005b4e:	f7fe feb1 	bl	80048b4 <xPortSysTickHandler>
  }
#endif /* INCLUDE_xTaskGetSchedulerState */
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 8005b52:	bd08      	pop	{r3, pc}

08005b54 <I2C2_EV_IRQHandler>:

/**
  * @brief This function handles I2C2 event interrupt.
  */
void I2C2_EV_IRQHandler(void)
{
 8005b54:	b508      	push	{r3, lr}
  /* USER CODE BEGIN I2C2_EV_IRQn 0 */

  /* USER CODE END I2C2_EV_IRQn 0 */
  HAL_I2C_EV_IRQHandler(&hi2c2);
 8005b56:	4802      	ldr	r0, [pc, #8]	; (8005b60 <I2C2_EV_IRQHandler+0xc>)
 8005b58:	f7fc fc16 	bl	8002388 <HAL_I2C_EV_IRQHandler>
  /* USER CODE BEGIN I2C2_EV_IRQn 1 */

  /* USER CODE END I2C2_EV_IRQn 1 */
}
 8005b5c:	bd08      	pop	{r3, pc}
 8005b5e:	bf00      	nop
 8005b60:	200010b4 	.word	0x200010b4

08005b64 <I2C2_ER_IRQHandler>:

/**
  * @brief This function handles I2C2 error interrupt.
  */
void I2C2_ER_IRQHandler(void)
{
 8005b64:	b508      	push	{r3, lr}
  /* USER CODE BEGIN I2C2_ER_IRQn 0 */

  /* USER CODE END I2C2_ER_IRQn 0 */
  HAL_I2C_ER_IRQHandler(&hi2c2);
 8005b66:	4802      	ldr	r0, [pc, #8]	; (8005b70 <I2C2_ER_IRQHandler+0xc>)
 8005b68:	f7fc fcdb 	bl	8002522 <HAL_I2C_ER_IRQHandler>
  /* USER CODE BEGIN I2C2_ER_IRQn 1 */

  /* USER CODE END I2C2_ER_IRQn 1 */
}
 8005b6c:	bd08      	pop	{r3, pc}
 8005b6e:	bf00      	nop
 8005b70:	200010b4 	.word	0x200010b4

08005b74 <UART4_IRQHandler>:

/**
  * @brief This function handles UART4 global interrupt.
  */
void UART4_IRQHandler(void)
{
 8005b74:	b508      	push	{r3, lr}
  /* USER CODE BEGIN UART4_IRQn 0 */

  /* USER CODE END UART4_IRQn 0 */
  HAL_UART_IRQHandler(&huart4);
 8005b76:	4802      	ldr	r0, [pc, #8]	; (8005b80 <UART4_IRQHandler+0xc>)
 8005b78:	f7fe f92a 	bl	8003dd0 <HAL_UART_IRQHandler>
  /* USER CODE BEGIN UART4_IRQn 1 */

  /* USER CODE END UART4_IRQn 1 */
}
 8005b7c:	bd08      	pop	{r3, pc}
 8005b7e:	bf00      	nop
 8005b80:	20001208 	.word	0x20001208

08005b84 <DMA2_Channel3_IRQHandler>:

/**
  * @brief This function handles DMA2 channel3 global interrupt.
  */
void DMA2_Channel3_IRQHandler(void)
{
 8005b84:	b508      	push	{r3, lr}
  /* USER CODE BEGIN DMA2_Channel3_IRQn 0 */

  /* USER CODE END DMA2_Channel3_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_uart4_rx);
 8005b86:	4802      	ldr	r0, [pc, #8]	; (8005b90 <DMA2_Channel3_IRQHandler+0xc>)
 8005b88:	f7fb f906 	bl	8000d98 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA2_Channel3_IRQn 1 */

  /* USER CODE END DMA2_Channel3_IRQn 1 */
}
 8005b8c:	bd08      	pop	{r3, pc}
 8005b8e:	bf00      	nop
 8005b90:	20000fcc 	.word	0x20000fcc

08005b94 <DMA2_Channel4_5_IRQHandler>:

/**
  * @brief This function handles DMA2 channel4 and channel5 global interrupts.
  */
void DMA2_Channel4_5_IRQHandler(void)
{
 8005b94:	b508      	push	{r3, lr}
  /* USER CODE BEGIN DMA2_Channel4_5_IRQn 0 */

  /* USER CODE END DMA2_Channel4_5_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_uart4_tx);
 8005b96:	4802      	ldr	r0, [pc, #8]	; (8005ba0 <DMA2_Channel4_5_IRQHandler+0xc>)
 8005b98:	f7fb f8fe 	bl	8000d98 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA2_Channel4_5_IRQn 1 */

  /* USER CODE END DMA2_Channel4_5_IRQn 1 */
}
 8005b9c:	bd08      	pop	{r3, pc}
 8005b9e:	bf00      	nop
 8005ba0:	20001290 	.word	0x20001290

08005ba4 <SystemInit>:
  */
void SystemInit (void)
{
  /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
  /* Set HSION bit */
  RCC->CR |= 0x00000001U;
 8005ba4:	4b0f      	ldr	r3, [pc, #60]	; (8005be4 <SystemInit+0x40>)
 8005ba6:	681a      	ldr	r2, [r3, #0]
 8005ba8:	f042 0201 	orr.w	r2, r2, #1
 8005bac:	601a      	str	r2, [r3, #0]

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#if !defined(STM32F105xC) && !defined(STM32F107xC)
  RCC->CFGR &= 0xF8FF0000U;
 8005bae:	6859      	ldr	r1, [r3, #4]
 8005bb0:	4a0d      	ldr	r2, [pc, #52]	; (8005be8 <SystemInit+0x44>)
 8005bb2:	400a      	ands	r2, r1
 8005bb4:	605a      	str	r2, [r3, #4]
#else
  RCC->CFGR &= 0xF0FF0000U;
#endif /* STM32F105xC */   
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= 0xFEF6FFFFU;
 8005bb6:	681a      	ldr	r2, [r3, #0]
 8005bb8:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 8005bbc:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8005bc0:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
 8005bc2:	681a      	ldr	r2, [r3, #0]
 8005bc4:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8005bc8:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
  RCC->CFGR &= 0xFF80FFFFU;
 8005bca:	685a      	ldr	r2, [r3, #4]
 8005bcc:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
 8005bd0:	605a      	str	r2, [r3, #4]

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000U;      
#else
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000U;
 8005bd2:	f44f 021f 	mov.w	r2, #10420224	; 0x9f0000
 8005bd6:	609a      	str	r2, [r3, #8]
#endif 

#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
 8005bd8:	4b04      	ldr	r3, [pc, #16]	; (8005bec <SystemInit+0x48>)
 8005bda:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8005bde:	609a      	str	r2, [r3, #8]
#endif 
}
 8005be0:	4770      	bx	lr
 8005be2:	bf00      	nop
 8005be4:	40021000 	.word	0x40021000
 8005be8:	f8ff0000 	.word	0xf8ff0000
 8005bec:	e000ed00 	.word	0xe000ed00

08005bf0 <Reset_Handler>:
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:

/* Copy the data segment initializers from flash to SRAM */
  movs r1, #0
 8005bf0:	2100      	movs	r1, #0
  b LoopCopyDataInit
 8005bf2:	e003      	b.n	8005bfc <LoopCopyDataInit>

08005bf4 <CopyDataInit>:

CopyDataInit:
  ldr r3, =_sidata
 8005bf4:	4b0b      	ldr	r3, [pc, #44]	; (8005c24 <LoopFillZerobss+0x14>)
  ldr r3, [r3, r1]
 8005bf6:	585b      	ldr	r3, [r3, r1]
  str r3, [r0, r1]
 8005bf8:	5043      	str	r3, [r0, r1]
  adds r1, r1, #4
 8005bfa:	3104      	adds	r1, #4

08005bfc <LoopCopyDataInit>:

LoopCopyDataInit:
  ldr r0, =_sdata
 8005bfc:	480a      	ldr	r0, [pc, #40]	; (8005c28 <LoopFillZerobss+0x18>)
  ldr r3, =_edata
 8005bfe:	4b0b      	ldr	r3, [pc, #44]	; (8005c2c <LoopFillZerobss+0x1c>)
  adds r2, r0, r1
 8005c00:	1842      	adds	r2, r0, r1
  cmp r2, r3
 8005c02:	429a      	cmp	r2, r3
  bcc CopyDataInit
 8005c04:	d3f6      	bcc.n	8005bf4 <CopyDataInit>
  ldr r2, =_sbss
 8005c06:	4a0a      	ldr	r2, [pc, #40]	; (8005c30 <LoopFillZerobss+0x20>)
  b LoopFillZerobss
 8005c08:	e002      	b.n	8005c10 <LoopFillZerobss>

08005c0a <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
  movs r3, #0
 8005c0a:	2300      	movs	r3, #0
  str r3, [r2], #4
 8005c0c:	f842 3b04 	str.w	r3, [r2], #4

08005c10 <LoopFillZerobss>:

LoopFillZerobss:
  ldr r3, = _ebss
 8005c10:	4b08      	ldr	r3, [pc, #32]	; (8005c34 <LoopFillZerobss+0x24>)
  cmp r2, r3
 8005c12:	429a      	cmp	r2, r3
  bcc FillZerobss
 8005c14:	d3f9      	bcc.n	8005c0a <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 8005c16:	f7ff ffc5 	bl	8005ba4 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8005c1a:	f000 f80f 	bl	8005c3c <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 8005c1e:	f7ff fc4b 	bl	80054b8 <main>
  bx lr
 8005c22:	4770      	bx	lr
  ldr r3, =_sidata
 8005c24:	08005f30 	.word	0x08005f30
  ldr r0, =_sdata
 8005c28:	20000000 	.word	0x20000000
  ldr r3, =_edata
 8005c2c:	20000010 	.word	0x20000010
  ldr r2, =_sbss
 8005c30:	20000010 	.word	0x20000010
  ldr r3, = _ebss
 8005c34:	200012d4 	.word	0x200012d4

08005c38 <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8005c38:	e7fe      	b.n	8005c38 <ADC1_2_IRQHandler>
	...

08005c3c <__libc_init_array>:
 8005c3c:	b570      	push	{r4, r5, r6, lr}
 8005c3e:	2500      	movs	r5, #0
 8005c40:	4e0c      	ldr	r6, [pc, #48]	; (8005c74 <__libc_init_array+0x38>)
 8005c42:	4c0d      	ldr	r4, [pc, #52]	; (8005c78 <__libc_init_array+0x3c>)
 8005c44:	1ba4      	subs	r4, r4, r6
 8005c46:	10a4      	asrs	r4, r4, #2
 8005c48:	42a5      	cmp	r5, r4
 8005c4a:	d109      	bne.n	8005c60 <__libc_init_array+0x24>
 8005c4c:	f000 f822 	bl	8005c94 <_init>
 8005c50:	2500      	movs	r5, #0
 8005c52:	4e0a      	ldr	r6, [pc, #40]	; (8005c7c <__libc_init_array+0x40>)
 8005c54:	4c0a      	ldr	r4, [pc, #40]	; (8005c80 <__libc_init_array+0x44>)
 8005c56:	1ba4      	subs	r4, r4, r6
 8005c58:	10a4      	asrs	r4, r4, #2
 8005c5a:	42a5      	cmp	r5, r4
 8005c5c:	d105      	bne.n	8005c6a <__libc_init_array+0x2e>
 8005c5e:	bd70      	pop	{r4, r5, r6, pc}
 8005c60:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8005c64:	4798      	blx	r3
 8005c66:	3501      	adds	r5, #1
 8005c68:	e7ee      	b.n	8005c48 <__libc_init_array+0xc>
 8005c6a:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8005c6e:	4798      	blx	r3
 8005c70:	3501      	adds	r5, #1
 8005c72:	e7f2      	b.n	8005c5a <__libc_init_array+0x1e>
 8005c74:	08005f28 	.word	0x08005f28
 8005c78:	08005f28 	.word	0x08005f28
 8005c7c:	08005f28 	.word	0x08005f28
 8005c80:	08005f2c 	.word	0x08005f2c

08005c84 <memset>:
 8005c84:	4603      	mov	r3, r0
 8005c86:	4402      	add	r2, r0
 8005c88:	4293      	cmp	r3, r2
 8005c8a:	d100      	bne.n	8005c8e <memset+0xa>
 8005c8c:	4770      	bx	lr
 8005c8e:	f803 1b01 	strb.w	r1, [r3], #1
 8005c92:	e7f9      	b.n	8005c88 <memset+0x4>

08005c94 <_init>:
 8005c94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005c96:	bf00      	nop
 8005c98:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8005c9a:	bc08      	pop	{r3}
 8005c9c:	469e      	mov	lr, r3
 8005c9e:	4770      	bx	lr

08005ca0 <_fini>:
 8005ca0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005ca2:	bf00      	nop
 8005ca4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8005ca6:	bc08      	pop	{r3}
 8005ca8:	469e      	mov	lr, r3
 8005caa:	4770      	bx	lr
